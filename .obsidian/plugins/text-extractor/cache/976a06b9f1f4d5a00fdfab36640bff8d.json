{"path":".obsidian/plugins/text-extractor/cache/976a06b9f1f4d5a00fdfab36640bff8d.json","text":"Linear Algebra Done Wrong Sergei Treil Department of Mathematics, Brown University Copyright c⃝ Sergei Treil, 2004, 2009, 2011, 2014, 2017 This book is licensed under a Creative Commons Attribution-NonCommercial-NoDerivs 3.0 Unported License, see https://creativecommons.org/licenses/by-nc-nd/3.0/ Additional details: You can use this book free of charge for non- commercial purposes, in particular for studying and/or teaching. You can print paper copies of the book or its parts using either personal printer or professional printing services. Instructors teaching a class (or their institu- tions) can provide students with printed copies of the book and charge the fee to cover the cost of printing; however the students should have an option to use the free electronic version. Preface The title of the book sounds a bit mysterious. Why should anyone read this book if it presents the subject in a wrong way? What is particularly done “wrong” in the book? Before answering these questions, let me ﬁrst describe the target au- dience of this text. This book appeared as lecture notes for the course “Honors Linear Algebra”. It supposed to be a ﬁrst linear algebra course for mathematically advanced students. It is intended for a student who, while not yet very familiar with abstract reasoning, is willing to study more rigor- ous mathematics than what is presented in a “cookbook style” calculus type course. Besides being a ﬁrst course in linear algebra it is also supposed to be a ﬁrst course introducing a student to rigorous proof, formal deﬁnitions—in short, to the style of modern theoretical (abstract) mathematics. The target audience explains the very speciﬁc blend of elementary ideas and concrete examples, which are usually presented in introductory linear algebra texts with more abstract deﬁnitions and constructions typical for advanced books. Another speciﬁc of the book is that it is not written by or for an alge- braist. So, I tried to emphasize the topics that are important for analysis, geometry, probability, etc., and did not include some traditional topics. For example, I am only considering vector spaces over the ﬁelds of real or com- plex numbers. Linear spaces over other ﬁelds are not considered at all, since I feel time required to introduce and explain abstract ﬁelds would be better spent on some more classical topics, which will be required in other dis- ciplines. And later, when the students study general ﬁelds in an abstract algebra course they will understand that many of the constructions studied in this book will also work for general ﬁelds. iii iv Preface Also, I treat only ﬁnite-dimensional spaces in this book and a basis always means a ﬁnite basis. The reason is that it is impossible to say some- thing non-trivial about inﬁnite-dimensional spaces without introducing con- vergence, norms, completeness etc., i.e. the basics of functional analysis. And this is deﬁnitely a subject for a separate course (text). So, I do not consider inﬁnite Hamel bases here: they are not needed in most applica- tions to analysis and geometry, and I feel they belong in an abstract algebra course. Notes for the instructor. There are several details that distinguish this text from standard advanced linear algebra textbooks. First concerns the deﬁnitions of bases, linearly independent, and generating sets. In the book I ﬁrst deﬁne a basis as a system with the property that any vector admits a unique representation as a linear combination. And then linear indepen- dence and generating system properties appear naturally as halves of the basis property, one being uniqueness and the other being existence of the representation. The reason for this approach is that I feel the concept of a basis is a much more important notion than linear independence: in most applications we really do not care about linear independence, we need a system to be a basis. For example, when solving a homogeneous system, we are not just looking for linearly independent solutions, but for the correct number of linearly independent solutions, i.e. for a basis in the solution space. And it is easy to explain to students, why bases are important: they allow us to introduce coordinates, and work with Rn (or Cn) instead of working with an abstract vector space. Furthermore, we need coordinates to perform computations using computers, and computers are well adapted to working with matrices. Also, I really do not know a simple motivation for the notion of linear independence. Another detail is that I introduce linear transformations before teach- ing how to solve linear systems. A disadvantage is that we did not prove until Chapter 2 that only a square matrix can be invertible as well as some other important facts. However, having already deﬁned linear transforma- tion allows more systematic presentation of row reduction. Also, I spend a lot of time (two sections) motivating matrix multiplication. I hope that I explained well why such a strange looking rule of multiplication is, in fact, a very natural one, and we really do not have any choice here. Many important facts about bases, linear transformations, etc., like the fact that any two bases in a vector space have the same number of vectors, are proved in Chapter 2 by counting pivots in the row reduction. While most of these facts have “coordinate free” proofs, formally not involving Gaussian Preface v elimination, a careful analysis of the proofs reveals that the Gaussian elim- ination and counting of the pivots do not disappear, they are just hidden in most of the proofs. So, instead of presenting very elegant (but not easy for a beginner to understand) “coordinate-free” proofs, which are typically presented in advanced linear algebra books, we use “row reduction” proofs, more common for the “calculus type” texts. The advantage here is that it is easy to see the common idea behind all the proofs, and such proofs are easier to understand and to remember for a reader who is not very mathematically sophisticated. I also present in Section 8 of Chapter 2 a simple and easy to remember formalism for the change of basis formula. Chapter 3 deals with determinants. I spent a lot of time presenting a motivation for the determinant, and only much later give formal deﬁnitions. Determinants are introduced as a way to compute volumes. It is shown that if we allow signed volumes, to make the determinant linear in each column (and at that point students should be well aware that the linearity helps a lot, and that allowing negative volumes is a very small price to pay for it), and assume some very natural properties, then we do not have any choice and arrive to the classical deﬁnition of the determinant. I would like to emphasize that initially I do not postulate antisymmetry of the determinant; I deduce it from other very natural properties of volume. Note, that while formally in Chapters 1–3 I was dealing mainly with real spaces, everything there holds for complex spaces, and moreover, even for the spaces over arbitrary ﬁelds. Chapter 4 is an introduction to spectral theory, and that is where the complex space Cn naturally appears. It was formally deﬁned in the begin- ning of the book, and the deﬁnition of a complex vector space was also given there, but before Chapter 4 the main object was the real space Rn. Now the appearance of complex eigenvalues shows that for spectral theory the most natural space is the complex space Cn, even if we are initially dealing with real matrices (operators in real spaces). The main accent here is on the diagonalization, and the notion of a basis of eigesnspaces is also introduced. Chapter 5 dealing with inner product spaces comes after spectral theory, because I wanted to do both the complex and the real cases simultaneously, and spectral theory provides a strong motivation for complex spaces. Other then the motivation, Chapters 4 and 5 do not depend on each other, and an instructor may do Chapter 5 ﬁrst. Although I present the Jordan canonical form in Chapter 9, I usually do not have time to cover it during a one-semester course. I prefer to spend more time on topics discussed in Chapters 6 and 7 such as diagonalization vi Preface of normal and self-adjoint operators, polar and singular values decomposi- tion, the structure of orthogonal matrices and orientation, and the theory of quadratic forms. I feel that these topics are more important for applications, then the Jordan canonical form, despite the deﬁnite beauty of the latter. However, I added Chapter 9 so the instructor may skip some of the topics in Chapters 6 and 7 and present the Jordan Decomposition Theorem instead. I also included (new for 2009) Chapter 8, dealing with dual spaces and tensors. I feel that the material there, especially sections about tensors, is a bit too advanced for a ﬁrst year linear algebra course, but some topics (for example, change of coordinates in the dual space) can be easily included in the syllabus. And it can be used as an introduction to tensors in a more advanced course. Note, that the results presented in this chapter are true for an arbitrary ﬁeld. I had tried to present the material in the book rather informally, prefer- ring intuitive geometric reasoning to formal algebraic manipulations, so to a purist the book may seem not suﬃciently rigorous. Throughout the book I usually (when it does not lead to the confusion) identify a linear transfor- mation and its matrix. This allows for a simpler notation, and I feel that overemphasizing the diﬀerence between a transformation and its matrix may confuse an inexperienced student. Only when the diﬀerence is crucial, for example when analyzing how the matrix of a transformation changes under the change of the basis, I use a special notation to distinguish between a transformation and its matrix. Contents Preface iii Chapter 1. Basic Notions 1 §1. Vector spaces 1 §2. Linear combinations, bases. 6 §3. Linear Transformations. Matrix–vector multiplication 12 §4. Linear transformations as a vector space 17 §5. Composition of linear transformations and matrix multiplication. 19 §6. Invertible transformations and matrices. Isomorphisms 24 §7. Subspaces. 30 §8. Application to computer graphics. 31 Chapter 2. Systems of linear equations 39 §1. Diﬀerent faces of linear systems. 39 §2. Solution of a linear system. Echelon and reduced echelon forms 40 §3. Analyzing the pivots. 46 §4. Finding A−1 by row reduction. 52 §5. Dimension. Finite-dimensional spaces. 54 §6. General solution of a linear system. 56 §7. Fundamental subspaces of a matrix. Rank. 59 §8. Representation of a linear transformation in arbitrary bases. Change of coordinates formula. 69 Chapter 3. Determinants 75 vii viii Contents §1. Introduction. 75 §2. What properties determinant should have. 76 §3. Constructing the determinant. 78 §4. Formal deﬁnition. Existence and uniqueness of the determinant. 86 §5. Cofactor expansion. 90 §6. Minors and rank. 96 §7. Review exercises for Chapter 3. 96 Chapter 4. Introduction to spectral theory (eigenvalues and eigenvectors) 99 §1. Main deﬁnitions 100 §2. Diagonalization. 105 Chapter 5. Inner product spaces 117 §1. Inner product in Rn and Cn. Inner product spaces. 117 §2. Orthogonality. Orthogonal and orthonormal bases. 125 §3. Orthogonal projection and Gram-Schmidt orthogonalization 129 §4. Least square solution. Formula for the orthogonal projection 136 §5. Adjoint of a linear transformation. Fundamental subspaces revisited. 142 §6. Isometries and unitary operators. Unitary and orthogonal matrices. 146 §7. Rigid motions in Rn 151 §8. Complexiﬁcation and decomplexiﬁcation 154 Chapter 6. Structure of operators in inner product spaces. 163 §1. Upper triangular (Schur) representation of an operator. 163 §2. Spectral theorem for self-adjoint and normal operators. 165 §3. Polar and singular value decompositions. 171 §4. Applications of the singular value decomposition. 179 §5. Structure of orthogonal matrices 187 §6. Orientation 193 Chapter 7. Bilinear and quadratic forms 197 §1. Main deﬁnition 197 §2. Diagonalization of quadratic forms 200 §3. Silvester’s Law of Inertia 206 §4. Positive deﬁnite forms. Minimax characterization of eigenvalues and the Silvester’s criterion of positivity 208 Contents ix §5. Positive deﬁnite forms and inner products 214 Chapter 8. Dual spaces and tensors 217 §1. Dual spaces 217 §2. Dual of an inner product space 224 §3. Adjoint (dual) transformations and transpose. Fundamental subspace revisited (once more) 227 §4. What is the diﬀerence between a space and its dual? 232 §5. Multilinear functions. Tensors 239 §6. Change of coordinates formula for tensors. 247 Chapter 9. Advanced spectral theory 253 §1. Cayley–Hamilton Theorem 253 §2. Spectral Mapping Theorem 257 §3. Generalized eigenspaces. Geometric meaning of algebraic multiplicity 259 §4. Structure of nilpotent operators 266 §5. Jordan decomposition theorem 272 Index 275 Chapter 1 Basic Notions 1. Vector spaces A vector space V is a collection of objects, called vectors (denoted in this book by lowercase bold letters, like v), along with two operations, addition of vectors and multiplication by a number (scalar) 1 , such that the following 8 properties (the so-called axioms of a vector space) hold: The ﬁrst 4 properties deal with the addition: 1. Commutativity: v + w = w + v for all v, w ∈ V ; A question arises, “How one can mem- orize the above prop- erties?” And the an- swer is that one does not need to, see be- low! 2. Associativity: (u + v) + w = u + (v + w) for all u, v, w ∈ V ; 3. Zero vector: there exists a special vector, denoted by 0 such that v + 0 = v for all v ∈ V ; 4. Additive inverse: For every vector v ∈ V there exists a vector w ∈ V such that v + w = 0. Such additive inverse is usually denoted as −v; The next two properties concern multiplication: 5. Multiplicative identity: 1v = v for all v ∈ V ; 1We need some visual distinction between vectors and other objects, so in this book we use bold lowercase letters for vectors and regular lowercase letters for numbers (scalars). In some (more advanced) books Latin letters are reserved for vectors, while Greek letters are used for scalars; in even more advanced texts any letter can be used for anything and the reader must understand from the context what each symbol means. I think it is helpful, especially for a beginner to have some visual distinction between diﬀerent objects, so a bold lowercase letters will always denote a vector. And on a blackboard an arrow (like in ⃗v) is used to identify a vector. 1 2 1. Basic Notions 6. Multiplicative associativity: (αβ)v = α(βv) for all v ∈ V and all scalars α, β; And ﬁnally, two distributive properties, which connect multipli- cation and addition: 7. α(u + v) = αu + αv for all u, v ∈ V and all scalars α; 8. (α + β)v = αv + βv for all v ∈ V and all scalars α, β. Remark. The above properties seem hard to memorize, but it is not nec- essary. They are simply the familiar rules of algebraic manipulations with numbers, that you know from high school. The only new twist here is that you have to understand what operations you can apply to what objects. You can add vectors, and you can multiply a vector by a number (scalar). Of course, you can do with number all possible manipulations that you have learned before. But, you cannot multiply two vectors, or add a number to a vector. Remark. It is easy to prove that zero vector 0 is unique, and that given v ∈ V its additive inverse −v is also unique. It is also not hard to show using properties 5, 6 and 8 that 0 = 0v for any v ∈ V , and that −v = (−1)v. Note, that to do this one still needs to use other properties of a vector space in the proofs, in particular properties 3 and 4. If the scalars are the usual real numbers, we call the space V a real vector space. If the scalars are the complex numbers, i.e. if we can multiply vectors by complex numbers, we call the space V a complex vector space. Note, that any complex vector space is a real vector space as well (if we can multiply by complex numbers, we can multiply by real numbers), but not the other way around. It is also possible to consider a situation when the scalars are elements ofIf you do not know what a ﬁeld is, do not worry, since in this book we con- sider only the case of real and complex spaces. an arbitrary ﬁeld F. In this case we say that V is a vector space over the ﬁeld F. Although many of the constructions in the book (in particular, everything in Chapters 1–3) work for general ﬁelds, in this text we are considering only real and complex vector spaces. If we do not specify the set of scalars, or use a letter F for it, then the results are true for both real and complex spaces. If we need to distinguish real and complex cases, we will explicitly say which case we are considering. Note, that in the deﬁnition of a vector space over an arbitrary ﬁeld, we require the set of scalars to be a ﬁeld, so we can always divide (without a remainder) by a non-zero scalar. Thus, it is possible to consider vector space over rationals, but not over the integers. 1. Vector spaces 3 1.1. Examples. Example. The space Rn consists of all columns of size n, v =      v1 v2 ... vn  | | |  whose entries are real numbers. Addition and multiplication are deﬁned entrywise, i.e. α      v1 v2 ... vn  | | |  =      αv1 αv2 ... αvn  | | |  ,      v1 v2 ... vn  | | |  +      w1 w2 ... wn  | | |  =      v1 + w1 v2 + w2 ... vn + wn  | | |  Example. The space Cn also consists of columns of size n, only the entries now are complex numbers. Addition and multiplication are deﬁned exactly as in the case of Rn, the only diﬀerence is that we can now multiply vectors by complex numbers, i.e. Cn is a complex vector space. Many results in this text are true for both Rn and Cn. In such cases we will use notation Fn. Example. The space Mm×n (also denoted as Mm,n) of m × n matrices: the addition and multiplication by scalars are deﬁned entrywise. If we allow only real entries (and so only multiplication only by reals), then we have a real vector space; if we allow complex entries and multiplication by complex numbers, we then have a complex vector space. Formally, we have to distinguish between between real and complex cases, i.e. write something like M R m,n or M C m,n. However, in most situa- tions there is no diﬀerence between real and complex case, and there is no need to specify which case we are considering. If there is a diﬀerence we say explicitly which case we are considering. Remark. As we mentioned above, the axioms of a vector space are just the familiar rules of algebraic manipulations with (real or complex) numbers, so if we put scalars (numbers) for the vectors, all axioms will be satisﬁed. Thus, the set R of real numbers is a real vector space, and the set C of complex numbers is a complex vector space. More importantly, since in the above examples all vector operations (addition and multiplication by a scalar) are performed entrywise, for these examples the axioms of a vector space are automatically satisﬁed because they are satisﬁed for scalars (can you see why?). So, we do not have to 4 1. Basic Notions check the axioms, we get the fact that the above examples are indeed vector spaces for free! The same can be applied to the next example, the coeﬃcients of the polynomials play the role of entries there. Example. The space Pn of polynomials of degree at most n, consists of all polynomials p of form p(t) = a0 + a1t + a2t 2 + . . . + antn, where t is the independent variable. Note, that some, or even all, coeﬃcients ak can be 0. In the case of real coeﬃcients ak we have a real vector space, complex coeﬃcient give us a complex vector space. Again, we will specify whether we treating real or complex case only when it is essential; otherwise everything applies to both cases. Question: What are zero vectors in each of the above examples? 1.2. Matrix notation. An m × n matrix is a rectangular array with m rows and n columns. Elements of the array are called entries of the matrix. It is often convenient to denote matrix entries by indexed letters: the ﬁrst index denotes the number of the row, where the entry is, and the second one is the number of the column. For example (1.1) A = (aj,k)m, j=1, n k=1 =      a1,1 a1,2 . . . a1,n a2,1 a2,2 . . . a2,n ... ... ... am,1 am,2 . . . am,n  | | |  is a general way to write an m × n matrix. Very often for a matrix A the entry in row number j and column number k is denoted by Aj,k or (A)j,k, and sometimes as in example (1.1) above the same letter but in lowercase is used for the matrix entries. Given a matrix A, its transpose (or transposed matrix) AT , is deﬁned by transforming the rows of A into the columns. For example ( 1 2 3 4 5 6 )T =   1 4 2 5 3 6   . So, the columns of AT are the rows of A and vice versa, the rows of AT are the columns of A. The formal deﬁnition is as follows: (AT )j,k = (A)k,j meaning that the entry of AT in the row number j and column number k equals the entry of A in the row number k and row number j. 1. Vector spaces 5 The transpose of a matrix has a very nice interpretation in terms of linear transformations, namely it gives the so-called adjoint transformation. We will study this in detail later, but for now transposition will be just a useful formal operation. One of the ﬁrst uses of the transpose is that we can write a column vector x ∈ Fn (recall that F is R or C) as x = (x1, x2, . . . , xn)T . If we put the column vertically, it will use signiﬁcantly more space. Exercises. 1.1. Let x = (1, 2, 3) T , y = (y1, y2, y3) T , z = (4, 2, 1)T . Compute 2x, 3y, x + 2y − 3z. 1.2. Which of the following sets (with natural addition and multiplication by a scalar) are vector spaces. Justify your answer. a) The set of all continuous functions on the interval [0, 1]; b) The set of all non-negative functions on the interval [0, 1]; c) The set of all polynomials of degree exactly n; d) The set of all symmetric n × n matrices, i.e. the set of matrices A = {aj,k} n j,k=1 such that AT = A. 1.3. True or false: a) Every vector space contains a zero vector; b) A vector space can have more than one zero vector; c) An m × n matrix has m rows and n columns; d) If f and g are polynomials of degree n, then f + g is also a polynomial of degree n; e) If f and g are polynomials of degree at most n, then f + g is also a polynomial of degree at most n 1.4. Prove that a zero vector 0 of a vector space V is unique. 1.5. What matrix is the zero vector of the space M2×3? 1.6. Prove that the additive inverse, deﬁned in Axiom 4 of a vector space is unique. 1.7. Prove that 0v = 0 for any vector v ∈ V . 1.8. Prove that for any vector v its additive inverse −v is given by (−1)v. 6 1. Basic Notions 2. Linear combinations, bases. Let V be a vector space, and let v1, v2, . . . , vp ∈ V be a collection of vectors. A linear combination of vectors v1, v2, . . . , vp is a sum of form α1v1 + α2v2 + . . . + αpvp = p∑ k=1 αkvk. Deﬁnition 2.1. A system of vectors v1, v2, . . . vn ∈ V is called a basis (for the vector space V ) if any vector v ∈ V admits a unique representation as a linear combination v = α1v1 + α2v2 + . . . + αnvn = n∑ k=1 αkvk. The coeﬃcients α1, α2, . . . , αn are called coordinates of the vector v (in the basis, or with respect to the basis v1, v2, . . . , vn). Another way to say that v1, v2, . . . , vn is a basis is to say that for any possible choice of the right side v, the equation x1v1 +x2v2 +. . .+xmvn = v (with unknowns xk) has a unique solution. Before discussing any properties of bases 2, let us give a few examples, showing that such objects exist, and that it makes sense to study them. Example 2.2. In the ﬁrst example the space V is Fn, where F is either R or C. Consider vectors e1 =        1 0 0 ... 0  | | | | |  , e2 =        0 1 0 ... 0  | | | | |  , e3 =        0 0 1 ... 0  | | | | |  , . . . , en =        0 0 0 ... 1  | | | | |  , (the vector ek has all entries 0 except the entry number k, which is 1). The system of vectors e1, e2, . . . , en is a basis in Fn. Indeed, any vector v =      x1 x2 ... xn  | | |  ∈ F n can be represented as the linear combination v = x1e1 + x2e2 + . . . xnen = n∑ k=1 xkek 2the plural for the “basis” is bases, the same as the plural for “base” 2. Linear combinations, bases. 7 and this representation is unique. The system e1, e2, . . . , en ∈ Fn is called the standard basis in Fn Example 2.3. In this example the space is the space Pn of the polynomials of degree at most n. Consider vectors (polynomials) e0, e1, e2, . . . , en ∈ Pn deﬁned by e0 := 1, e1 := t, e2 := t 2, e3 := t 3, . . . , en := t n. Clearly, any polynomial p, p(t) = a0 + a1t + a2t2 + . . . + antn admits a unique representation p = a0e0 + a1e1 + . . . + anen. So the system e0, e1, e2, . . . , en ∈ Pn is a basis in Pn. We will call it the standard basis in Pn. Remark 2.4. If a vector space V has a basis v1, v2, . . . , vn, then any vector v is uniquely deﬁned by its coeﬃcients in the decomposition v = ∑n k=1 αkvk. This is a very im- portant remark, that will be used through- out the book. It al- lows us to translate any statement about the standard column space Fn to a vector space V with a basis v1, v2, . . . , vn So, if we stack the coeﬃcients αk in a column, we can operate with them as if they were column vectors, i.e. as with elements of Fn (again here F is either R or C, but everything also works for an abstract ﬁeld F). Namely, if v = ∑n k=1 αkvk and w = ∑n k=1 βkvk, then v + w = n∑ k=1 αkvk + n∑ k=1 βkvk = n∑ k=1(αk + βk)vk, i.e. to get the column of coordinates of the sum one just need to add the columns of coordinates of the summands. Similarly, to get the coordinates of αv we need simply to multiply the column of coordinates of v by α. 2.1. Generating and linearly independent systems. The deﬁnition of a basis says that any vector admits a unique representation as a linear combination. This statement is in fact two statements, namely that the rep- resentation exists and that it is unique. Let us analyze these two statements separately. If we only consider the existence we get the following notion Deﬁnition 2.5. A system of vectors v1, v2, . . . , vp ∈ V is called a generating system (also a spanning system, or a complete system) in V if any vector v ∈ V admits representation as a linear combination v = α1v1 + α2v2 + . . . + αpvp = p∑ k=1 αkvk. The only diﬀerence from the deﬁnition of a basis is that we do not assume that the representation above is unique. 8 1. Basic Notions The words generating, spanning and complete here are synonyms. I per- sonally prefer the term complete, because of my operator theory background. Generating and spanning are more often used in linear algebra textbooks. Clearly, any basis is a generating (complete) system. Also, if we have a basis, say v1, v2, . . . , vn, and we add to it several vectors, say vn+1, . . . , vp, then the new system will be a generating (complete) system. Indeed, we can represent any vector as a linear combination of the vectors v1, v2, . . . , vn, and just ignore the new ones (by putting corresponding coeﬃcients αk = 0). Now, let us turn our attention to the uniqueness. We do not want to worry about existence, so let us consider the zero vector 0, which always admits a representation as a linear combination. Deﬁnition. A linear combination α1v1 + α2v2 + . . . + αpvp is called trivial if αk = 0 ∀k. A trivial linear combination is always (for all choices of vectors v1, v2, . . . , vp) equal to 0, and that is probably the reason for the name. Deﬁnition. A system of vectors v1, v2, . . . , vp ∈ V is called linearly inde- pendent if only the trivial linear combination (∑p k=1 αkvk with αk = 0 ∀k) of vectors v1, v2, . . . , vp equals 0. In other words, the system v1, v2, . . . , vp is linearly independent iﬀ the equation x1v1 + x2v2 + . . . + xpvp = 0 (with unknowns xk) has only trivial solution x1 = x2 = . . . = xp = 0. If a system is not linearly independent, it is called linearly dependent. By negating the deﬁnition of linear independence, we get the following Deﬁnition. A system of vectors v1, v2, . . . , vp is called linearly dependent if 0 can be represented as a nontrivial linear combination, 0 = ∑p k=1 αkvk. Non-trivial here means that at least one of the coeﬃcient αk is non-zero. This can be (and usually is) written as ∑p k=1 |αk| ̸= 0. So, restating the deﬁnition we can say, that a system is linearly depen- dent if and only if there exist scalars α1, α2, . . . , αp, ∑p k=1 |αk| ̸= 0 such that p∑ k=1 αkvk = 0. An alternative deﬁnition (in terms of equations) is that a system v1, v2, . . . , vp is linearly dependent iﬀ the equation x1v1 + x2v2 + . . . + xpvp = 0 (with unknowns xk) has a non-trivial solution. Non-trivial, once again means that at least one of xk is diﬀerent from 0, and it can be written as ∑p k=1 |xk| ̸= 0. 2. Linear combinations, bases. 9 The following proposition gives an alternative description of linearly de- pendent systems. Proposition 2.6. A system of vectors v1, v2, . . . , vp ∈ V is linearly de- pendent if and only if one of the vectors vk can be represented as a linear combination of the other vectors, (2.1) vk = p∑ j=1 j̸=k βjvj. Proof. Suppose the system v1, v2, . . . , vp is linearly dependent. Then there exist scalars αk, ∑p k=1 |αk| ̸= 0 such that α1v1 + α2v2 + . . . + αpvp = 0. Let k be the index such that αk ̸= 0. Then, moving all terms except αkvk to the right side we get αkvk = − p∑ j=1 j̸=k αjvj. Dividing both sides by αk we get (2.1) with βj = −αj/αk. On the other hand, if (2.1) holds, 0 can be represented as a non-trivial linear combination vk − p∑ j=1 j̸=k βjvj = 0. □ Obviously, any basis is a linearly independent system. Indeed, if a system v1, v2, . . . , vn is a basis, 0 admits a unique representation 0 = α1v1 + α2v2 + . . . + αnvn = n∑ k=1 αkvk. Since the trivial linear combination always gives 0, the trivial linear combi- nation must be the only one giving 0. So, as we already discussed, if a system is a basis it is a complete (gen- erating) and linearly independent system. The following proposition shows that the converse implication is also true. Proposition 2.7. A system of vectors v1, v2, . . . , vn ∈ V is a basis if and In many textbooks a basis is deﬁned as a complete and linearly independent system. By Propo- sition 2.7 this deﬁni- tion is equivalent to ours. only if it is linearly independent and complete (generating). 10 1. Basic Notions Proof. We already know that a basis is always linearly independent and complete, so in one direction the proposition is already proved. Let us prove the other direction. Suppose a system v1, v2, . . . , vn is lin- early independent and complete. Take an arbitrary vector v ∈ V . Since the system v1, v2, . . . , vn is linearly complete (generating), v can be represented as v = α1v1 + α2v2 + . . . + αnvn = n∑ k=1 αkvk. We only need to show that this representation is unique. Suppose v admits another representation v = n∑ k=1 ̃αkvk. Then n∑ k=1(αk − ̃αk)vk = n∑ k=1 αkvk − n∑ k=1 ̃αkvk = v − v = 0. Since the system is linearly independent, αk − ̃αk = 0 ∀k, and thus the representation v = α1v1 + α2v2 + . . . + αnvn is unique. □ Remark. In many textbooks a basis is deﬁned as a complete and linearly independent system (by Proposition 2.7 this deﬁnition is equivalent to ours). Although this deﬁnition is more common than one presented in this text, I prefer the latter. It emphasizes the main property of a basis, namely that any vector admits a unique representation as a linear combination. Proposition 2.8. Any (ﬁnite) generating system contains a basis. Proof. Suppose v1, v2, . . . , vp ∈ V is a generating (complete) set. If it is linearly independent, it is a basis, and we are done. Suppose it is not linearly independent, i.e. it is linearly dependent. Then there exists a vector vk which can be represented as a linear combination of the vectors vj, j ̸= k. Since vk can be represented as a linear combination of vectors vj, j ̸= k, any linear combination of vectors v1, v2, . . . , vp can be represented as a linear combination of the same vectors without vk (i.e. the vectors vj, 1 ≤ j ≤ p, j ̸= k). So, if we delete the vector vk, the new system will still be a complete one. If the new system is linearly independent, we are done. If not, we repeat the procedure. Repeating this procedure ﬁnitely many times we arrive to a linearly independent and complete system, because otherwise we delete all vectors and end up with an empty set. 2. Linear combinations, bases. 11 So, any ﬁnite complete (generating) set contains a complete linearly independent subset, i.e. a basis. □ Exercises. 2.1. Find a basis in the space of 3 × 2 matrices M3×2. 2.2. True or false: a) Any set containing a zero vector is linearly dependent b) A basis must contain 0; c) subsets of linearly dependent sets are linearly dependent; d) subsets of linearly independent sets are linearly independent; e) If α1v1 + α2v2 + . . . + αnvn = 0 then all scalars αk are zero; 2.3. Recall, that a matrix is called symmetric if AT = A. Write down a basis in the space of symmetric 2 × 2 matrices (there are many possible answers). How many elements are in the basis? 2.4. Write down a basis for the space of a) 3 × 3 symmetric matrices; b) n × n symmetric matrices; c) n × n antisymmetric (AT = −A) matrices; 2.5. Let a system of vectors v1, v2, . . . , vr be linearly independent but not gen- erating. Show that it is possible to ﬁnd a vector vr+1 such that the system v1, v2, . . . , vr, vr+1 is linearly independent. Hint: Take for vr+1 any vector that cannot be represented as a linear combination ∑r k=1 αkvk and show that the system v1, v2, . . . , vr, vr+1 is linearly independent. 2.6. Is it possible that vectors v1, v2, v3 are linearly dependent, but the vectors w1 = v1 + v2, w2 = v2 + v3 and w3 = v3 + v1 are linearly independent? 12 1. Basic Notions 3. Linear Transformations. Matrix–vector multiplication A transformation T from a set X to a set Y is a rule that for each argumentThe words “trans- formation”, “trans- form”, “mapping”, “map”, “operator”, “function” all denote the same object. (input) x ∈ X assigns a value (output) y = T (x) ∈ Y . The set X is called the domain of T , and the set Y is called the target space or codomain of T . We write T : X → Y to say that T is a transformation with the domain X and the target space Y . Deﬁnition. Let V , W be vector spaces (over the same ﬁeld F). A transfor- mation T : V → W is called linear if 1. T (u + v) = T (u) + T (v) ∀u, v ∈ V ; 2. T (αv) = αT (v) for all v ∈ V and for all scalars α ∈ F. Properties 1 and 2 together are equivalent to the following one: T (αu + βv) = αT (u) + βT (v) for all u, v ∈ V and for all scalars α, β. 3.1. Examples. You dealt with linear transformation before, may be with- out even suspecting it, as the examples below show. Example. Diﬀerentiation: Let V = Pn (the set of polynomials of degree at most n), W = Pn−1, and let T : Pn → Pn−1 be the diﬀerentiation operator, T (p) := p′ ∀p ∈ Pn. Since (f + g)′ = f ′ + g′ and (αf )′ = αf ′, this is a linear transformation. Example. Rotation: in this example V = W = R2 (the usual coordinate plane), and a transformation Tγ : R2 → R2 takes a vector in R2 and rotates it counterclockwise by γ radians. Since Tγ rotates the plane as a whole, it rotates as a whole the parallelogram used to deﬁne a sum of two vectors (parallelogram law). Therefore the property 1 of linear transformation holds. It is also easy to see that the property 2 is also true. Example. Reﬂection: in this example again V = W = R2, and the trans- formation T : R2 → R2 is the reﬂection in the ﬁrst coordinate axis, see the ﬁg. It can also be shown geometrically, that this transformation is linear, but we will use another way to show that. Namely, it is easy to write a formula for T , T ( ( x1 x2 ) ) = ( x1 −x2 ) and from this formula it is easy to check that the transformation is linear. 3. Linear Transformations. Matrix–vector multiplication 13 Figure 1. Rotation Example. Let us investigate linear transformations T : R → R. Any such transformation is given by the formula T (x) = ax where a = T (1). Indeed, T (x) = T (x × 1) = xT (1) = xa = ax. So, any linear transformation of R is just a multiplication by a constant. 3.2. Linear transformations Fn → Fm. Matrix–column multiplica- tion. It turns out that a linear transformation T : Fn → Fm also can be represented as a multiplication, not by a scalar, but by a matrix. Let us see how. Let T : Fn → Fm be a linear transformation. What information do we need to compute T (x) for all vectors x ∈ Fn? My claim is that it is suﬃcient to know how T acts on the standard basis e1, e2, . . . , en of Fn. Namely, it is suﬃcient to know n vectors in Fm (i.e. the vectors of size m), a1 = T (e1), a2 := T (e2), . . . , an := T (en). 14 1. Basic Notions Indeed, let x =      x1 x2 ... xn  | | |  . Then x = x1e1 + x2e2 + . . . + xnen = ∑n k=1 xkek and T (x) = T ( n∑ k=1 xkek) = n∑ k=1 T (xkek) = n∑ k=1 xkT (ek) = n∑ k=1 xkak. So, if we join the vectors (columns) a1, a2, . . . , an together in a matrix A = [a1, a2, . . . , an] (ak being the kth column of A, k = 1, 2, . . . , n), this matrix contains all the information about T . Let us show how one should deﬁne the product of a matrix and a vector (column) to represent the transformation T as a product, T (x) = Ax. Let A =      a1,1 a1,2 . . . a1,n a2,1 a2,2 . . . a2,n ... ... ... am,1 am,2 . . . am,n  | | |  . Recall, that the column number k of A is the vector ak, i.e. ak =      a1,k a2,k ... am,k  | | |  . Then if we want Ax = T (x) we get Ax = n∑ k=1 xkak = x1      a1,1 a2,1 ... am,1  | | |  + x2      a1,2 a2,2 ... am,2  | | |  + . . . + xn      a1,n a2,n ... am,n  | | |  . So, the matrix–vector multiplication should be performed by the follow- ing column by coordinate rule: multiply each column of the matrix by the corresponding coordi- nate of the vector. Example. ( 1 2 3 3 2 1 )   1 2 3   = 1 ( 1 3 ) + 2 ( 2 2 ) + 3 ( 3 1 ) = ( 14 10 ) . 3. Linear Transformations. Matrix–vector multiplication 15 The “column by coordinate” rule is very well adapted for parallel com- puting. It will be also very important in diﬀerent theoretical constructions later. However, when doing computations manually, it is more convenient to compute the result one entry at a time. This can be expressed as the fol- lowing row by column rule: To get the entry number k of the result, one need to multiply row number k of the matrix by the vector, that is, if Ax = y, then yk = ∑n j=1 ak,jxj, k = 1, 2, . . . m; here xj and yk are coordinates of the vectors x and y respectively, and aj,k are the entries of the matrix A. Example. ( 1 2 3 4 5 6 )   1 2 3   = ( 1 · 1 + 2 · 2 + 3 · 3 4 · 1 + 5 · 2 + 6 · 3 ) = ( 14 32 ) 3.3. Linear transformations and generating sets. As we discussed above, linear transformation T (acting from Fn to Fm) is completely deﬁned by its values on the standard basis in Fn. The fact that we consider the standard basis is not essential, one can consider any basis, even any generating (spanning) set. Namely, A linear transformation T : V → W is completely deﬁned by its values on a generating set (in particular by its values on a basis). So, if v1, v2, . . . , vn is a generating set (in particular, if it is a basis) in V , and T and T1 are linear transformations T, T1 : V → W such that T vk = T1vk, k = 1, 2, . . . , n then T = T1. The proof of this statement is trivial and left as an exercise. 3.4. Conclusions. • To get the matrix of a linear transformation T : Fn → Fm one needs to join the vectors ak = T ek (where e1, e2, . . . , en is the standard basis in Fn) into a matrix: kth column of the matrix is ak, k = 1, 2, . . . , n. • If the matrix A of the linear transformation T is known, then T (x) can be found by the matrix–vector multiplication, T (x) = Ax. To perform matrix–vector multiplication one can use either “column by coordinate” or “row by column” rule. 16 1. Basic Notions The latter seems more appropriate for manual computations. The former is well adapted for parallel computers, and will be used in diﬀerent theoretical constructions. For a linear transformation T : Fn → Fm, its matrix is usually denoted as [T ]. However, very often people do not distinguish between a linear trans- formation and its matrix, and use the same symbol for both. When it does not lead to confusion, we will also use the same symbol for a transformation and its matrix. Since a linear transformation is essentially a multiplication, the notationThe notation T v is often used instead of T (v). T v is often used instead of T (v). We will also use this notation. Note that the usual order of algebraic operations apply, i.e. T v + u means T (v) + u, not T (v + u). Remark. In the matrix–vector multiplication Ax the number of columnsIn the matrix vector multiplication using the “row by column” rule be sure that you have the same num- ber of entries in the row and in the col- umn. The entries in the row and in the column should end simultaneously: if not, the multipli- cation is not deﬁned. of the matrix A matrix must coincide with the size of the vector x, i.e. a vector in Fn can only be multiplied by an m × n matrix. It makes sense, since an m × n matrix deﬁnes a linear transformation Fn → Fm, so vector x must belong to Fn. The easiest way to remember this is to remember that if performing multiplication you run out of some elements faster, then the multiplication is not deﬁned. For example, if using the “row by column” rule you run out of row entries, but still have some unused entries in the vector, the multiplication is not deﬁned. It is also not deﬁned if you run out of vector’s entries, but still have unused entries in the row. Remark. One does not have to restrict himself to the case of Fn with standard basis: everything described in this section works for transformation between arbitrary vector spaces as long as there is a basis in the domain and in the target space. Of course, if one changes a basis, the matrix of the linear transformation will be diﬀerent. This will be discussed later in Section 8. Exercises. 3.1. Multiply: a) ( 1 2 3 4 5 6 )   1 3 2  ; b)   1 2 0 1 2 0   ( 1 3 ); c)     1 2 0 0 0 1 2 0 0 0 1 2 0 0 0 1  | |      1 2 3 4  | | ; 4. Linear transformations as a vector space 17 d)     1 2 0 0 1 2 0 0 1 0 0 0  | |      1 2 3 4  | | . 3.2. Let a linear transformation in R2 be the reﬂection in the line x1 = x2. Find its matrix. 3.3. For each linear transformation below ﬁnd it matrix a) T : R2 → R3 deﬁned by T (x, y) T = (x + 2y, 2x − 5y, 7y) T ; b) T : R4 → R3 deﬁned by T (x1, x2, x3, x4) T = (x1 +x2 +x3 +x4, x2 −x4, x1 + 3x2 + 6x4) T ; c) T : Pn → Pn, T f (t) = f ′(t) (ﬁnd the matrix with respect to the standard basis 1, t, t2, . . . , tn); d) T : Pn → Pn, T f (t) = 2f (t) + 3f ′(t) − 4f ′′(t) (again with respect to the standard basis 1, t, t2, . . . , tn). 3.4. Find 3 × 3 matrices representing the transformations of R3 which: a) project every vector onto x-y plane; b) reﬂect every vector through x-y plane; c) rotate the x-y plane through 30◦, leaving z-axis alone. 3.5. Let A be a linear transformation. If z is the center of the straight interval [x, y], show that Az is the center of the interval [Ax, Ay]. Hint: What does it mean that z is the center of the interval [x, y]? 3.6. The set C of complex numbers can be canonically identiﬁed with the space R2 by treating each z = x + iy ∈ C as a column (x, y) T ∈ R2. a) Treating C as a complex vector space, show that the multiplication by α = a + ib ∈ C is a linear transformation in C. What is its matrix? b) Treating C as the real vector space R2 show that the multiplication by α = a + ib deﬁnes a linear transformation there. What is its matrix? c) Deﬁne T (x + iy) = 2x − y + i(x − 3y). Show that this transformation is not a linear transformation in the complex vectors space C, but if we treat C as the real vector space R2 then it is a linear transformation there (i.e. that T is a real linear but not a complex linear transformation). Find the matrix of the real linear transformation T . 3.7. Show that any linear transformation in C (treated as a complex vector space) is a multiplication by α ∈ C. 4. Linear transformations as a vector space What operations can we perform with linear transformations? We can al- ways multiply a linear transformation for a scalar, i.e. if we have a linear 18 1. Basic Notions transformation T : V → W and a scalar α we can deﬁne a new transforma- tion αT by (αT )v = α(T v) ∀v ∈ V. It is easy to check that αT is also a linear transformation: (αT )(α1v1 + α2v2) = α(T (α1v1 + α2v2)) by the deﬁnition of αT = α(α1T v1 + α2T v2) by the linearity of T = α1αT v1 + α2αT v2 = α1(αT )v1 + α2(αT )v2 If T1 and T2 are linear transformations with the same domain and target space (T1 : V → W and T2 : V → W , or in short T1, T2 : V → W ), then we can add these transformations, i.e. deﬁne a new transformation T = (T1 + T2) : V → W by (T1 + T2)v = T1v + T2v ∀v ∈ V. It is easy to check that the transformation T1 + T2 is a linear one, one just needs to repeat the above reasoning for the linearity of αT . So, if we ﬁx vector spaces V and W and consider the collection of all linear transformations from V to W (let us denote it by L(V, W )), we can deﬁne 2 operations on L(V, W ): multiplication by a scalar and addition. It can be easily shown that these operations satisfy the axioms of a vector space, deﬁned in Section 1. This should come as no surprise for the reader, since axioms of a vector space essentially mean that operation on vectors follow standard rules of algebra. And the operations on linear transformations are deﬁned as to satisfy these rules! As an illustration, let us write down a formal proof of the ﬁrst distribu- tive law (axiom 7) of a vector space. We want to show that α(T1 + T2) = αT1 + αT2. For any v ∈ V α(T1 + T2)v = α((T1 + T2)v) by the deﬁnition of multiplication = α(T1v + T2v) by the deﬁnition of the sum = αT1v + αT2v by Axiom 7 for W = (αT1 + αT2)v by the deﬁnition of the sum So indeed α(T1 + T2) = αT1 + αT2. Remark. Linear operations (addition and multiplication by a scalar) on linear transformations T : Fn → Fm correspond to the respective operations on their matrices. Since we know that the set of m × n matrices is a vector space, this immediately implies that L(Fn, Fm) is a vector space. We presented the abstract proof above, ﬁrst of all because it work for general spaces, for example, for spaces without a basis, where we cannot 5. Composition of linear transformations and matrix multiplication. 19 work with coordinates. Secondly, the reasonings similar to the abstract one presented here, are used in many places, so the reader will beneﬁt from understanding it. And as the reader gains some mathematical sophistication, he/she will see that this abstract reasoning is indeed a very simple one, that can be performed almost automatically. 5. Composition of linear transformations and matrix multiplication. 5.1. Deﬁnition of the matrix multiplication. Knowing matrix–vector multiplication, one can easily guess what is the natural way to deﬁne the product AB of two matrices: Let us multiply by A each column of B (matrix- vector multiplication) and join the resulting column-vectors into a matrix. Formally, if b1, b2, . . . , br are the columns of B, then Ab1, Ab2, . . . , Abr are the columns of the matrix AB. Recalling the row by column rule for the matrix–vector multiplication we get the following row by column rule for the matrices the entry (AB)j,k (the entry in the row j and column k) of the product AB is deﬁned by (AB)j,k = (row #j of A) · (column #k of B) Formally it can be rewritten as (AB)j,k = ∑ l aj,lbl,k, if aj,k and bj,k are entries of the matrices A and B respectively. I intentionally did not speak about sizes of the matrices A and B, but if we recall the row by column rule for the matrix–vector multiplication, we can see that in order for the multiplication to be deﬁned, the size of a row of A should be equal to the size of a column of B. In other words the product AB is deﬁned if and only if A is an m × n and B is n × r matrix. 5.2. Motivation: composition of linear transformations. One can ask yourself here: Why are we using such a complicated rule of multiplica- tion? Why don’t we just multiply matrices entrywise? And the answer is, that the multiplication, as it is deﬁned above, arises naturally from the composition of linear transformations. 20 1. Basic Notions Suppose we have two linear transformations, T1 : Fn → Fm and T2 : Fr → Fn. Deﬁne the composition T = T1 ◦ T2 of the transformations T1, T2 as T (x) = T1(T2(x)) ∀x ∈ Fr. Note that T2(x) ∈ Fn. Since T1 : Fn → Fm, the expression T1(T2(x)) is well deﬁned and the result belongs to Fm. So, T : Fr → Fm.We will usually identify a linear transformation and its matrix, but in the next few paragraphs we will distinguish them It is easy to show that T is a linear transformation (exercise), so it is deﬁned by an m × r matrix. How one can ﬁnd this matrix, knowing the matrices of T1 and T2? Let A be the matrix of T1 and B be the matrix of T2. As we discussed in the previous section, the columns of T are vectors T (e1), T (e2), . . . , T (er), where e1, e2, . . . , er is the standard basis in Fr. For k = 1, 2, . . . , r we have T (ek) = T1(T2(ek)) = T1(Bek) = T1(bk) = Abk (operators T2 and T1 are simply the multiplication by B and A respectively). So, the columns of the matrix of T are Ab1, Ab2, . . . , Abr, and that is exactly how the matrix AB was deﬁned! Let us return to identifying again a linear transformation with its matrix. Since the matrix multiplication agrees with the composition, we can (and will) write T1T2 instead of T1 ◦ T2 and T1T2x instead of T1(T2(x)). Note that in the composition T1T2 the transformation T2 is applied ﬁrst!Note: order of transformations! The way to remember this is to see that in T1T2x the transformation T2 meets x ﬁst. Remark. There is another way of checking the dimensions of matrices in a product, diﬀerent form the row by column rule: for a composition T1T2 to be deﬁned it is necessary that T2x belongs to the domain of T1. If T2 acts from some space, say Fr to Fn, then T1 must act from Fn to some space, say Fm. So, in order for T1T2 to be deﬁned the matrices of T1 and T2 should be of sizes m × n and n × r respectively—the same condition as obtained from the row by column rule. Example. Let T : R2 → R2 be the reﬂection in the line x1 = 3x2. It is a linear transformation, so let us ﬁnd its matrix. To ﬁnd the matrix, we need to compute T e1 and T e2. However, the direct computation of T e1 and T e2 involves signiﬁcantly more trigonometry than a sane person is willing to remember. An easier way to ﬁnd the matrix of T is to represent it as a composition of simple linear transformation. Namely, let γ be the angle between the x1 axis and the line x1 = 3x2, and let T0 be the reﬂection in the x1-axis. Then to get the reﬂection T we can ﬁrst rotate the plane by the angle −γ, moving the line x1 = 3x2 to the x1-axis, then reﬂect everything in the x1 5. Composition of linear transformations and matrix multiplication. 21 axis, and then rotate the plane by γ, taking everything back. Formally it can be written as T = RγT0R−γ (note the order of terms!), where Rγ is the rotation by γ. The matrix of T0 is easy to compute, T0 = ( 1 0 0 −1 ) , the rotation matrices are known Rγ = ( cos γ − sin γ sin γ cos γ, ) , R−γ = ( cos(−γ) − sin(−γ) sin(−γ) cos(−γ), ) = ( cos γ sin γ − sin γ cos γ, ) To compute sin γ and cos γ take a vector in the line x1 = 3x2, say a vector (3, 1)T . Then cos γ = ﬁrst coordinate length = 3 √32 + 12 = 3 √10 and similarly sin γ = second coordinate length = 1 √32 + 12 = 1 √10 Gathering everything together we get T = RγT0R−γ = 1 √10 ( 3 −1 1 3 ) ( 1 0 0 −1 ) 1 √10 ( 3 1 −1 3 ) = 1 10 ( 3 −1 1 3 ) ( 1 0 0 −1 ) ( 3 1 −1 3 ) It remains only to perform matrix multiplication here to get the ﬁnal result. □ 5.3. Properties of matrix multiplication. Matrix multiplication enjoys a lot of properties, familiar to us from high school algebra: 1. Associativity: A(BC) = (AB)C, provided that either left or right side is well deﬁned; we therefore can (and will) simply write ABC in this case. 2. Distributivity: A(B + C) = AB + AC, (A + B)C = AC + BC, provided either left or right side of each equation is well deﬁned. 3. One can take scalar multiplies out: A(αB) = (αA)B = α(AB) = αAB. 22 1. Basic Notions These properties are easy to prove. One should prove the corresponding properties for linear transformations, and they almost trivially follow from the deﬁnitions. The properties of linear transformations then imply the properties for the matrix multiplication. The new twist here is that the commutativity fails: matrix multiplication is non-commutative, i.e. generally for matrices AB ̸= BA. One can see easily it would be unreasonable to expect the commutativity of matrix multiplication. Indeed, let A and B be matrices of sizes m × n and n × r respectively. Then the product AB is well deﬁned, but if m ̸= r, BA is not deﬁned. Even when both products are well deﬁned, for example, when A and B are n×n (square) matrices, the multiplication is still non-commutative. If we just pick the matrices A and B at random, the chances are that AB ̸= BA: we have to be very lucky to get AB = BA. 5.4. Transposed matrices and multiplication. Given a matrix A, its transpose (or transposed matrix) AT is deﬁned by transforming the rows of A into the columns. For example ( 1 2 3 4 5 6 )T =   1 4 2 5 3 6   . So, the columns of AT are the rows of A and vice versa, the rows of AT are the columns of A. The formal deﬁnition is as follows: (AT )j,k = (A)k,j meaning that the entry of AT in the row number j and column number k equals the entry of A in the row number k and row number j. The transpose of a matrix has a very nice interpretation in terms of linear transformations, namely it gives the so-called adjoint transformation. We will study this in detail later, but for now transposition will be just a useful formal operation. One of the ﬁrst uses of the transpose is that we can write a column vector x ∈ Fn as x = (x1, x2, . . . , xn)T . If we put the column vertically, it will use signiﬁcantly more space. A simple analysis of the row by columns rule shows that (AB)T = BT AT , i.e. when you take the transpose of the product, you change the order of the terms. 5. Composition of linear transformations and matrix multiplication. 23 5.5. Trace and matrix multiplication. For a square (n × n) matrix A = (aj,k) its trace (denoted by trace A) is the sum of the diagonal entries trace A = n∑ k=1 ak,k. Theorem 5.1. Let A and B be matrices of size m×n and n×m respectively (so the both products AB and BA are well deﬁned). Then trace(AB) = trace(BA) We leave the proof of this theorem as an exercise, see Problem 5.6 below. There are essentially two ways of proving this theorem. One is to compute the diagonal entries of AB and of BA and compare their sums. This method requires some proﬁciency in manipulating sums in ∑ notation. If you are not comfortable with algebraic manipulations, there is another way. We can consider two linear transformations, T and T1, acting from Mn×m to F = F1 deﬁned by T (X) = trace(AX), T1(X) = trace(XA) To prove the theorem it is suﬃcient to show that T = T1; the equality for X = B gives the theorem. Since a linear transformation is completely deﬁned by its values on a generating system, we need just to check the equality on some simple ma- trices, for example on matrices Xj,k, which has all entries 0 except the entry 1 in the intersection of jth column and kth row. Exercises. 5.1. Let A = ( 1 2 3 1 ) , B = ( 1 0 2 3 1 −2 ) , C = ( 1 −2 3 −2 1 −1 ) , D =   −2 2 1   a) Mark all the products that are deﬁned, and give the dimensions of the result: AB, BA, ABC, ABD, BC, BC T , BT C, DC, DT C T . b) Compute AB, A(3B + C), BT A, A(BD), (AB)D. 5.2. Let Tγ be the matrix of rotation by γ in R2. Check by matrix multiplication that TγT−γ = T−γTγ = I 5.3. Multiply two rotation matrices Tα and Tβ (it is a rare case when the multi- plication is commutative, i.e. TαTβ = TβTα, so the order is not essential). Deduce formulas for sin(α + β) and cos(α + β) from here. 5.4. Find the matrix of the orthogonal projection in R2 onto the line x1 = −2x2. Hint: What is the matrix of the projection onto the coordinate axis x1? 5.5. Find linear transformations A, B : R2 → R2 such that AB = 0 but BA ̸= 0. 24 1. Basic Notions 5.6. Prove Theorem 5.1, i.e. prove that trace(AB) = trace(BA). 5.7. Construct a non-zero matrix A such that A2 = 0. 5.8. Find the matrix of the reﬂection through the line y = −2x/3. Perform all the multiplications. 6. Invertible transformations and matrices. Isomorphisms 6.1. Identity transformation and identity matrix. Among all linear transformations, there is a special one, the identity transformation (opera- tor) I, Ix = x, ∀x. To be precise, there are inﬁnitely many identity transformations: for any vector space V , there is the identity transformation I = IV : V → V , IV x = x, ∀x ∈ V . However, when it is does not lead to the confusion we will use the same symbol I for all identity operators (transformations). We will use the notation IV only we want to emphasize in what space the transformation is acting. Clearly, if I : Fn → Fn is the identity transformation in Fn, its matrixOften, the symbol E is used in Linear Al- gebra textbooks for the identity matrix. I prefer I, since it is used in operator the- ory. is the n × n matrix I = In =      1 0 . . . 0 0 1 . . . 0 ... ... . . . ... 0 0 . . . 1  | | |  (1 on the main diagonal and 0 everywhere else). When we want to emphasize the size of the matrix, we use the notation In; otherwise we just use I. Clearly, for an arbitrary linear transformation A, the equalities AI = A, IA = A hold (whenever the product is deﬁned). 6.2. Invertible transformations. Deﬁnition. Let A : V → W be a linear transformation. We say that the transformation A is left invertible if there exist a linear transformation B : W → V such that BA = I (I = I V here). The transformation A is called right invertible if there exists a linear trans- formation C : W → V such that AC = I (here I = IW ). 6. Invertible transformations and matrices. Isomorphisms 25 The transformations B and C are called left and right inverses of A. Note, that we did not assume the uniqueness of B or C here, and generally left and right inverses are not unique. Deﬁnition. A linear transformation A : V → W is called invertible if it is both right and left invertible. Theorem 6.1. If a linear transformation A : V → W is invertible, then its left and right inverses B and C are unique and coincide. Corollary. A transformation A : V → W is invertible if and only if there Very often this prop- erty is used as the deﬁnition of an in- vertible transforma- tion exists a unique linear transformation (denoted A−1), A−1 : W → V such that A−1A = I V , AA−1 = I W . The transformation A−1 is called the inverse of A. Proof of Theorem 6.1. Let BA = I and AC = I. Then BAC = B(AC) = BI = B. On the other hand BAC = (BA)C = IC = C, and therefore B = C. Suppose for some transformation B1 we have B1A = I. Repeating the above reasoning with B1 instead of B we get B1 = C. Therefore the left inverse B is unique. The uniqueness of C is proved similarly. □ Deﬁnition. A matrix is called invertible (resp. left invertible, right invert- ible) if the corresponding linear transformation is invertible (resp. left in- vertible, right invertible). Theorem 6.1 asserts that a matrix A is invertible if there exists a unique matrix A−1 such that A−1A = I, AA−1 = I. The matrix A−1 is called (surprise) the inverse of A. Examples. 1. The identity transformation (matrix) is invertible, I −1 = I; 2. The rotation Rγ Rγ = ( cos γ − sin γ sin γ cos γ ) is invertible, and the inverse is given by (Rγ)−1 = R−γ. This equality is clear from the geometric description of Rγ, and it also can be checked by the matrix multiplication; 26 1. Basic Notions 3. The column (1, 1)T is left invertible but not right invertible. One of the possible left inverses in the row (1/2, 1/2). To show that this matrix is not right invertible, we just notice that there are more than one left inverse. Exercise: describe all left inverses of this matrix. 4. The row (1, 1) is right invertible, but not left invertible. The column (1/2, 1/2)T is a possible right inverse. Remark 6.2. An invertible matrix must be square (n × n). Moreover, if a square matrix A has either left or right inverse, it is invertible. So, it isAn invertible matrix must be square (to be proved later) suﬃcient to check only one of the identities AA−1 = I, A−1A = I. This fact will be proved later. Until we prove this fact, we will not use it. I presented it here only to stop students from trying wrong directions. 6.2.1. Properties of the inverse transformation. Theorem 6.3 (Inverse of the product). If linear transformations A and B are invertible (and such that the product AB is deﬁned), then the productInverse of a product: (AB) −1 = B−1A−1. Note the change of order AB is invertible and (AB)−1 = B−1A −1 (note the change of the order!) Proof. Direct computation shows: (AB)(B−1A−1) = A(BB−1)A −1 = AIA−1 = AA−1 = I and similarly (B−1A−1)(AB) = B−1(A−1A)B = B−1IB = B−1B = I □ Remark 6.4. The invertibility of the product AB does not imply the in- vertibility of the factors A and B (can you think of an example?). However, if one of the factors (either A or B) and the product AB are invertible, then the second factor is also invertible. We leave the proof of this fact as an exercise. Theorem 6.5 (Inverse of AT ). If a matrix A is invertible, then AT is also invertible and (AT )−1 = (A−1) T Proof. Using (AB)T = BT AT we get (A −1)T AT = (AA−1) T = I T = I, and similarly AT (A−1)T = (A−1A) T = I T = I. □ 6. Invertible transformations and matrices. Isomorphisms 27 And ﬁnally, if A is invertible, then A−1 is also invertible, (A−1)−1 = A. So, let us summarize the main properties of the inverse: 1. If A is invertible, then A−1 is also invertible, (A−1)−1 = A; 2. If A and B are invertible and the product AB is deﬁned, then AB is invertible and (AB)−1 = B−1A−1. 3. If A is invertible, then AT is also invertible and (AT )−1 = (A−1)T . 6.3. Isomorphism. Isomorphic spaces. An invertible linear transfor- mation A : V → W is called an isomorphism. We did not introduce anything new here, it is just another name for the object we already studied. Two vector spaces V and W are called isomorphic (denoted V ∼= W ) if there is an isomorphism A : V → W . Isomorphic spaces can be considered as diﬀerent representation of the same space, meaning that all properties and constructions involving vector space operations are preserved under isomorphism. The theorem below illustrates this statement. Theorem 6.6. Let A : V → W be an isomorphism, and let v1, v2, . . . , vn be a basis in V . Then the system Av1, Av2, . . . , Avn is a basis in W . We leave the proof of the theorem as an exercise. Remark. In the above theorem one can replace “basis” by “linearly inde- pendent”, or “generating”, or “linearly dependent”—all these properties are preserved under isomorphisms. Remark. If A is an isomorphism, then so is A−1. Therefore in the above theorem we can state that v1, v2, . . . , vn is a basis if and only if Av1, Av2, . . . , Avn is a basis. The converse to the Theorem 6.6 is also true Theorem 6.7. Let A : V → W be a linear map,and let v1, v2, . . . , vn and w1, w2, . . . , wn be bases in V and W respectively. If Avk = wk, k = 1, 2, . . . , n, then A is an isomorphism. Proof. Deﬁne the inverse transformation A−1 by A−1wk = vk, k = 1, 2, . . . , n (as we know, a linear transformation is deﬁned by its values on a basis). □ Examples. 1. Let A : Fn+1 → PF n (PF n is the set of polynomials ∑n k=0 aktk, αk ∈ F of degree at most n) is deﬁned by Ae1 = 1, Ae2 = t, . . . , Aen = t n−1, Aen+1 = tn 28 1. Basic Notions By Theorem 6.7 A is an isomorphism, so PF n ∼= Fn+1. 2. Let V be a vector space (over F) with a basis v1, v2, . . . , vn. Deﬁne transformation A : Fn → V byAny real vector space with a basis is isomorphic to Rn (for some n). Sim- ilarly, any complex vector space with a basis is isomorphic to Cn. Aek = vk, k = 1, 2, . . . , n, where e1, e2, . . . , en is the standard basis in Fn. Again by Theorem 6.7 A is an isomorphism, so V ∼= Fn. 3. The space M F 2×3 of 2 × 3 matrices with entries in F is isomorphic to R6; 4. More generally, M F m×n ∼= Fm·n 6.4. Invertibility and equations. Theorem 6.8. Let A : X → Y be a linear transformation. Then A isDoesn’t this remind you of a basis? invertible if and only if for any right side b ∈ Y the equation Ax = b has a unique solution x ∈ X. Proof. Suppose A is invertible. Then x = A−1b solves the equation Ax = b. To show that the solution is unique, suppose that for some other vector x1 ∈ X Ax1 = b Multiplying this identity by A−1 from the left we get A−1Ax1 = A−1b, and therefore x1 = A−1b = x. Note that both identities, AA−1 = I and A−1A = I were used here. Let us now suppose that the equation Ax = b has a unique solution x for any b ∈ Y . Let us use symbol y instead of b. We know that given y ∈ Y the equation Ax = y has a unique solution x ∈ X. Let us call this solution B(y). Note that B(y) is deﬁned for all y ∈ Y , so we deﬁned a transformation B : Y → X. Let us check that B is a linear transformation. We need to show that B(αy1 +βy2) = αB(y1)+βB(y2). Let xk := B(yk), k = 1, 2, i.e. Axk = yk, k = 1, 2. Then A(αx1 + βx2) = αAx1 + βAx2 = αy1 + βy2, which means B(αy1 + βy2) = αB(y1) + βB(y2). 6. Invertible transformations and matrices. Isomorphisms 29 And ﬁnally, let us show that B is indeed the inverse of A. Take x ∈ X and let y = Ax, so by the deﬁnition of B we have x = By. Then for all x ∈ X BAx = By = x, so BA = I. Similarly, for arbitrary y ∈ Y let x = By, so y = Ax. Then for all y ∈ Y ABy = Ax = y so AB = I. □ Recalling the deﬁnition of a basis we get the following corollary of The- orems 6.6 and 6.7. Corollary 6.9. An m × n matrix is invertible if and only if its columns form a basis in Fm. Exercises. 6.1. Prove, that if A : V → W is an isomorphism (i.e. an invertible linear trans- formation) and v1, v2, . . . , vn is a basis in V , then Av1, Av2, . . . , Avn is a basis in W . 6.2. Find all right inverses to the 1 × 2 matrix (row) A = (1, 1). Conclude from here that the row A is not left invertible. 6.3. Find all left inverses of the column (1, 2, 3)T 6.4. Is the column (1, 2, 3)T right invertible? Justify 6.5. Find two matrices A and B that AB is invertible, but A and B are not. Hint: square matrices A and B would not work. Remark: It is easy to construct such A and B in the case when AB is a 1 × 1 matrix (a scalar). But can you get 2 × 2 matrix AB? 3 × 3? n × n? 6.6. Suppose the product AB is invertible. Show that A is right invertible and B is left invertible. Hint: you can just write formulas for right and left inverses. 6.7. Let A and AB be invertible (assuming that the product AB is well deﬁned). Prove that B is invertible. 6.8. Let A be n × n matrix. Prove that if A2 = 0 then A is not invertible 6.9. Suppose AB = 0 for some non-zero matrix B. Can A be invertible? Justify. 6.10. Write matrices of the linear transformations T1 and T2 in F 5, deﬁned as follows: T1 interchanges the coordinates x2 and x4 of the vector x, and T2 just adds to the coordinate x2 a times the coordinate x4, and does not change other coordinates, i.e. T1       x1 x2 x3 x4 x5  | | | |  =       x1 x4 x3 x2 x5  | | | |  , T2       x1 x2 x3 x4 x5  | | | |  =       x1 x2 + ax4 x3 x4 x5  | | | |  ; 30 1. Basic Notions here a is some ﬁxed number. Show that T1 and T2 are invertible transformations, and write the matrices of the inverses. Hint: it may be simpler, if you ﬁrst describe the inverse transforma- tion, and then ﬁnd its matrix, rather than trying to guess (or compute) the inverses of the matrices T1, T2. 6.11. Find the matrix of the rotation in R3 through the angle α around the vector (1, 2, 3)T . We assume that the rotation is counterclockwise if we sit at the tip of the vector and looking at the origin. You can present the answer as a product of several matrices: you don’t have to perform the multiplication. 6.12. Give examples of matrices (say 2 × 2) such that: a) A + B is not invertible although both A and B are invertible; b) A + B is invertible although both A and B are not invertible; c) All of A, B and A + B are invertible 6.13. Let A be an invertible symmetric (AT = A) matrix. Is the inverse of A symmetric? Justify. 7. Subspaces. A subspace of a vector space V is a non-empty subset V0 ⊂ V of V which is closed under the vector addition and multiplication by scalars, i.e. 1. If v ∈ V0 then αv ∈ V0 for all scalars α; 2. For any u, v ∈ V0 the sum u + v ∈ V0; Again, the conditions 1 and 2 can be replaced by the following one: αu + βv ∈ V0 for all u, v ∈ V0, and for all scalars α, β. Note, that a subspace V0 ⊂ V with the operations (vector addition and multiplication by scalars) inherited from V , is a vector space. Indeed, since V is non-empty, it contain at least 1 vector v and since 0 = 0v, the above condition 1. imples that the zero vector 0 is in V . Also, for any v ∈ V its additive inverse −v in given by −v = (−1)v, so again by property 1. −v ∈ V . The rest of the axiom of the vector space are satisﬁed because all operations are inherited from the vector space V . The only thing that could possibly go wrong, is that the result of some operation does not belong to V0. But the deﬁnition of a subspace prohibits this! Now let us consider some examples: 1. Trivial subspaces of a space V , namely V itself and {0} (the sub- space consisting only of zero vector). Note, that the empty set ∅ is not a vector space, since it does not contain a zero vector, so it is not a subspace. 8. Application to computer graphics. 31 With each linear transformation A : V → W we can associate the following two subspaces: 2. The null space, or kernel of A, which is denoted as Null A or Ker A and consists of all vectors v ∈ V such that Av = 0 3. The range Ran A is deﬁned as the set of all vectors w ∈ W which can be represented as w = Av for some v ∈ V . If A is a matrix, i.e. A : Fm → Fn, then recalling column by coordinate rule of the matrix–vector multiplication, we can see that any vector w ∈ Ran A can be represented as a linear combination of columns of the matrix A. That explains why the term column space (and notation Col A) is often used for the range of the matrix. So, for a matrix A, the notation Col A is often used instead of Ran A. And now the last example. 4. Given a system of vectors v1, v2, . . . , vr ∈ V its linear span (some- times called simply span) L{v1, v2, . . . , vr} is the collection of all vectors v ∈ V that can be represented as a linear combination v = α1v1 + α2v2 + . . . + αrvr of vectors v1, v2, . . . , vr. The no- tation span{v1, v2, . . . , vr} is also used instead of L{v1, v2, . . . , vr} It is easy to check that in all of these examples we indeed have subspaces. We leave this an an exercise for the reader. Some of the statements will be proved later in the text. Exercises. 7.1. Let X and Y be subspaces of a vector space V . Prove that X ∩Y is a subspace of V . 7.2. Let V be a vector space. For X, Y ⊂ V the sum X + Y is the collection of all vectors v which can be represented as v = x + y, x ∈ X, y ∈ Y . Show that if X and Y are subspaces of V , then X + Y is also a subspace. 7.3. Let X be a subspace of a vector space V , and let v ∈ V , v /∈ X. Prove that if x ∈ X then x + v /∈ X. 7.4. Let X and Y be subspaces of a vector space V . Using the previous exercise, show that X ∪ Y is a subspace if and only if X ⊂ Y or Y ⊂ X. 7.5. What is the smallest subspace of the space of 4 × 4 matrices which contains all upper triangular matrices (aj,k = 0 for all j > k), and all symmetric matrices (A = AT )? What is the largest subspace contained in both of those subspaces? 8. Application to computer graphics. In this section we give some ideas of how linear algebra is used in computer graphics. We will not go into the details, but just explain some ideas. 32 1. Basic Notions In particular we explain why manipulation with 3 dimensional images are reduced to multiplications of 4 × 4 matrices. 8.1. 2-dimensional manipulation. The x-y plane (more precisely, a rec- tangle there) is a good model of a computer monitor. Any object on a monitor is represented as a collection of pixels, each pixel is assigned a spe- ciﬁc color. Position of each pixel is determined by the column and row, which play role of x and y coordinates on the plane. So a rectangle on a plane with x-y coordinates is a good model for a computer screen: and a graphical object is just a collection of points. Remark. There are two types of graphical objects: bitmap objects, where every pixel of an object is described, and vector object, where we describe only critical points, and graphic engine connects them to reconstruct the object. A (digital) photo is a good example of a bitmap object: every pixel of it is described. Bitmap object can contain a lot of points, so manipulations with bitmaps require a lot of computing power. Anybody who has edited digital photos in a bitmap manipulation program, like Adobe Photoshop, knows that one needs quite a powerful computer, and even with modern and powerful computers manipulations can take some time. That is the reason that most of the objects, appearing on a computer screen are vector ones: the computer only needs to memorize critical points. For example, to describe a polygon, one needs only to give the coordinates of its vertices, and which vertex is connected with which. Of course, not all objects on a computer screen can be represented as polygons, some, like letters, have curved smooth boundaries. But there are standard methods allowing one to draw smooth curves through a collection of points, for exam- ple Bezier splines, used in PostScript and Adobe PDF (and in many other formats). Anyhow, this is the subject of a completely diﬀerent book, and we will not discuss it here. For us a graphical object will be a collection of points (either wireframe model, or bitmap) and we would like to show how one can perform some manipulations with such objects. The simplest transformation is a translation (shift), where each point (vector) v is translated by a, i.e. the vector v is replaced by v + a (nota- tion v 7→ v + a is used for this). Vector addition is very well adapted to computers, so the translation is easy to implement. Note, that the translation is not a linear transformation (if a ̸= 0): while it preserves the straight lines, it does not preserve 0. All other transformation used in computer graphics are linear. The ﬁrst one that comes to mind is rotation. The rotation by γ around the origin 0 8. Application to computer graphics. 33 is given by the multiplication by the rotation matrix Rγ we discussed above, Rγ = ( cos γ − sin γ sin γ cos γ ) . If we want to rotate around a point a, we ﬁrst need to translate the picture by −a, moving the point a to 0, then rotate around 0 (multiply by Rγ) and then translate everything back by a. Another very useful transformation is scaling, given by a matrix ( a 0 0 b ) , a, b ≥ 0. If a = b it is uniform scaling which enlarges (reduces) an object, preserving its shape. If a ̸= b then x and y coordinates scale diﬀerently; the object becomes “taller” or “wider”. Another often used transformation is reﬂection: for example the matrix ( 1 0 0 −1 ) , deﬁnes the reﬂection through x-axis. We will show later in the book, that any linear transformation in R2 can be represented either as a composition of scaling rotations and reﬂections. However it is sometimes convenient to consider some diﬀerent transforma- tions, like the shear transformation, given by the matrix ( 1 tan ϕ 0 1 ) . This transformation makes all objects slanted, the horizontal lines remain horizontal, but vertical lines go to the slanted lines at the angle ϕ to the horizontal ones. 8.2. 3-dimensional graphics. Three-dimensional graphics is more com- plicated. First we need to be able to manipulate 3-dimensional objects, and then we need to represent it on 2-dimensional plane (monitor). The manipulations with 3-dimensional objects is pretty straightforward, we have the same basic transformations: translation, reﬂection through a plane, scaling, rotation. Matrices of these transformations are very similar to the matrices of their 2 × 2 counterparts. For example the matrices   1 0 0 0 1 0 0 0 −1   ,   a 0 0 0 b 0 0 0 c   ,   cos γ − sin γ 0 sin γ cos γ 0 0 0 1   represent respectively reﬂection through x-y plane, scaling, and rotation around z-axis. 34 1. Basic Notions Note, that the above rotation is essentially 2-dimensional transforma- tion, it does not change z coordinate. Similarly, one can write matrices for the other 2 elementary rotations around x and around y axes. It will be shown later that a rotation around an arbitrary axis can be represented as a composition of elementary rotations. So, we know how to manipulate 3-dimensional objects. Let us now discuss how to represent such objects on a 2-dimensional plane. The simplest way is to project it to a plane, say to the x-y plane. To perform such projection one just needs to replace z coordinate by 0, the matrix of this projection is   1 0 0 0 1 0 0 0 0   . Such method is often used in technical illustrations. Rotating an object and projecting it is equivalent to looking at it from diﬀerent points. However, this method does not give a very realistic picture, because it does not take into account the perspective, the fact that the objects that are further away look smaller. To get a more realistic picture one needs to use the so-called perspective projection. To deﬁne a perspective projection one needs to pick a point (the center of projection or the focal point) and a plane to project onto. Then each point in R3 is projected into a point on the plane such that the point, its image and the center of the projection lie on the same line, see Fig. 2. This is exactly how a camera works, and it is a reasonable ﬁrst approx- imation of how our eyes work. Let us get a formula for the projection. Assume that the focal point is (0, 0, d)T and that we are projecting onto x-y plane, see Fig. 3 a). Consider a point v = (x, y, z)T , and let v∗ = (x∗, y∗, 0)T be its projection. Analyzing similar triangles see Fig. 3 b), we get that x∗ d = x d − z , so x∗ = xd d − z = x 1 − z/d , and similarly y∗ = y 1 − z/d . Note, that this formula also works if z > d and if z < 0: you can draw the corresponding similar triangles to check it. 8. Application to computer graphics. 35 x y z F Figure 2. Perspective projection onto x-y plane: F is the center (focal point) of the projection x x∗ z d−z (x, y, z) (x∗,y∗, 0) x z y (0, 0,d) a) b) Figure 3. Finding coordinates x∗, y∗ of the perspective projection of the point (x, y, z)T . Thus the perspective projection maps a point (x, y, z)T to the point ( x 1−z/d , y 1−z/d , 0)T . This transformation is deﬁnitely not linear (because of z in the denomi- nator). However it is still possible to represent it as a linear transformation. To do this let us introduce the so-called homogeneous coordinates. 36 1. Basic Notions In the homogeneous coordinates, every point in R3 is represented by 4 coordinates, the last, 4th coordinate playing role of the scaling coeﬃcient. Thus, to get usual 3-dimensional coordinates of the vector v = (x, y, z)T from its homogeneous coordinates (x1, x2, x3, x4)T one needs to divide all entries by the last coordinate x4 and take the ﬁrst 3 coordinates 3 (if x4 = 0 this recipe does not work, so we assume that the case x4 = 0 corresponds to the point at inﬁnity). Thus in homogeneous coordinates the vector v∗ can be represented as (x, y, 0, 1 − z/d)T , so in homogeneous coordinates the perspective projection is a linear transformation:     x y 0 1 − z/d  | |  =     1 0 0 0 0 1 0 0 0 0 0 0 0 0 −1/d 1  | |      x y z 1  | |  . Note that in the homogeneous coordinates the translation is also a linear transformation:     x + a1 y + a2 z + a3 1  | |  =     1 0 0 a1 0 1 0 a2 0 0 1 a3 0 0 0 1  | |      x y z 1  | |  . But what happen if the center of projection is not a point (0, 0, d)T but some arbitrary point (d1, d2, d3)T . Then we ﬁrst need to apply the transla- tion by −(d1, d2, 0)T to move the center to (0, 0, d3)T while preserving the x-y plane, apply the projection, and then move everything back translating it by (d1, d2, 0)T . Similarly, if the plane we project to is not x-y plane, we move it to the x-y plane by using rotations and translations, and so on. All these operations are just multiplications by 4 × 4 matrices. That explains why modern graphic cards have 4 × 4 matrix operations embedded in the processor. Of course, here we only touched the mathematics behind 3-dimensional graphics, there is much more. For example, how to determine which parts of the object are visible and which are hidden, how to make realistic lighting, shades, etc. 3If we multiply homogeneous coordinates of a point in R2 by a non-zero scalar, we do not change the point. In other words, in homogeneous coordinates a point in R3 is represented by a line through 0 in R4. 8. Application to computer graphics. 37 Exercises. 8.1. What vector in R3 has homogeneous coordinates (10, 20, 30, 5)? 8.2. Show that a rotation through γ can be represented as a composition of two shear-and-scale transformations T1 = ( 1 0 sin γ cos γ ) , T2 = ( sec γ − tan γ 0 1 ) . In what order the transformations should be taken? 8.3. Multiplication of a 2-vector by an arbitrary 2 × 2 matrix usually requires 4 multiplications. Suppose a 2 × 1000 matrix D contains coordinates of 1000 points in R2. How many multiplications are required to transform these points using 2 arbitrary 2 × 2 matrices A and B. Compare 2 possibilities, A(BD) and (AB)D. 8.4. Write 4 × 4 matrix performing perspective projection to x-y plane with center (d1, d2, d3) T . 8.5. A transformation T in R3 is a rotation about the line y = x+3 in the x-y plane through an angle γ. Write a 4 × 4 matrix corresponding to this transformation. You can leave the result as a product of matrices. Chapter 2 Systems of linear equations 1. Diﬀerent faces of linear systems. There exist several points of view on what a system of linear equations, or in short a linear system is. The ﬁrst, na¨ıve one is, that it is simply a collection of m linear equations with n unknowns x1, x2, . . . , xn,  || || a1,1x1 + a1,2x2 + . . . + a1,nxn = b1 a2,1x1 + a2,2x2 + . . . + a2,nxn = b2 . . . am,1x1 + am,2x2 + . . . + am,nxn = bm . To solve the system is to ﬁnd all n-tuples of numbers x1, x2, . . . , xn which satisfy all m equations simultaneously. If we denote x := (x1, x2, . . . , xn)T ∈ Fn, b = (b1, b2, . . . , bm)T ∈ Fm, and A =      a1,1 a1,2 . . . a1,n a2,1 a2,2 . . . a2,n ... ... ... am,1 am,2 . . . am,n  | | |  , then the above linear system can be written in the matrix form (as a matrix- vector equation) Ax = b. To solve the above equation is to ﬁnd all vectors x ∈ Fn satisfying Ax = b. 39 40 2. Systems of linear equations And ﬁnally, recalling the “column by coordinate” rule of the matrix- vector multiplication, we can write the system as a vector equation x1a1 + x2a2 + . . . + xnan = b, where ak is the kth column of the matrix A, ak = (a1,k, a2,k, . . . , am,k)T , k = 1, 2, . . . , n. Note, these three examples are essentially just diﬀerent representations of the same mathematical object. Before explaining how to solve a linear system, let us notice that it does not matter what we call the unknowns, xk, yk or something else. So, all the information necessary to solve the system is contained in the matrix A, which is called the coeﬃcient matrix of the system and in the vector (right side) b. Hence, all the information we need is contained in the following matrix      a1,1 a1,2 . . . a1,n b1 a2,1 a2,2 . . . a2,n b2 ... ... ... ... am,1 am,2 . . . am,n bm  | | |  which is obtained by attaching the column b to the matrix A. This matrix is called the augmented matrix of the system. We will usually put the vertical line separating A and b to distinguish between the augmented matrix and the coeﬃcient matrix. 2. Solution of a linear system. Echelon and reduced echelon forms Linear system are solved by the Gauss–Jordan elimination (which is some- times called row reduction). By performing operations on rows of the aug- mented matrix of the system (i.e. on the equations), we reduce it to a simple form, the so-called echelon form. When the system is in the echelon form, one can easily write the solution. 2.1. Row operations. There are three types of row operations we use: 1. Row exchange: interchange two rows of the matrix; 2. Scaling: multiply a row by a non-zero scalar a; 3. Row replacement: replace a row # k by its sum with a constant multiple of a row # j; all other rows remain intact; It is clear that the operations 1 and 2 do not change the set of solutions of the system; they essentially do not change the system. 2. Solution of a linear system. Echelon and reduced echelon forms 41 As for the operation 3, one can easily see that it does not lose solutions. Namely, let a “new” system be obtained from an “old” one by a row oper- ation of type 3. Then any solution of the “old” system is a solution of the “new” one. To see that we do not gain anything extra, i.e. that any solution of the “new” system is also a solution of the “old” one, we just notice that row operation of type 3 are reversible, i.e. the “old’ system also can be obtained from the “new” one by applying a row operation of type 3 (can you say which one?) 2.1.1. Row operations and multiplication by elementary matrices. There is another, more “advanced” explanation why the above row operations are legal. Namely, every row operation is equivalent to the multiplication of the matrix from the left by one of the special elementary matrices. Namely, the multiplication by the matrix j k j k                         1 ... ... . . . ... ... 0 1 ... ... . . . . . . . . . 0 . . . . . . . . . 1 ... 1 ... ... . . . ... ... 1 ... . . . . . . . . . 1 . . . . . . . . . 0 1 0 . . . 1  | | | | | | | | | | | | | | | | | | | | | |  just interchanges the rows number j and number k. Multiplication by the matrix k             1 ... . . . ... 0 1 0 . . . . . . 0 a 0 0 1 0 . . . 0 0 1  | | | | | | | | | |  42 2. Systems of linear equations multiplies the row number k by a. Finally, multiplication by the matrix j k               1 ... ... . . . ... ... 0 . . . . . . 1 . . . 0 ... . . . ... . . . . . . a . . . 1 . . .0 1  | | | | | | | | | | | |  adds to the row #k row #j multiplied by a, and leaves all other rows intact.A way to describe (or to remember) these elementary matrices: they are obtained from I by applying the corresponding row operation to it To see, that the multiplication by these matrices works as advertised, one can just see how the multiplications act on vectors (columns). Note that all these matrices are invertible (compare with reversibility of row operations). The inverse of the ﬁrst matrix is the matrix itself. To get the inverse of the second one, one just replaces a by 1/a. And ﬁnally, the inverse of the third matrix is obtained by replacing a by −a. To see that the inverses are indeed obtained this way, one again can simply check how they act on columns. So, performing a row operation on the augmented matrix of the system Ax = b is equivalent to the multiplication of the system (from the left) by a special invertible matrix E. Left multiplying the equality Ax = b by E we get that any solution of the equation Ax = b is also a solution of EAx = Eb. Multiplying this equation (from the left) by E−1 we get that any of its solutions is a solution of the equation E−1EAx = E−1Eb, which is the original equation Ax = b. So, a row operation does not change the solution set of a system. 2.2. Row reduction. The main step of row reduction consists of three sub-steps: 1. Find the leftmost non-zero column of the matrix; 2. Make sure, by applying row operations of type 1 (row exchange), if necessary, that the ﬁrst (the upper) entry of this column is non-zero. This entry will be called the pivot entry or simply the pivot; 2. Solution of a linear system. Echelon and reduced echelon forms 43 3. “Kill” (i.e. make them 0) all non-zero entries below the pivot by adding (subtracting) an appropriate multiple of the ﬁrst row from the rows number 2, 3, . . . , m. We apply the main step to a matrix, then we leave the ﬁrst row alone and apply the main step to rows 2, . . . , m, then to rows 3, . . . , m, etc. The point to remember is that after we subtract a multiple of a row from all rows below it (step 3), we leave it alone and do not change it in any way, not even interchange it with another row. After applying the main step ﬁnitely many times (at most m), we get what is called the echelon form of the matrix. 2.2.1. An example of row reduction. Let us consider the following linear system:    x1 + 2x2 + 3x3 = 1 3x1 + 2x2 + x3 = 7 2x1 + x2 + 2x3 = 1 The augmented matrix of the system is   1 2 3 1 3 2 1 7 2 1 2 1   Subtracting 3·Row#1 from the second row, and subtracting 2·Row#1 from the third one we get:   1 2 3 1 3 2 1 7 2 1 2 1   −3R1 −2R1 ∼   1 2 3 1 0 −4 −8 4 0 −3 −4 −1   Multiplying the second row by −1/4 we get   1 2 3 1 0 1 2 −1 0 −3 −4 −1   Adding 3·Row#2 to the third row we obtain   1 2 3 1 0 1 2 −1 0 −3 −4 −1  −3R2 ∼   1 2 3 1 0 1 2 −1 0 0 2 −4   Now we can use the so called back substitution to solve the system. Namely, from the last row (equation) we get x3 = −2. Then from the second equation we get x2 = −1 − 2x3 = −1 − 2(−2) = 3, and ﬁnally, from the ﬁrst row (equation) x1 = 1 − 2x2 − 3x3 = 1 − 6 + 6 = 1. 44 2. Systems of linear equations So, the solution is    x1 = 1 x2 = 3, x3 = −2, or in vector form x =   1 3 −2   or x = (1, 3, −2)T . We can check the solution by multiplying Ax, where A is the coeﬃcient matrix. Instead of using back substitution, we can do row reduction from bottom to top, killing all the entries above the main diagonal of the coeﬃcient matrix: we start by multiplying the last row by 1/2, and the rest is pretty self-explanatory:   1 2 3 1 0 1 2 −1 0 0 1 −2   −3R3 −2R3 ∼   1 2 0 7 0 1 0 3 0 0 1 −2   −2R2 ∼   1 0 0 1 0 1 0 3 0 0 1 −2   and we just read the solution x = (1, 3, −2)T oﬀ the augmented matrix. We leave it as an exercise to the reader to formulate the algorithm for the backward phase of the row reduction. 2.3. Echelon form. A matrix is in echelon form if it satisﬁes the following two conditions: 1. All zero rows (i.e. the rows with all entries equal 0), if any, are below all non-zero entries. For a non-zero row, let us call the leftmost non-zero entry the leading entry. Then the second property of the echelon form can be formulated as follows: 2. For any non-zero row its leading entry is strictly to the right of the leading entry in the previous row. The leading entry in each row in echelon form is also called pivot entry,Pivots: leading (leftmost non-zero entries) in a row. or simply pivot, because these entries are exactly the pivots we used in the row reduction. A particular case of the echelon form is the so-called triangular form. We got this form in our example above. In this form the coeﬃcient matrix is square (n × n), all its entries on the main diagonal are non-zero, and all the 2. Solution of a linear system. Echelon and reduced echelon forms 45 entries below the main diagonal are zero. The right side, i.e. the rightmost column of the augmented matrix can be arbitrary. After the backward phase of the row reduction, we get what the so- called reduced echelon form of the matrix: coeﬃcient matrix equal I, as in the above example, is a particular case of the reduced echelon form. The general deﬁnition is as follows: we say that a matrix is in the reduced echelon form, if it is in the echelon form and 3. All pivot entries are equal 1; 4. All entries above the pivots are 0. Note, that all entries below the pivots are also 0 because of the echelon form. To get reduced echelon form from echelon form, we work from the bottom to the top and from the right to the left, using row replacement to kill all entries above the pivots. An example of the reduced echelon form is the system with the coeﬃcient matrix equal I. In this case, one just reads the solution from the reduced echelon form. In general case, one can also easily read the solution from the reduced echelon form. For example, let the reduced echelon form of the system (augmented matrix) be   1 2 0 0 0 1 0 0 1 5 0 2 0 0 0 0 1 3   ; here we boxed the pivots. The idea is to move the variables, corresponding to the columns without pivot (the so-called free variables) to the right side. Then we can just write the solution.  |||| |||| x1 = 1 − 2x2 x2 is free x3 = 2 − 5x4 x4 is free x5 = 3 or in the vector form x =       1 − 2x2 x2 2 − 5x4 x4 3  | | | |  =       1 0 2 0 3  | | | |  + x2       −2 1 0 0 0  | | | |  + x4       0 0 −5 1 0  | | | |  , x2, x4 ∈ F. One can also ﬁnd the solution from the echelon form by using back sub- stitution: the idea is to work from bottom to top, moving all free variables to the right side. 46 2. Systems of linear equations Exercises. 2.1. Write the systems of equations below in matrix form and as vector equations: a)    x1 + 2x2 − x3 = −1 2x1 + 2x2 + x3 = 1 3x1 + 5x2 − 2x3 = −1 b)  || || x1 − 2x2 − x3 = 1 2x1 − 3x2 + x3 = 6 3x1 − 5x2 = 7 x1 + 5x3 = 9 c)  || || x1 + 2x2 + 2x4 = 6 3x1 + 5x2 − x3 + 6x4 = 17 2x1 + 4x2 + x3 + 2x4 = 12 2x1 − 7x3 + 11x4 = 7 d)    x1 − 4x2 − x3 + x4 = 3 2x1 − 8x2 + x3 − 4x4 = 9 −x1 + 4x2 − 2x3 + 5x4 = −6 e)    x1 + 2x2 − x3 + 3x4 = 2 2x1 + 4x2 − x3 + 6x4 = 5 x2 + 2x4 = 3 f)    2x1 − 2x2 − x3 + 6x4 −2x5 = 1 x1 − x2 + x3 + 2x4 −x5 = 2 4x1 − 4x2 + 5x3 + 7x4 −x5 = 6 g)  || || 3x1 − x2 + x3 − x4 + 2x5 = 5 x1 − x2 − x3 − 2x4 − x5 = 2 5x1 − 2x2 + x3 − 3x4 + 3x5 = 10 2x1 − x2 − 2x4 + x5 = 5 Solve the systems. Write the answers in the vector form. 2.2. Find all solutions of the vector equation x1v1 + x2v2 + x3v3 = 0, where v1 = (1, 1, 0)T , v2 = (0, 1, 1) T and v3 = (1, 0, 1) T . What conclusion can you make about linear independence (dependence) of the system of vectors v1, v2, v3? 3. Analyzing the pivots. All questions about existence of a solution and it uniqueness can be answered by analyzing pivots in the echelon (reduced echelon) form of the augmented matrix of the system. First of all, let us investigate the question of when is the equation Ax = b inconsistent, i.e. when it does not have a solution. The answer follows immediately, if one just thinks about it: 3. Analyzing the pivots. 47 a system is inconsistent (does not have a solution) if and only if there is a pivot in the last column of an echelon form of the augmented matrix, i.e. iﬀ an echelon form of the augmented matrix has a row ( 0 0 . . . 0 b ), b ̸= 0 in it. Indeed, such a row correspond to the equation 0x1 + 0x2 + . . . + 0xn = b ̸= 0 that does not have a solution. If we don’t have such a row, we just make the reduced echelon form and then read the solution oﬀ it. Now, three more statements. Note, they all deal with the coeﬃcient matrix, and not with the augmented matrix of the system. 1. A solution (if it exists) is unique iﬀ there are no free variables, that is if and only if the echelon form of the coeﬃcient matrix has a pivot in every column; 2. Equation Ax = b is consistent for all right sides b if and only if the echelon form of the coeﬃcient matrix has a pivot in every row. 3. Equation Ax = b has a unique solution for any right side b if and only if echelon form of the coeﬃcient matrix A has a pivot in every column and every row. The ﬁrst statement is trivial, because free variables are responsible for all non-uniqueness. I should only emphasize that this statement does not say anything about the existence. The second statement is a tiny bit more complicated. If we have a pivot in every row of the coeﬃcient matrix, we cannot have the pivot in the last column of the augmented matrix, so the system is always consistent, no matter what the right side b is. Let us show that if we have a zero row in the echelon form of the coeﬃ- cient matrix A, then we can pick a right side b such that the system Ax = b is not consistent. Let Ae echelon form of the coeﬃcient matrix A. Then Ae = EA, where E is the product of elementary matrices, corresponding to the row operations, E = EN . . . E2E1. If Ae has a zero row, then the last row is also zero. Therefore, if we put be = (0, . . . , 0, 1)T (all entries are 0, except the last one), then the equation Aex = be does not have a solution. Multiplying this equation by E−1 from the left, and recalling that E−1Ae = A, we get that the equation Ax = E−1be does not have a solution. Finally, statement 3 immediately follows from statements 1 and 2. □ 48 2. Systems of linear equations From the above analysis of pivots we get several very important corol- laries. The main observation we use is In echelon form, any row and any column have no more than 1 pivot in it (it can have 0 pivots) 3.1. Corollaries about linear independence and bases. Dimension. Questions as to when a system of vectors in Fn is a basis, a linearly inde- pendent or a spanning system, can be easily answered by the row reduction. Proposition 3.1. Let us have a system of vectors v1, v2, . . . , vm ∈ Fn, and let A = [v1, v2, . . . , vm] be an n × m matrix with columns v1, v2, . . . , vm. Then 1. The system v1, v2, . . . , vm is linearly independent iﬀ echelon form of A has a pivot in every column; 2. The system v1, v2, . . . , vm is complete in Fn (spanning, generating) iﬀ echelon form of A has a pivot in every row; 3. The system v1, v2, . . . , vm is a basis in Fn iﬀ echelon form of A has a pivot in every column and in every row. Proof. The system v1, v2, . . . , vm ∈ Fn is linearly independent if and only if the equation x1v1 + x2v2 + . . . + xmvm = 0 has the unique (trivial) solution x1 = x2 = . . . = xm = 0, or equivalently, the equation Ax = 0 has unique solution x = 0. By statement 1 above, it happens if and only if there is a pivot in every column of the matrix. Similarly, the system v1, v2, . . . , vm ∈ Fn is complete in Fn if and only if the equation x1v1 + x2v2 + . . . + xmvm = b has a solution for any right side b ∈ Fn. By statement 2 above, it happens if and only if there is a pivot in every row in echelon form of the matrix. And ﬁnally, the system v1, v2, . . . , vm ∈ Fn is a basis in Fn if and only if the equation x1v1 + x2v2 + . . . + xmvm = b has unique solution for any right side b ∈ Fn. By statement 3 this happens if and only if there is a pivot in every column and in every row of echelon form of A. □ Proposition 3.2. Any linearly independent system of vectors in Fn cannot have more than n vectors in it. 3. Analyzing the pivots. 49 Proof. Let a system v1, v2, . . . , vm ∈ Fn be linearly independent, and let A = [v1, v2, . . . , vm] be the n × m matrix with columns v1, v2, . . . , vm. By Proposition 3.1 echelon form of A must have a pivot in every column, which is impossible if m > n (number of pivots cannot be more than number of rows). □ Proposition 3.3. Any two bases in a vector space V have the same number of vectors in them. Proof. Let v1, v2, . . . , vn and w1, w2, . . . , wm be two diﬀerent bases in V . Without loss of generality we can assume that n ≤ m. Consider an isomor- phism A : Fn → V deﬁned by Aek = vk, k = 1, 2, . . . n, where e1, e2, . . . , en is the standard basis in Rn. Since A−1 is also an isomorphism, the system A−1w1, A −1w2, . . . , A−1wm is a basis (see Theorem 6.6 in Chapter 1). So it is linearly independent, and by Proposition 3.2, m ≤ n. Together with the assumption n ≤ m this implies that m = n. □ The statement below is a particular case of the above proposition. Proposition 3.4. Any basis in Fn must have exactly n vectors in it. Proof. This fact follows immediately from the previous proposition, but there is also a direct proof. Let v1, v2, . . . , vm be a basis in Fn and let A be the n × m matrix with columns v1, v2, . . . , vm. The fact that the system is a basis, means that the equation Ax = b has a unique solution for any (all possible) right side b. The existence means that there is a pivot in every row (of a reduced echelon form of the matrix), hence the number of pivots is exactly n. The uniqueness mean that there is pivot in every column of the coeﬃcient matrix (its echelon form), so m = number of columns = number of pivots = n □ Proposition 3.5. Any spanning (generating) set in Fn must have at least n vectors. Proof. Let v1, v2, . . . , vm be a complete system in Fn, and let A be n × m matrix with columns v1, v2, . . . , vm. Statement 2 of Proposition 3.1 implies 50 2. Systems of linear equations that echelon form of A has a pivot in every row. Since number of pivots cannot exceed the number of columns, n ≤ m. □ 3.2. Corollaries about invertible matrices. Proposition 3.6. A matrix A is invertible if and only if its echelon form has pivot in every column and every row. Proof. As it was discussed in the beginning of the section, the equation Ax = b has a unique solution for any right side b if and only if the echelon form of A has pivot in every row and every column. But, we know, see Theorem 6.8 in Chapter 1, that the matrix (linear transformation) A is invertible if and only if the equation Ax = b has a unique solution for any possible right side b. There is also an alternative proof. We know that a matrix is invertible if and only if its columns form a basis in (see Corollary 6.9 in Section 6.4, Chapter 1). Proposition 3.4 above states that it happens if and only if there is a pivot in every row and every column. □ The above proposition immediately implies the following Corollary 3.7. An invertible matrix must be square (n × n). Proposition 3.8. If a square (n×n) matrix is left invertible, or if it is right invertible, then it is invertible. In other words, to check the invertibility of a square matrix A it is suﬃcient to check only one of the conditions AA−1 = I, A−1A = I. Note, that this proposition applies only to square matrices! Proof. We know that matrix A is invertible if and only if the equation Ax = b has a unique solution for any right side b. This happens if and only if the echelon form of the matrix A has pivots in every row and in every column. If a matrix A is left invertible, the equation Ax = 0 has unique solution x = 0. Indeed, if B is a left inverse of A (i.e. BA = I), and x satisﬁes Ax = 0, then multiplying this identity by B from the left we get x = 0, so the solution is unique. Therefore, the echelon form of A has pivots in every column (no free variables). If the matrix A is square (n × n), the echelon form also has pivots in every row (n pivots, and a row can have no more than 1 pivot), so the matrix is invertible. 3. Analyzing the pivots. 51 If a matrix A is right invertible, and C is its right inverse (AC = I), then for x = Cb, b ∈ Fn Ax = ACb = Ib = b. Therefore, for any right side b the equation Ax = b has a solution x = Cb. Thus, echelon form of A has a pivot in every row. If A is square, it also has a pivot in every column, so A is invertible. □ Exercises. 3.1. For what value of b the system   1 2 2 2 4 6 1 2 3   x =   1 4 b   has a solution. Find the general solution of the system for this value of b. 3.2. Determine, if the vectors     1 1 0 0  | |  ,     1 0 1 0  | |  ,     0 0 1 1  | |  ,     0 1 0 1  | |  are linearly independent or not. Do these four vectors span R4? (In other words, is it a generating system?) What about C4? 3.3. Determine, which of the following systems of vectors are bases in R3: a) (1, 2, −1) T , (1, 0, 2)T , (2, 1, 1)T ; b) (−1, 3, 2) T , (−3, 1, 3)T , (2, 10, 2)T ; c) (67, 13, −47) T , (π, −7.84, 0)T , (3, 0, 0)T . Which of the systems are bases in C3? 3.4. Do the polynomials x3 + 2x, x2 + x + 1, x3 + 5 generate (span) P3? Justify your answer. 3.5. Can 5 vectors in F 4 be linearly independent? Justify your answer. 3.6. Prove or disprove: If the columns of a square (n × n) matrix A are linearly independent, so are the columns of A2 = AA. 3.7. Prove or disprove: If the columns of a square (n × n) matrix A are linearly independent, so are the rows of A3 = AAA. 3.8. Show that if the equation Ax = 0 has unique solution (i.e. if echelon form of A has pivot in every column), then A is left invertible. Hint: elementary matrices may help. Note: It was shown in the text that if A is left invertible, then the equation Ax = 0 has unique solution. But here you are asked to prove the converse of this statement, which was not proved. 52 2. Systems of linear equations Remark: This can be a very hard problem, for it requires deep understanding of the subject. However, when you understand what to do, the problem becomes almost trivial. 3.9. Is the reduced echelon form of a matrix unique? Justify your conclusion. Namely, suppose that by performing some row operations (not necessarily fol- lowing any algorithm) we end up with a reduced echelon matrix. Do we always end up with the same matrix, or can we get diﬀerent ones? Note that we are only allowed to perform row operations, the “column operations”’ are forbidden. Hint: What happens if you start with an invertible matrix? Also, are the pivots always in the same columns, or can it be diﬀerent depending on what row operations you perform? If you can tell what the pivot columns are without reverting to row operations, then the positions of pivot columns do not depend on them. 4. Finding A−1 by row reduction. As it was discussed above, an invertible matrix must be square, and its eche- lon form must have pivots in every row and every column. Therefore reduced echelon form of an invertible matrix is the identity matrix I. Therefore, Any invertible matrix is row equivalent (i.e. can be reduced by row operations) to the identity matrix. Now let us state a simple algorithm of ﬁnding the inverse of an n × n matrix: 1. Form an augmented n×2n matrix (A | I) by writing the n×n identity matrix right of A; 2. Performing row operations on the augmented matrix transform A to the identity matrix I; 3. The matrix I that we added will be automatically transformed to A−1; 4. If it is impossible to transform A to the identity by row operations, A is not invertible. There are several possible explanations of the above algorithm. The ﬁrst, a na¨ıve one, is as follows: we know that (for an invertible A) the vector A−1b is the solution of the equation Ax = b. So to ﬁnd the column number k of A−1 we need to ﬁnd the solution of Ax = ek, where e1, e2, . . . , en is the standard basis in Rn. The above algorithm just solves the equations Ax = ek, k = 1, 2, . . . , n simultaneously! Let us also present another, more “advanced” explanation. As we dis- cussed above, every row operation can be realized as a left multiplication 4. Finding A−1 by row reduction. 53 by an elementary matrix. Let E1, E2, . . . , EN be the elementary matrices corresponding to the row operation we performed, and let E = EN · · · E2E1 be their product. 1 We know that the row operations transform A to iden- tity, i.e. EA = I, so E = A−1. But the same row operations transform the augmented matrix (A | I) to (EA | E) = (I | A−1). □ This “advanced” explanation using elementary matrices implies an im- portant proposition that will be often used later. Theorem 4.1. Any invertible matrix can be represented as a product of elementary matrices. Proof. As we discussed in the previous paragraph, A−1 = EN · · · E2E1, so A = (A−1) −1 = E−1 1 E−1 2 · · · E−1 N . □ An Example. Suppose we want to ﬁnd the inverse of the matrix   1 4 −2 −2 −7 7 3 11 −6   . Augmenting the identity matrix to it and performing row reduction we get   1 4 −2 1 0 0 −2 −7 7 0 1 0 3 11 −6 0 0 1  +2R1 −3R1 ∼   1 4 −2 1 0 0 0 1 3 2 1 0 0 −1 0 −3 0 1   +R2 ∼   1 4 −2 1 0 0 0 1 3 2 1 0 0 0 3 −1 1 1   ×3 ∼   3 12 −6 3 0 0 0 1 3 2 1 0 0 0 3 −1 1 1   +2R3 −R3 ∼ Here in the last row operation we multiplied the ﬁrst row by 3 to avoid fractions in the backward phase of row reduction. Continuing with the row reduction we get   3 12 0 1 2 2 0 1 0 3 0 −1 0 0 3 −1 1 1   −12R2 ∼   3 0 0 −35 2 14 0 1 0 3 0 −1 0 0 3 −1 1 1   Dividing the ﬁrst and the last row by 3 we get the inverse matrix   −35/3 2/3 14/3 3 0 −1 −1/3 1/3 1/3   1Although it does not matter here, but please notice, that if the row operation E1 was performed ﬁrst, E1 must be the rightmost term in the product 54 2. Systems of linear equations Exercises. 4.1. Find the inverse of the matrices   1 2 1 3 7 3 2 3 4   ,   1 −1 2 1 1 −2 1 1 4   . Show all steps 5. Dimension. Finite-dimensional spaces. Deﬁnition. The dimension dim V of a vector space V is the number of vectors in a basis. For a vector space consisting only of zero vector 0 we put dim V = 0. If V does not have a (ﬁnite) basis, we put dim V = ∞. If dim V is ﬁnite, we call the space V ﬁnite-dimensional ; otherwise we call it inﬁnite-dimensional. Proposition 3.3 asserts that the dimension is well deﬁned, i.e. that it does not depend on the choice of a basis. Proposition 2.8 from Chapter 1 states that any ﬁnite spanning system in a vector space V contains a basis. This immediately implies the following Proposition 5.1. A vector space V is ﬁnite-dimensional if and only if it has a ﬁnite spanning system. Suppose, that we have a system of vectors in a ﬁnite-dimensional vector space, and we want to check if it is a basis (or if it is linearly independent, or if it is complete)? Probably the simplest way is to use an isomorphism A : V → Rn, n = dim E to move the problem to Rn, where all such questions can be answered by row reduction (studying pivots). Note, that if dim V = n, then there always exists an isomorphism A : V → Rn. Indeed, if dim V = n then there exists a basis v1, v2, . . . , vn ∈ V , and one can deﬁne an isomorphism A : V → Rn by Avk = ek, k = 1, 2, . . . , n. As an example, let us give the following two corollaries of the above Propositions 3.2, 3.5: Proposition 5.2. Any linearly independent system in a ﬁnite-dimensional vector space V cannot have more than dim V vectors in it. Proof. Let v1, v2, . . . , vm ∈ V be a linearly independent system, and let A : V → Rn be an isomorphism. Then Av1, Av2, . . . , Avm is a linearly independent system in Rn, and by Proposition 3.2 m ≤ n. □ 5. Dimension. Finite-dimensional spaces. 55 Proposition 5.3. Any generating system in a ﬁnite-dimensional vector space V must have at least dim V vectors in it. Proof. Let v1, v2, . . . , vm ∈ V be a complete system in V , and let A : V → Rn be an isomorphism. Then Av1, Av2, . . . , Avm is a complete system in Rn, and by Proposition 3.5 m ≥ n. □ 5.1. Completing a linearly independent system to a basis. The fol- lowing statement will play an important role later. Proposition 5.4 (Completion to a basis). A linearly independent system of vectors in a ﬁnite-dimensional space can be completed to a basis, i.e. if v1, v2, . . . , vr are linearly independent vectors in a ﬁnite-dimensional vector space V then one can ﬁnd vectors vr+1, vr+2 . . . , vn such that the system of vectors v1, v2, . . . , vn is a basis in V . Proof. Let n = dim V .Take any vector not belonging to span{v1, v2, . . . , vr} and call it vr+1 (one can always do that because the system v1, v2, . . . , vr is not generating). By Exercise 2.5 from Chapter 1 the system v1, . . . , vr, vr+1 is linearly independent (notice that in this case r < n by Proposition 5.2). Repeat the procedure with the new system to get vector vr+2, and so on. We will stop the process when we get a generating system. Note, that the process cannot continue inﬁnitely, because a linearly independent system of vectors in V cannot have more than n = dim V vectors. □ 5.2. Subspaces of ﬁnite dimensional spaces. Theorem 5.5. Let V be a subspace of a vector space W , dim W < ∞. Then V is ﬁnite dimensional and dim V ≤ dim W . Moreover, if dim V = dim W then V = W (we are still assuming that V is a subspace of W here). Remark. This theorem looks like a complete banality, like an easy corollary of Proposition 5.2. But we can apply Proposition 5.2 only if we already have a basis in V . And we only have a basis in W , and we cannot say how many vectors in this basis belong to V ; in fact, it is easy to construct an example where none of the vectors in the basis of W belongs to V . Proof of Theorem 5.5. If V = {0} then the theorem is trivial, so let us assume otherwise. We want to ﬁnd a basis in V . Take a non-zero vector v1 ∈ V . If V = span{v1}, we got our basis (consisting of the one vector v1). If not, we continue by induction. Suppose we constructed r linearly independent vectors v1, . . . , vr ∈ V . If V = span{vk : 1 ≤ k ≤ r}, 56 2. Systems of linear equations then we have found a basis in V . If not, there exists a vector vr+1 ∈ V , vr+1 /∈ span{vk : 1 ≤ k ≤ r}. By Exercise 2.5 from Chapter 1 the system v1, . . . , vr, vr+1 is linearly independent. □ Exercises. 5.1. True or false: a) Every vector space that is generated by a ﬁnite set has a basis; b) Every vector space has a (ﬁnite) basis; c) A vector space cannot have more than one basis; d) If a vector space has a ﬁnite basis, then the number of vectors in every basis is the same. e) The dimension of Pn is n; f) The dimension on Mm×n is m + n; g) If vectors v1, v2, . . . , vn generate (span) the vector space V , then every vector in V can be written as a linear combination of vector v1, v2, . . . , vn in only one way; h) Every subspace of a ﬁnite-dimensional space is ﬁnite-dimensional; i) If V is a vector space having dimension n, then V has exactly one subspace of dimension 0 and exactly one subspace of dimension n. 5.2. Prove that if V is a vector space having dimension n, then a system of vectors v1, v2, . . . , vn in V is linearly independent if and only if it spans V . 5.3. Prove that a linearly independent system of vectors v1, v2, . . . , vn in a vector space V is a basis if and only if n = dim V . 5.4. (An old problem revisited: now this problem should be easy) Is it possible that vectors v1, v2, v3 are linearly dependent, but the vectors w1 = v1+v2, w2 = v2+v3 and w3 = v3 + v1 are linearly independent? Hint: What dimension can the subspace span(v1, v2, v3) have? 5.5. Let vectors u, v, w be a basis in V . Show that u + v + w, v + w, w is also a basis in V . 5.6. Consider in the space R5 vectors v1 = (2, −1, 1, 5, −3) T , v2 = (3, −2, 0, 0, 0)T , v3 = (1, 1, 50, −921, 0) T . a) Prove that these vectors are linearly independent. b) Complete this system of vectors to a basis. If you do part b) ﬁrst you can do everything without any computations. 6. General solution of a linear system. In this short section we discuss the structure of the general solution (i.e. of the solution set) of a linear system. 6. General solution of a linear system. 57 We call a system Ax = b homogeneous if the right side b = 0, i.e. a homogeneous system is a system of form Ax = 0. With each system Ax = b we can associate a homogeneous system just by putting b = 0. Theorem 6.1 (General solution of a linear equation). Let a vector x1 satisfy the equation Ax = b, and let H be the set of all solutions of the associated homogeneous system Ax = 0. Then the set {x = x1 + xh : xh ∈ H} is the set of all solutions of the equation Ax = b. In other words, this theorem can be stated as General solution of Ax = b = A particular solu- tion of Ax = b + General solution of Ax = 0 . Proof. Fix a vector x1 satisfying Ax1 = b. Let a vector xh satisfy Axh = 0. Then for x = x1 + xh we have Ax = A(x1 + xh) = Ax1 + Axh = b + 0 = b, so any x of form x = x1 + xh, xh ∈ H is a solution of Ax = b. Now let x satisfy Ax = b. Then for xh := x − x1 we get Axh = A(x − x1) = Ax − Ax1 = b − b = 0, so xh ∈ H. Therefore any solution x of Ax = b can be represented as x = x1 + xh with some xh ∈ H. □ The power of this theorem is in its generality. It applies to all linear equations, we do not have to assume here that vector spaces are ﬁnite- dimensional. You will meet this theorem in diﬀerential equations, integral equations, partial diﬀerential equations, etc. Besides showing the struc- ture of the solution set, this theorem allows one to separate investigation of uniqueness from the study of existence. Namely, to study uniqueness, we only need to analyze uniqueness of the homogeneous equation Ax = 0, which always has a solution. 58 2. Systems of linear equations There is an immediate application in this course: this theorem allows us to check a solution of a system Ax = b. For example, consider a system     2 3 1 4 −9 1 1 1 1 −3 1 1 1 2 −5 2 2 2 3 −8  | |  x =     17 6 8 14  | |  . Performing row reduction one can ﬁnd the solution of this system (6.1) x =       3 1 0 2 0  | | | |  + x3       −2 1 1 0 0  | | | |  + x5       2 −1 0 2 1  | | | |  , x3, x5 ∈ F. The parameters x3, x5 can be denoted here by any other letters, t and s, for example; we are keeping notation x3 and x5 here only to remind us that the parameters came from the corresponding free variables. Now, let us suppose, that we are just given this solution, and we want to check whether or not it is correct. Of course, we can repeat the row operations, but this is too time consuming. Moreover, if the solution was obtained by some non-standard method, it can look diﬀerently from what we get from the row reduction. For example, the formula (6.2) x =       3 1 0 2 0  | | | |  + s       −2 1 1 0 0  | | | |  + t       0 0 1 2 1  | | | |  , s, t ∈ F gives the same set as (6.1) (can you say why?); here we just replaced the last vector in (6.1) by its sum with the second one. So, this formula is diﬀerent from the solution we got from the row reduction, but it is nevertheless correct. The simplest way to check that (6.1) and (6.2) give us correct solutions, is to check that the ﬁrst vector (3, 1, 0, 2, 0)T satisﬁes the equation Ax = b, and that the other two (the ones with the parameters x3 and x5 or s and t in front of them) should satisfy the associated homogeneous equation Ax = 0. If this checks out, we will be assured that any vector x deﬁned by (6.1) or (6.2) is indeed a solution. Note, that this method of checking the solution does not guarantee that (6.1) (or (6.2)) gives us all the solutions. For example, if we just somehow miss out the term with x3, the above method of checking will still work ﬁne. 7. Fundamental subspaces of a matrix. Rank. 59 So, how can we guarantee, that we did not miss any free variable, and there should not be extra term in (6.1)? What comes to mind, is to count the pivots again. In this example, if one does row operations, the number of pivots is 3. So indeed, there should be 2 free variables, and it looks like we did not miss anything in (6.1). To be able to prove this, we will need new notions of fundamental sub- spaces and of rank of a matrix. I should also mention that in this particular example, one does not have to perform all row operations to check that there are only 2 free variables, and that formulas (6.1) and (6.2) both give correct general solutions. Exercises. 6.1. True or false a) Any system of linear equations has at least one solution; b) Any system of linear equations has at most one solution; c) Any homogeneous system of linear equations has at least one solution; d) Any system of n linear equations in n unknowns has at least one solution; e) Any system of n linear equations in n unknowns has at most one solution; f) If the homogeneous system corresponding to a given system of a linear equations has a solution, then the given system has a solution; g) If the coeﬃcient matrix of a homogeneous system of n linear equations in n unknowns is invertible, then the system has no non-zero solution; h) The solution set of any system of m equations in n unknowns is a subspace in Rn; i) The solution set of any homogeneous system of m equations in n unknowns is a subspace in Rn. 6.2. Find a 2 × 3 system (2 equations with 3 unknowns) such that its general solution has a form   1 1 0   + s   1 2 1   , s ∈ R. 7. Fundamental subspaces of a matrix. Rank. As we discussed above in Section 7 of Chapter 1, with any linear transfor- mation A : V → W we can associate two subspaces, namely, its kernel, or null space Ker A = Null A := {v ∈ V : Av = 0} ⊂ V, and its range Ran A = {w ∈ W : w = Av for some v ∈ V } ⊂ W. 60 2. Systems of linear equations In other words, the kernel Ker A is the solution set of the homogeneous equation Ax = 0, and the range Ran A is exactly the set of all right sides b ∈ W for which the equation Ax = b has a solution. If A is an m × n matrix, i.e. a mapping from Fn to Fm, then it follows from the “column by coordinate” rule of the matrix multiplication that any vector w ∈ Ran A can be represented as a linear combination of columns of A. This explains the name column space (notation Col A), which is often used instead of Ran A. If A is a matrix, then in addition to Ran A and Ker A one can also consider the range and kernel for the transposed matrix AT . Often the term row space is used for Ran AT and the term left null space is used for Ker AT (but usually no special notation is introduced). The four subspaces Ran A, Ker A, Ran AT , Ker AT are called the funda- mental subspaces of the matrix A. In this section we will study important relations between the dimensions of the four fundamental subspaces. We will need the following deﬁnition, which is one of the fundamental notions of Linear Algebra Deﬁnition. Given a linear transformation (matrix) A its rank, rank A, is the dimension of the range of A rank A := dim Ran A. 7.1. Computing fundamental subspaces and rank. To compute the fundamental subspaces and rank of a matrix, one needs to do echelon re- duction. Namely, let A be the matrix, and Ae be its echelon form 1. The pivot columns of the original matrix A (i.e. the columns where after row operations we will have pivots in the echelon form) give us a basis (one of many possible) in Ran A. 2. The pivot rows of the echelon from Ae give us a basis in the row space. Of course, it is possible just to transpose the matrix, and then do row operations. But if we already have the echelon form of A, say by computing Ran A, then we get Ran AT for free. 3. To ﬁnd a basis in the null space Ker A one needs to solve the homo- geneous equation Ax = 0: the details will be seen from the example below. Example. Consider a matrix     1 1 2 2 1 2 2 1 1 1 3 3 3 3 2 1 1 −1 −1 0  | |  . 7. Fundamental subspaces of a matrix. Rank. 61 Performing row operations we get the echelon form     1 1 2 2 1 0 0 −3 −3 −1 0 0 0 0 0 0 0 0 0 0  | |  (the pivots are boxed here). So, the columns 1 and 3 of the original matrix, i.e. the columns     1 2 3 1  | |  ,     2 1 3 −1  | |  give us a basis in Ran A. We also get a basis for the row space Ran AT for free: the ﬁrst and second row of the echelon form of A, i.e. the vectors       1 1 2 2 1  | | | |  ,       0 0 −3 −3 −1  | | | |  (we put the vectors vertically here. The question of whether to put vectors here vertically as columns, or horizontally as rows is is really a matter of convention. Our reason for putting them vertically is that although we call Ran AT the row space we deﬁne it as a column space of AT ) To compute the basis in the null space Ker A we need to solve the equa- tion Ax = 0. Compute the reduced echelon form of A, which in this example is     1 1 0 0 1/3 0 0 1 1 1/3 0 0 0 0 0 0 0 0 0 0  | |  . Note, that when solving the homogeneous equation Ax = 0, it is not neces- sary to write the whole augmented matrix, it is suﬃcient to work with the coeﬃcient matrix. Indeed, in this case the last column of the augmented matrix is the column of zeroes, which does not change under row opera- tions. So, we can just keep this column in mind, without actually writing it. Keeping this last zero column in mind, we can read the solution oﬀ the 62 2. Systems of linear equations reduced echelon form above:  |||| |||| x1 = −x2 − 1 3 x5, x2 is free, x3 = −x4 − 1 3 x5 x4 is free, x5 is free, or, in the vector form (7.1) x =       −x2 − 1 3 x5 x2 −x4 − 1 3 x5 x4 x5  | | | |  = x2       −1 1 0 0 0  | | | |  + x4       0 0 −1 1 0  | | | |  + x5       −1/3 0 −1/3 0 1  | | | |  The vectors at each free variable, i.e. in our case the vectors       −1 1 0 0 0  | | | |  ,       0 0 −1 1 0  | | | |  ,       −1/3 0 −1/3 0 1  | | | |  form a basis in Ker A. Unfortunately, there is no shortcut for ﬁnding a basis in Ker AT , one must solve the equation AT x = 0. The knowledge of the echelon form of A does not help here. 7.2. Explanation of the computing bases in the fundamental sub- spaces. So, why do the above methods indeed give us bases in the funda- mental subspaces? 7.2.1. The null space Ker A. The case of the null space Ker A is probably the simplest one: since we solved the equation Ax = 0, i.e. found all the solutions, then any vector in Ker A is a linear combination of the vectors we obtained. Thus, the vectors we obtained form a spanning system in Ker A. To see that the system is linearly independent, let us multiply each vector by the corresponding free variable and add everything, see (7.1). Then for each free variable xk, the entry number k of the resulting vector is exactly xk, see (7.1) again, so the only way this vector (the linear combination) can be 0 is when all free variables are 0. 7.2.2. The column space Ran A. Let us now explain why the method for ﬁnding a basis in the column space Ran A works. First of all, notice that the pivot columns of the reduced echelon form Are of A form a basis in Ran Are (not in the column space of the original matrix, but of its reduced 7. Fundamental subspaces of a matrix. Rank. 63 echelon form!). Since row operations are just left multiplications by invert- ible matrices, they do not change linear independence. Therefore, the pivot columns of the original matrix A are linearly independent. Let us now show that the pivot columns of A span the column space of A. Let v1, v2, . . . , vr be the pivot columns of A, and let v be an arbi- trary column of A. We want to show that v can be represented as a linear combination of the pivot columns v1, v2, . . . , vr, v = α1v1 + α2v2 + . . . + αrvr. The reduced echelon form Are is obtained from A by the left multiplication Are = EA, where E is a product of elementary matrices, so E is an invertible matrix. The vectors Ev1, Ev2, . . . , Evr are the pivot columns of Are, and the column v of A is transformed to the column Ev of Are. Since the pivot columns of Are form a basis in Ran Are, vector Ev can be represented as a linear combination Ev = α1Ev1 + α2Ev2 + . . . + αrEvr. Multiplying this equality by E−1 from the left we get the representation v = α1v1 + α2v2 + . . . + αrvr, so indeed the pivot columns of A span Ran A. 7.2.3. The row space Ran AT . It is easy to see that the pivot rows of the echelon form Ae of A are linearly independent. Indeed, let w1, w2, . . . , wr be the transposed (since we agreed always to put vectors vertically) pivot rows of Ae. Suppose α1w1 + α2w2 + . . . + αrwr = 0. Consider the ﬁrst non-zero entry of w1. Since for all other vectors w2, w3, . . . , wr the corresponding entries equal 0 (by the deﬁnition of eche- lon form), we can conclude that α1 = 0. So we can just ignore the ﬁrst term in the sum. Consider now the ﬁrst non-zero entry of w2. The corresponding entries of the vectors w3, . . . , wr are 0, so α2 = 0. Repeating this procedure, we get that αk = 0 ∀k = 1, 2, . . . , r. To see that vectors w1, w2, . . . , wr span the row space, one can notice that row operations do not change the row space. This can be obtained directly from analyzing row operations, but we present here a more formal way to demonstrate this fact. For a transformation A and a set X let us denote by A(X) the set of all elements y which can represented as y = A(x), x ∈ X, A(X) := {y = A(x) : x ∈ X} . 64 2. Systems of linear equations If A is an m × n matrix, and Ae is its echelon form, Ae is obtained from A be left multiplication Ae = EA, where E is an m × m invertible matrix (the product of the corresponding elementary matrices). Then Ran AT e = Ran(AT ET ) = AT (Ran ET ) = AT (Rm) = Ran A T , so indeed Ran AT = Ran AT e . 7.3. The Rank Theorem. Dimensions of fundamental subspaces. There are many applications in which one needs to ﬁnd a basis in column space or in the null space of a matrix. For example, as it was shown above, solving a homogeneous equation Ax = 0 amounts to ﬁnding a basis in the null space Ker A. Finding a basis in the column space means simply extracting a basis from a spanning set, by removing unnecessary vectors (columns). However, the most important application of the above methods of com- puting bases of fundamental subspaces is the relations between their dimen- sions. Theorem 7.1 (The Rank Theorem). For a matrix A rank A = rank AT . This theorem is often stated as follows: The column rank of a matrix coincides with its row rank. The proof of this theorem is trivial, since dimensions of both Ran A and Ran AT are equal to the number of pivots in the echelon form of A. The following theorem is gives us important relations between dimen- sions of the fundamental spaces. It is often also called the Rank Theorem Theorem 7.2. Let A be an m × n matrix, i.e. a linear transformation from Fn to Fm. Then 1. dim Ker A + dim Ran A = dim Ker A + rank A = n (dimension of the domain of A); 2. dim Ker AT + dim Ran AT = dim Ker AT + rank AT = dim Ker AT + rank A = m (dimension of the target space of A); Proof. The proof, modulo the above algorithms of ﬁnding bases in the fundamental subspaces, is almost trivial. The ﬁrst statement is simply the fact that the number of free variables (dim Ker A) plus the number of basic variables (i.e. the number of pivots, i.e. rank A) adds up to the number of columns (i.e. to n). 7. Fundamental subspaces of a matrix. Rank. 65 The second statement, if one takes into account that rank A = rank AT is simply the ﬁrst statement applied to AT . □ As an application of the above theorem, let us recall the example from Section 6. There we considered a system     2 3 1 4 −9 1 1 1 1 −3 1 1 1 2 −5 2 2 2 3 −8  | |  x =     17 6 8 14  | |  , and we claimed that its general solution given by x =       3 1 0 2 0  | | | |  + x3       −2 1 1 0 0  | | | |  + x5       2 −1 0 2 1  | | | |  , x3, x5 ∈ F, or by x =       3 1 0 2 0  | | | |  + s       −2 1 1 0 0  | | | |  + t       0 0 1 2 1  | | | |  , s, t ∈ F. We checked in Section 6 that a vector x given by either formula is indeed a solution of the equation. But, how can we guarantee that any of the formulas describe all solutions? First of all, we know that in either formula, the last 2 vectors (the ones multiplied by the parameters) belong to Ker A. It is easy to see that in either case both vectors are linearly independent (two vectors are linearly dependent if and only if one is a multiple of the other). Now, let us count dimensions: interchanging the ﬁrst and the second rows and performing ﬁrst round of row operations −2R1 −R1 −2R1     1 1 1 1 −3 2 3 1 4 −9 1 1 1 2 −5 2 2 2 3 −8  | |  ∼     1 1 1 1 −3 0 1 −1 2 −3 0 0 0 1 −2 0 0 0 1 −2  | |  we see that there are three pivots already, so rank A ≥ 3. (Actually, we already can see that the rank is 3, but it is enough just to have the estimate here). By Theorem 7.2, rank A + dim Ker A = 5, hence dim Ker A ≤ 2, and therefore there cannot be more than 2 linearly independent vectors in Ker A. Therefore, last 2 vectors in either formula form a basis in Ker A, so either formula give all solutions of the equation. 66 2. Systems of linear equations An important corollary of the rank theorem, is the following theorem connecting existence and uniqueness for linear equations. Theorem 7.3. Let A be an m × n matrix. Then the equation Ax = b has a solution for every b ∈ Rm if and only if the dual equation AT x = 0 has a unique (only the trivial) solution. (Note, that in the second equation we have AT , not A). Proof. The proof follows immediately from Theorem 7.2 by counting the dimensions. We leave the details as an exercise to the reader. □ There is a very nice geometric interpretation of the second rank the- orem (Theorem 7.2). Namely, statement 1 of the theorem says, that if a transformation A : Fn → Fm has trivial kernel (Ker A = {0}), then the dimensions of the domain Fn and of the range Ran A coincide. If the ker- nel is non-trivial, then the transformation “kills” dim Ker A dimensions, so dim Ran A = n − dim Ker A. 7.4. Completion of a linearly independent system to a basis. As Proposition 5.4 from Section 5 above asserts, any linearly independent sys- tem can be completed to a basis, i.e. given inearly independent vectors v1, v2, . . . , vr in a ﬁnite-dimensional vector space V , one can ﬁnd vectors vr+1, vr+2 . . . , vn such that the system of vectors v1, v2, . . . , vn is a basis in V . Theoretically, the proof of this proposition give us an algorithm of ﬁnding the vectors vr+1, vr+2 . . . , vn, but this algorithm does not look too practical. Ideas of this section give us a more practical way to perform the com- pletion to a basis. First of all, notice that if an m × n matrix is in an echelon form, then its non-zero rows (which are clearly linearly independent) can be easily com- pleted to a basis in the whole space Fn; one just needs to add some rows in appropriate places, so the resulting matrix is still in the echelon form and has pivots in every column. Then, the non-zero rows of the new matrix form a basis, and we can order it any way we want, because property of being basis does not depend on the ordering. Suppose now that we have linearly independent vectors v1, v2, . . . , vr, vk ∈ Fn. Consider the matrix A with rows vT 1 , vT 2 , . . . , vT r and perform row operations to get the echelon form Ae. As we discussed above, the rows of 7. Fundamental subspaces of a matrix. Rank. 67 Ae can be easily completed to a basis in Rn. And it turns out that the same vectors that complete rows of Ae to a basis complete to a basis the original vectors v1, v2, . . . , vr. To see that, let vectors vr+1, . . . , vn complete the rows of Ae to a basis in Fn. Then, if we add to a matrix Ae rows vT r+1, . . . , vT n , we get an invertible matrix. Let call this matrix ̃Ae, and let ̃A be the matrix obtained from A by adding rows vT r+1, . . . , vT n . The matrix ̃Ae can be obtained from ̃A by row operations, so ̃Ae = E ̃A, where E is the product of the corresponding elementary matrices. Then ̃A = E−1 and ̃A is invertible as a product of invertible matrices. But that means that the rows of ̃A form a basis in Fn, which is exactly what we need. Remark. The method of completion to a basis described above may be not the simplest one, but one of its principal advantages is that it works for vector spaces over an arbitrary ﬁeld. Exercises. 7.1. True or false: a) The rank of a matrix is equal to the number of its non-zero columns; b) The m × n zero matrix is the only m × n matrix having rank 0; c) Elementary row operations preserve rank; d) Elementary column operations do not necessarily preserve rank; e) The rank of a matrix is equal to the maximum number of linearly inde- pendent columns in the matrix; f) The rank of a matrix is equal to the maximum number of linearly inde- pendent rows in the matrix; g) The rank of an n × n matrix is at most n; h) An n × n matrix having rank n is invertible. 7.2. A 54 × 37 matrix has rank 31. What are dimensions of all 4 fundamental subspaces? 7.3. Compute rank and ﬁnd bases of all four fundamental subspaces for the matrices   1 1 0 0 1 1 1 1 0   ,     1 2 3 1 1 1 4 0 1 2 0 2 −3 0 1 1 0 0 0 0  | |  . 7.4. Prove that if A : X → Y and V is a subspace of X then dim AV ≤ rank A. (AV here means the subspace V transformed by the transformation A, i.e. any vector in AV can be represented as Av, v ∈ V ). Deduce from here that rank(AB) ≤ rank A. 68 2. Systems of linear equations Remark: Here one can use the fact that if V ⊂ W then dim V ≤ dim W . Do you understand why is it true? 7.5. Prove that if A : X → Y and V is a subspace of X then dim AV ≤ dim V . Deduce from here that rank(AB) ≤ rank B. 7.6. Prove that if the product AB of two n × n matrices is invertible, then both A and B are invertible. Even if you know about determinants, do not use them, we did not cover them yet. Hint: use previous 2 problems. 7.7. Prove that if Ax = 0 has unique solution, then the equation AT x = b has a solution for every right side b. Hint: count pivots 7.8. Write a matrix with the required property, or explain why no such matrix exists a) Column space contains (1, 0, 0) T , (0, 0, 1)T , row space contains (1, 1)T , (1, 2) T ; b) Column space is spanned by (1, 1, 1)T , nullspace is spanned by (1, 2, 3)T ; c) Column space is R4, row space is R3. Hint: Check ﬁrst if the dimensions add up. 7.9. If A has the same four fundamental subspaces as B, does A = B? 7.10. Complete the rows of a matrix     e3 3 4 0 −π 6 −2 0 0 2 −1 πe 1 1 0 0 0 0 3 −3 2 0 0 0 0 0 0 1  | |  to a basis in R7. 7.11. For a matrix     1 2 −1 2 3 2 2 1 5 5 3 6 −3 0 24 −1 −4 4 −7 11  | |  ﬁnd bases in its column and row spaces. 7.12. For the matrix in the previous problem, complete the basis in the row space to a basis in R5 7.13. For the matrix A = ( 1 i i −1 ) compute Ran A and Ker A. What can you say about relation between these sub- spaces? 7.14. Is it possible that for a real matrix A that Ran A = Ker AT ? Is it possible for a complex A? 7.15. Complete the vectors (1, 2, −1, 2, 3)T , (2, 2, 1, 5, 5) T , (−1, −4, 4, 7, −11) T to a basis in R5. 8. Change of coordinates 69 8. Representation of a linear transformation in arbitrary bases. Change of coordinates formula. The material we have learned about linear transformations and their matri- ces can be easily extended to transformations in abstract vector spaces with ﬁnite bases. In this section we will distinguish between a linear transforma- tion T and its matrix, the reason being that we consider diﬀerent bases, so a linear transformation can have diﬀerent matrix representation. 8.1. Coordinate vector. Let V be a vector space with a basis B := {b1, b2, . . . , bn}. Any vector v ∈ V admits a unique representation as a linear combination v = x1b1 + x2b2 + . . . + xnbn = n∑ k=1 xkbk. The numbers x1, x2, . . . , xn are called the coordinates of the vector v in the basis B. It is convenient to join these coordinates into the so-called coordinate vector of v relative to the basis B, which is the column vector [v]B :=      x1 x2 ... xn  | | |  ∈ Fn. Note that the mapping v 7→ [v]B is an isomorphism between V and Fn. It transforms the basis b1, b2, . . . , bn to the standard basis e1, e2, . . . , en in Fn. 8.2. Matrix of a linear transformation. Let T : V → W be a linear transformation, and let A = {a1, a2, . . . , an}, B := {b1, b2, . . . , bm} be bases in V and W respectively. A matrix of the transformation T in (or with respect to) the bases A and B is an m × n matrix, denoted by [T ] BA, which relates the coordinate vectors [T v] B and [v]A, [T v]B = [T ]BA[v]A; notice the balance of symbols A and B here: this is the reason we put the ﬁrst basis A into the second position. The matrix [T ] BA is easy to ﬁnd: its kth column is just the coordinate vector [T ak] B (compare this with ﬁnding the matrix of a linear transforma- tion from Fn to Fm). 70 2. Systems of linear equations As in the case of standard bases, composition of linear transformations is equivalent to multiplication of their matrices: one only has to be a bit more careful about bases. Namely, let T1 : X → Y and T2 : Y → Z be linear transformation, and let A, B and C be bases in X, Y and Z respectively. Then for the composition T = T2T1, T : X → Z, T x := T2(T1(x)) we have (8.1) [T ]CA = [T2T1] CA = [T2] CB [T1] BA (notice again the balance of indices here). The proof here goes exactly as in the case of Fn spaces with standard bases, so we do not repeat it here. Another possibility is to transfer every- thing to the spaces Fn via the coordinate isomorphisms v 7→ [v] B . Then one does not need any proof, everything follows from the results about matrix multiplication. 8.3. Change of coordinate matrix. Let us have two bases A = {a1, a2, . . . , an} and B = {b1, b2, . . . , bn} in a vector space V . Consider the identity transformation I = IV and its matrix [I]BA in these bases. By the deﬁnition [v] B = [I] BA[v] A, ∀v ∈ V, i.e. for any vector v ∈ V the matrix [I] BA transforms its coordinates in the basis A into coordinates in the basis B. The matrix [I] BA is often called the change of coordinates (from the basis A to the basis B) matrix. The matrix [I] BA is easy to compute: according to the general rule of ﬁnding the matrix of a linear transformation, its kth column is the coordi- nate representation [ak] B of kth element of the basis A Note that [I] AB = ([I] BA)−1, (follows immediately from the multiplication of matrices rule (8.1)), so any change of coordinate matrix is always invertible. 8.3.1. An example: change of coordinates from the standard basis. Let our space V be Fn, and let us have a basis B = {b1, b2, . . . , bn} there. We also have the standard basis S = {e1, e2, . . . , en} there. The change of coordinates matrix [I] SB is easy to compute: [I]SB = [b1, b2, . . . , bn] =: B, i.e. it is just the matrix B whose kth column is the vector (column) vk. And in the other direction [I] BS = ([I] SB ) −1 = B−1. 8. Change of coordinates 71 For example, consider a basis B = {( 1 2 ) , ( 2 1 )} in F2, and let S denote the standard basis there. Then [I] SB = ( 1 2 2 1 ) =: B and [I] BS = [I]−1 SB = B−1 = 1 3 ( −1 2 2 −1 ) (we know how to compute inverses, and it is also easy to check that the above matrix is indeed the inverse of B) 8.3.2. An example: going through the standard basis. In the space of poly- nomials of degree at most 1 we have bases A = {1, 1 + x}, and B = {1 + 2x, 1 − 2x}, and we want to ﬁnd the change of coordinate matrix [I] BA. Of course, we can always take vectors from the basis A and try to de- compose them in the basis B; it involves solving linear systems, and we know how to do that. However, I think the following way is simpler. In P1 we also have the standard basis S = {1, x}, and for this basis [I] SA = ( 1 1 0 1 ) =: A, [I] SB = ( 1 1 2 −2 ) =: B, and taking the inverses [I] AS = A−1 = ( 1 −1 0 1 ) , [I] BS = B−1 = 1 4 ( 2 1 2 −1 ) . Then [I] BA = [I]BS [I]SA = B−1A = 1 4 ( 2 1 2 −1 ) ( 1 1 0 1 ) and Notice the balance of indices here. [I] AB = [I] AS [I]SB = A−1B = ( 1 −1 0 1 ) ( 1 1 2 −2 ) 72 2. Systems of linear equations 8.4. Matrix of a transformation and change of coordinates. Let T : V → W be a linear transformation, and let A, ̃A be two bases in V and let B, ̃B be two bases in W . Suppose we know the matrix [T ] BA, and we would like to ﬁnd the matrix representation with respect to new bases ̃A, ̃B, i.e. the matrix [T ] ̃B ̃A. The rule is very simple: to get the matrix in the “new” bases one has to surround the matrix in the “old” bases by change of coordinates matrices. I did not mention here what change of coordinate matrix should go where, because we don’t have any choice if we follow the balance of indices rule. Namely, matrix representation of a linear transformation changes according to the formulaNotice the balance of indices. [T ] ̃B ̃A = [I] ̃BB [T ]BA[I] A ̃A The proof can be done just by analyzing what each of the matrices does. 8.5. Case of one basis: similar matrices. Let V be a vector space and let A = {a1, a2, . . . , an} be a basis in V . Consider a linear transformation T : V → V and let [T ]AA be its matrix in this basis (we use the same basis for “inputs” and “outputs”) The case when we use the same basis for “inputs” and “outputs” is very important (because in this case we can multiply a matrix by itself), so let us study this case a bit more carefully. Notice, that very often in this[T ] A is often used in- stead of [T ] AA . It is shorter, but two in- dex notation is bet- ter adapted to the balance of indices rule. case the shorter notation [T ] A is used instead of [T ] AA. However, the two index notation [T ]AA is better adapted to the balance of indices rule, so I recommend using it (or at least always keep it in mind) when doing change of coordinates. Let B = {b1, b2, . . . , bn} be another basis in V . By the change of coordinate rule above [T ] BB = [I]BA[T ]AA[I] AB Recalling that [I] BA = [I]−1 AB and denoting Q := [I] AB , we can rewrite the above formula as [T ] BB = Q −1[T ] AAQ. This gives a motivation for the following deﬁnition Deﬁnition 8.1. We say that a matrix A is similar to a matrix B if there exists an invertible matrix Q such that A = Q−1BQ. 8. Change of coordinates 73 Since an invertible matrix must be square, it follows from counting di- mensions, that similar matrices A and B have to be square and of the same size. If A is similar to B, i.e. if A = Q−1BQ, then B = QAQ −1 = (Q −1)−1A(Q −1) (since Q−1 is invertible), therefore B is similar to A. So, we can just say that A and B are similar. The above reasoning shows, that it does not matter where to put Q and where Q−1: one can use the formula A = QBQ−1 in the deﬁnition of similarity. The above discussion shows, that one can treat similar matrices as dif- ferent matrix representation of the same linear operator (transformation). Exercises. 8.1. True or false a) Every change of coordinate matrix is square; b) Every change of coordinate matrix is invertible; c) The matrices A and B are called similar if B = Q T AQ for some matrix Q; d) The matrices A and B are called similar if B = Q −1AQ for some matrix Q; e) Similar matrices do not need to be square. 8.2. Consider the system of vectors (1, 2, 1, 1)T , (0, 1, 3, 1)T , (0, 3, 2, 0)T , (0, 1, 0, 0)T . a) Prove that it is a basis in F 4. Try to do minimal amount of computations. b) Find the change of coordinate matrix that changes the coordinates in this basis to the standard coordinates in F 4 (i.e. to the coordinates in the stan- dard basis e1, . . . , e4). 8.3. Find the change of coordinates matrix that changes the coordinates in the basis 1, 1 + t in P1 to the coordinates in the basis 1 − t, 2t. 8.4. Let T be the linear operator in F 2 deﬁned (in the standard coordinates) by T ( x y ) = ( 3x + y x − 2y ) Find the matrix of T in the standard basis and in the basis (1, 1) T , (1, 2)T . 8.5. Prove, that if A and B are similar matrices then trace A = trace B. Hint: recall how trace(XY ) and trace(Y X) are related. 8.6. Are the matrices ( 1 3 2 2 ) and ( 0 2 4 2 ) similar? Justify. Chapter 3 Determinants 1. Introduction. The reader probably already met determinants in calculus or algebra, at least the determinants of 2 × 2 and 3 × 3 matrices. For a 2 × 2 matrix ( a b c d ) the determinant is simply ad − bc; the determinant of a 3 × 3 matrix can be found by the “Star of David” rule. In this chapter we would like to introduce determinants for n × n matri- ces. I don’t want just to give a formal deﬁnition. First I want to give some motivation, and then derive some properties the determinant should have. Then if we want to have these properties, we do not have any choice, and arrive to several equivalent deﬁnitions of the determinant. It is more convenient to start not with the determinant of a matrix, but with determinant of a system of vectors. There is no real diﬀerence here, since we always can join vectors together (say as columns) to form a matrix. Let us have n vectors v1, v2, . . . , vn in Rn (notice that the number of vectors coincides with dimension), and we want to ﬁnd the n-dimensional volume of the parallelepiped determined by these vectors. The parallelepiped determined by the vectors v1, v2, . . . , vn can be de- ﬁned as the collection of all vectors v ∈ Rn that can be represented as v = t1v1 + t2v2 + . . . + tnvn, 0 ≤ tk ≤ 1 ∀k = 1, 2, . . . , n. It can be easily visualized when n = 2 (parallelogram) and n = 3 (paral- lelepiped). So, what is the n-dimensional volume? 75 76 3. Determinants If n = 2 it is area; if n = 3 it is indeed the volume. In dimension 1 is it just the length. Finally, let us introduce some notation. For a system of vectors (col- umns) v1, v2, . . . , vn we will denote its determinant (that we are going to construct) as D(v1, v2, . . . , vn). If we join these vectors in a matrix A (col- umn number k of A is vk), then we will use the notation det A, det A = D(v1, v2, . . . , vn) Also, for a matrix A =      a1,1 a1,2 . . . a1,n a2,1 a2,2 . . . a2,n ... ... ... an,1 an,2 . . . an,n  | | |  its determinant is often is denoted by \f \f \f \f \f \f \f \f \f a1,1 a1,2 . . . a1,n a2,1 a2,2 . . . a2,n ... ... ... an,1 an,2 . . . an,n \f \f \f \f \f \f \f \f \f . 2. What properties determinant should have. We know, that for dimensions 2 and 3 “volume” of a parallelepiped is de- termined by the base times height rule: if we pick one vector, then height is the distance from this vector to the subspace spanned by the remaining vectors, and the base is the (n − 1)-dimensional volume of the parallelepiped determined by the remaining vectors. Now let us generalize this idea to higher dimensions. For a moment we do not care about how exactly to determine height and base. We will show, that if we assume that the base and the height satisfy some natural properties, then we do not have any choice, and the volume (determinant) is uniquely deﬁned. 2.1. Linearity in each argument. First of all, if we multiply vector v1 by a positive number a, then the height (i.e. the distance to the linear span L(v2, . . . , vn)) is multiplied by a. If we admit negative heights (and negative volumes), then this property holds for all scalars a, and so the determinant D(v1, v2, . . . , vn) of the system v1, v2, . . . , vn should satisfy D(αv1, v2, . . . , vn) = αD(v1, v2, . . . , vn). 2. What properties determinant should have. 77 Of course, there is nothing special about vector v1, so for any index k (2.1) D(v1, . . . , αvk k , . . . , vn) = αD(v1, . . . , vk k , . . . , vn) To get the next property, let us notice that if we add 2 vectors, then the “height” of the result should be equal the sum of the “heights” of summands, i.e. that (2.2) D(v1, . . . , uk + vk| {z } k , . . . , vn) = D(v1, . . . , uk k , . . . , vn) + D(v1, . . . , vk k , . . . , vn) In other words, the above two properties say that the determinant of n vectors is linear in each argument (vector), meaning that if we ﬁx n − 1 vectors and interpret the remaining vector as a variable (argument), we get a linear function. Remark. We already know that linearity is a very nice property, that helps in many situations. So, admitting negative heights (and therefore negative volumes) is a very small price to pay to get linearity, since we can always put on the absolute value afterwards. In fact, by admitting negative heights, we did not sacriﬁce anything! To the contrary, we even gained something, because the sign of the determinant contains some information about the system of vectors (orientation). 2.2. Preservation under “column replacement”. The next property also seems natural. Namely, if we take a vector, say vj, and add to it a multiple of another vector vk, the “height” does not change, so (2.3) D(v1, . . . , vj + αvk | {z } j , . . . , vk k , . . . , vn) = D(v1, . . . , vj j , . . . , vk k , . . . , vn) In other words, if we apply the column operation of the third type, the determinant does not change. Remark. Although it is not essential here, let us notice that the second part of linearity (property (2.2)) is not independent: it can be deduced from properties (2.1) and (2.3). We leave the proof as an exercise for the reader. 2.3. Antisymmetry. The next property the determinant should have, is Functions of several variables that change sign when one interchanges any two arguments are called antisymmetric. that if we interchange 2 vectors, the determinant changes sign: (2.4) D(v1, . . . , vk j , . . . , vj k , . . . , vn) = −D(v1, . . . , vj j , . . . , vk k , . . . , vn). 78 3. Determinants At ﬁrst sight this property does not look natural, but it can be deduced from the previous ones. Namely, applying property (2.3) three times, and then using (2.1) we get D(v1, . . . , vj j , . . . , vk k , . . . , vn) = = D(v1, . . . , vj j , . . . , vk − vj | {z } k , . . . , vn) = D(v1, . . . , vj + (vk − vj) | {z } j , . . . , vk − vj | {z } k , . . . , vn) = D(v1, . . . , vk j , . . . , vk − vj | {z } k , . . . , vn) = D(v1, . . . , vk j , . . . , (vk − vj) − vk | {z } k , . . . , vn) = D(v1, . . . , vk j , . . . , −vj k , . . . , vn) = −D(v1, . . . , vk j , . . . , vj k , . . . , vn). 2.4. Normalization. The last property is the easiest one. For the stan- dard basis e1, e2, . . . , en in Rn the corresponding parallelepiped is the n- dimensional unit cube, so (2.5) D(e1, e2, . . . , en) = 1. In matrix notation this can be written as det(I) = 1 3. Constructing the determinant. The plan of the game is now as follows: using the properties that as we decided in Section 2 the determinant should have, we derive other properties of the determinant, some of them highly non-trivial. We will show how to use these properties to compute the determinant using our old friend—row reduction. Later, in Section 4, we will show that the determinant, i.e. a function with the desired properties exists and unique. After all we have to be sure that the object we are computing and studying exists. While our initial geometric motivation for determinant and its properties came from considering vectors in the real vector space Rn, so they relate only to matrices with real entries, all the constructions below use only algebraic operations (addition, multiplication, division) and are applicable to matrices with complex entries, and even with entries in an arbitrary ﬁeld. 3. Constructing the determinant. 79 So in what follows we are constructing determinant not just for real matrices, but for complex matrices as well (and also for matrices with entries in an arbitrary ﬁeld). The nice geometric motivation for the properties works only in the real case, but after we decided on the properties of the determinant (see properties 1–3 below) everything works in the general case. 3.1. Basic properties. We will use the following basic properties of the determinant: 1. Determinant is linear in each column, i.e. in vector notation for every index k D(v1, . . . , αuk + βvk| {z } k , . . . , vn) = αD(v1, . . . , uk k , . . . , vn) + βD(v1, . . . , vk k , . . . , vn) for all scalars α, β. 2. Determinant is antisymmetric, i.e. if one interchanges two columns, the determinant changes sign. 3. Normalization property: det I = 1. All these properties were discussed above in Section 2. The ﬁrst property is just the (2.1) and (2.2) combined. The second one is (2.4), and the last one is the normalization property (2.5). Note, that we did not use property (2.3): it can be deduced from the above three. These three properties completely deﬁne determinant! 3.2. Properties of determinant deduced from the basic properties. Proposition 3.1. For a square matrix A the following statements hold: 1. If A has a zero column, then det A = 0. 2. If A has two equal columns, then det A = 0; 3. If one column of A is a multiple of another, then det A = 0; 4. If columns of A are linearly dependent, i.e. if the matrix is not in- vertible, then det A = 0. Proof. Statement 1 follows immediately from linearity. If we multiply the zero column by zero, we do not change the matrix and its determinant. But by the property 1 above, we should get 0. The fact that determinant is antisymmetric, implies statement 2. In- deed, if we interchange two equal columns, we change nothing, so the deter- minant remains the same. On the other hand, interchanging two columns 80 3. Determinants changes sign of determinant, so det A = − det A, which is possible only if det A = 0. Statement 3 is immediate corollary of statement 2 and linearity. To prove the last statement, let us ﬁrst suppose that the ﬁrst vector v1 is a linear combination of the other vectors, v1 = α2v2 + α3v3 + . . . + αnvn = n∑ k=2 αkvk. Then by linearity we have (in vector notation) D(v1, v2, . . . , vn) = D (( n∑ k=2 αkvk), v2, v3, . . . , vn ) = n∑ k=2 αkD(vk, v2, v3, . . . , vn) and each determinant in the sum is zero because of two equal columns. Let us now consider general case, i.e. let us assume that the system v1, v2, . . . , vn is linearly dependent. Then one of the vectors, say vk can be represented as a linear combination of the others. Interchanging this vector with v1 we arrive to the situation we just treated, so D(v1, . . . , vk k , . . . , vn) = −D(vk, . . . , v1 k , . . . , vn) = −0 = 0, so the determinant in this case is also 0. □ The next proposition generalizes property (2.3). As we already have said above, this property can be deduced from the three “basic” properties of the determinant, we are using in this section. Proposition 3.2. The determinant does not change if we add to a col-Note, that adding to a column a multiple of itself is prohibited here. We can only add multiples of the other columns. umn a linear combination of the other columns (leaving the other columns intact). In particular, the determinant is preserved under “column replace- ment” (column operation of third type). Proof. Fix a vector vk, and let u be a linear combination of the other vectors, u = ∑ j̸=k αjvj. Then by linearity D(v1, . . . , vk + u | {z } k , . . . , vn) = D(v1, . . . , vk k , . . . , vn) + D(v1, . . . , u k , . . . , vn), 3. Constructing the determinant. 81 and by Proposition 3.1 the last term is zero. □ 3.3. Determinants of diagonal and triangular matrices. Now we are ready to compute determinant for some important special classes of matrices. The ﬁrst class is the so-called diagonal matrices. Let us recall that a square matrix A = {aj,k}n j,j=1 is called diagonal if all entries oﬀ the main diagonal are zero, i.e. if aj,k = 0 for all j ̸= k. We will often use the notation diag{a1, a2, . . . , an} for the diagonal matrix      a1 0 . . . 0 0 a2 . . . 0 ... ... . . . 0 0 0 . . . an  | | |  . Since a diagonal matrix diag{a1, a2, . . . , an} can be obtained from the identity matrix I by multiplying column number k by ak, Determinant of a diagonal matrix equal the product of the diago- nal entries, det(diag{a1, a2, . . . , an}) = a1a2 . . . an. The next important class is the class of so-called triangular matrices. A square matrix A = {aj,k}n j,j=1 is called upper triangular if all entries below the main diagonal are 0, i.e. if aj,k = 0 for all k < j. A square matrix is called lower triangular if all entries above the main are 0, i.e if aj,k = 0 for all j < k. We call a matrix triangular, if it is either lower or upper triangular matrix. It is easy to see that Determinant of a triangular matrix equals to the product of the diagonal entries, det A = a1,1a2,2 . . . an,n. Indeed, if a triangular matrix has zero on the main diagonal, it is not invertible (this can easily be checked by column operations) and therefore both sides equal zero. If all diagonal entries are non-zero, then using column replacement (column operations of third type) one can transform the matrix into a diagonal one with the same diagonal entries: For upper triangular matrix one should ﬁrst subtract appropriate multiples of the ﬁrst column from the columns number 2, 3, . . . , n, “killing” all entries in the ﬁrst row, then subtract appropriate multiples of the second column from columns number 3, . . . , n, and so on. 82 3. Determinants To treat the case of lower triangular matrices one has to do “column reduction” from the left to the right, i.e. ﬁrst subtract appropriate multiples of the last column from columns number n − 1, . . . , 2, 1, and so on. 3.4. Computing the determinant. Now we know how to compute de- terminants, using their properties: one just needs to do column reduction (i.e. row reduction for AT ) keeping track of column operations changing the determinant. Fortunately, the most often used operation—row replace- ment, i.e. operation of third type does not change the determinant. So we only need to keep track of interchanging of columns and of multiplication of column by a scalar. If an echelon form of AT does not have pivots in every column (and row), then A is not invertible, so det A = 0. If A is invertible, we arrive at a triangular matrix, and det A is the product of diagonal entries times the correction from column interchanges and multiplications. The above algorithm implies that det A can be zero only if a matrix A is not invertible. Combining this with the last statement of Proposition 3.1 we get Proposition 3.3. det A = 0 if and only if A is not invertible. An equivalent statement: det A ̸= 0 if and only if A is invertible. Note, that although we now know how to compute determinants, the determinant is still not deﬁned. One can ask: why don’t we deﬁne it as the result we get from the above algorithm? The problem is that formally this result is not well deﬁned: that means we did not prove that diﬀerent sequences of column operations yield the same answer. 3.5. Determinants of a transpose and of a product. Determinants of elementary matrices. In this section we prove two important theorems. Theorem 3.4 (Determinant of a transpose). For a square matrix A, det A = det(AT ). This theorem implies that for all statement about columns we discussed above, the corresponding statements about rows are also true. In particular, determinants behave under row operations the same way they behave under column operations. So, we can use row operations to compute determinants. Theorem 3.5 (Determinant of a product). For n × n matrices A and B det(AB) = (det A)(det B) In other words Determinant of a product equals product of determinants. 3. Constructing the determinant. 83 To prove both theorems we need the following lemma. Lemma 3.6. For a square matrix A and an elementary matrix E (of the same size) det(AE) = (det A)(det E) Proof. The proof can be done just by direct checking: determinants of special matrices are easy to compute; right multiplication by an elemen- tary matrix is a column operation, and eﬀect of column operations on the determinant is well known. This can look like a lucky coincidence, that the determinants of elemen- tary matrices agree with the corresponding column operations, but it is not a coincidence at all. Namely, for a column operation the corresponding elementary matrix can be obtained from the identity matrix I by this column operation. So, its determinant is 1 (determinant of I) times the eﬀect of the column operation. And that is all! It may be hard to realize at ﬁrst, but the above para- graph is a complete and rigorous proof of the lemma! □ Applying N times Lemma 3.6 we get the following corollary. Corollary 3.7. For any matrix A and any sequence of elementary matrices E1, E2, . . . , EN (all matrices are n × n) det(AE1E2 . . . EN ) = (det A)(det E1)(det E2) . . . (det EN ) Lemma 3.8. Any invertible matrix is a product of elementary matrices. Proof. We know that any invertible matrix is row equivalent to the identity matrix, which is its reduced echelon form. So I = EN EN −1 . . . E2E1A, and therefore any invertible matrix can be represented as a product of ele- mentary matrices, A = E−1 1 E−1 2 . . . E−1 N −1E−1 N I = E−1 1 E−1 2 . . . E−1 N −1E−1 N (the inverse of an elementary matrix is an elementary matrix). □ Proof of Theorem 3.4. First of all, it can be easily checked, that for an elementary matrix E we have det E = det(ET ). Notice, that it is suﬃcient to prove the theorem only for invertible matrices A, since if A is not invertible then AT is also not invertible, and both determinants are zero. By Lemma 3.8 matrix A can be represented as a product of elementary matrices, A = E1E2 . . . EN , 84 3. Determinants and by Corollary 3.7 the determinant of A is the product of determinants of the elementary matrices. Since taking the transpose just transposes each elementary matrix and reverses their order, Corollary 3.7 implies that det A = det AT . □ Proof of Theorem 3.5. Let us ﬁrst suppose that the matrix B is invert- ible. Then Lemma 3.8 implies that B can be represented as a product of elementary matrices B = E1E2 . . . EN , and so by Corollary 3.7 det(AB) = (det A)[(det E1)(det E2) . . . (det EN )] = (det A)(det B). If B is not invertible, then the product AB is also not invertible, and the theorem just says that 0 = 0. To check that the product AB = C is not invertible, let us assume that it is invertible. Then multiplying the identity AB = C by C−1 from the left, we get C−1AB = I, so C−1A is a left inverse of B. So B is left invertible, and since it is square, it is invertible. We got a contradiction. □ 3.6. Summary of properties of determinant. First of all, let us say once more, that the determinant is deﬁned only for square matrices! Since we now know that det A = det(AT ), the statements that we knew about columns are true for rows too. 1. Determinant is linear in each row (column) when the other rows (columns) are ﬁxed. 2. If one interchanges two rows (columns) of a matrix A, the determi- nant changes sign. 3. For a triangular (in particular, for a diagonal) matrix its determinant is the product of the diagonal entries. In particular, det I = 1. 4. If a matrix A has a zero row (or column), det A = 0. 5. If a matrix A has two equal rows (columns), det A = 0. 6. If one of the rows (columns) of A is a linear combination of the other rows (columns), i.e. if the matrix is not invertible, then det A = 0; More generally, 7. det A = 0 if and only if A is not invertible, or equivalently 8. det A ̸= 0 if and only if A is invertible. 9. det A does not change if we add to a row (column) a linear combi- nation of the other rows (columns). In particular, the determinant is preserved under the row (column) replacement, i.e. under the row (column) operation of the third kind. 3. Constructing the determinant. 85 10. det AT = det A. 11. det(AB) = (det A)(det B). And ﬁnally, 12. If A is an n × n matrix, then det(aA) = an det A. The last property follows from the linearity of the determinant, if we recall that to multiply a matrix A by a we have to multiply each row by a, and that each multiplication multiplies the determinant by a. Exercises. 3.1. If A is an n × n matrix, how are the determinants det A and det(5A) related? Remark: det(5A) = 5 det A only in the trivial case of 1 × 1 matrices 3.2. How are the determinants det A and det B related if a) A =   a1 a2 a3 b1 b2 b3 c1 c2 c3   , B =   2a1 3a2 5a3 2b1 3b2 5b3 2c1 3c2 5c3   ; b) A =   a1 a2 a3 b1 b2 b3 c1 c2 c3   , B =   3a1 4a2 + 5a1 5a3 3b1 4b2 + 5b1 5b3 3c1 4c2 + 5c1 5c3   . 3.3. Using column or row operations compute the determinants \f \f \f \f \f \f 0 1 2 −1 0 −3 2 3 0 \f \f \f \f \f \f , \f \f \f \f \f \f 1 2 3 4 5 6 7 8 9 \f \f \f \f \f \f , \f \f \f \f \f \f \f \f 1 0 −2 3 −3 1 1 2 0 4 −1 1 2 3 0 1 \f \f \f \f \f \f \f \f , \f \f \f \f 1 x 1 y \f \f \f \f . 3.4. A square (n × n) matrix is called skew-symmetric (or antisymmetric) if AT = −A. Prove that if A is skew-symmetric and n is odd, then det A = 0. Is this true for even n? 3.5. A square matrix is called nilpotent if Ak = 0 for some positive integer k. Show that for a nilpotent matrix A det A = 0. 3.6. Prove that if the matrices A and B are similar, than det A = det B. 3.7. A real square matrix Q is called orthogonal if Q T Q = I. Prove that if Q is an orthogonal matrix then det Q = ±1. 3.8. Show that \f \f \f \f \f \f 1 x x2 1 y y2 1 z z2 \f \f \f \f \f \f = (z − x)(z − y)(y − x). This is a particular case of the so-called Vandermonde determinant. 86 3. Determinants 3.9. Let points A, B and C in the plane R2 have coordinates (x1, y1), (x2, y2) and (x3, y3) respectively. Show that the area of triangle ABC is the absolute value of 1 2 \f \f \f \f \f \f 1 x1 y1 1 x2 y2 1 x3 y3 \f \f \f \f \f \f . Hint: use row operations and geometric interpretation of 2×2 determinants (area). 3.10. Let A be a square matrix. Show that block triangular matrices ( I ∗ 0 A ) , ( A ∗ 0 I ) , ( I 0 ∗ A ) , ( A 0 ∗ I ) all have determinant equal to det A. Here ∗ can be anything. The following problems illustrate the power of block matrix notation. 3.11. Use the previous problem to show that if A and C are square matrices, then det ( A B 0 C ) = det A det C. Hint: ( A B 0 C ) = ( I B 0 C ) ( A 0 0 I ) . 3.12. Let A be m × n and B be n × m matrices. Prove that det ( 0 A −B I ) = det(AB). Hint: While it is possible to transform the matrix by row operations to a form where the determinant is easy to compute, the easiest way is to right multiply the matrix by ( I 0 B I ). 4. Formal deﬁnition. Existence and uniqueness of the determinant. In this section we arrive to the formal deﬁnition of the determinant. We show that a function, satisfying the basic properties 1, 2, 3 from Section 3 exists, and moreover, such function is unique, i.e. we do not have any choice in constructing the determinant. Consider an n × n matrix A = {aj,k}n j,k=1, and let v1, v2, . . . , vn be its columns, i.e. vk =      a1,k a2,k ... an,k  | | |  = a1,ke1 + a2,ke2 + . . . + an,ken = n∑ j=1 aj,kej. 4. Formal deﬁnition. Existence and uniqueness of the determinant. 87 Using linearity of the determinant we expand it in the ﬁrst column v1: (4.1) D(v1, v2, . . . , vn) = D( n∑ j=1 aj,1ej, v2, . . . , vn) = n∑ j=1 aj,1D(ej, v2, . . . , vn). Then we expand it in the second column, then in the third, and so on. We get D(v1, v2, . . . , vn) = n∑ j1=1 n∑ j2=1 . . . n∑ jn=1 aj1,1aj2,2 . . . ajn,nD(ej1.ej2, . . . ejn). Notice, that we have to use a diﬀerent index of summation for each column: we call them j1, j2, . . . , jn; the index j1 here is the same as the index j in (4.1). It is a huge sum, it contains nn terms. Fortunately, some of the terms are zero. Namely, if any 2 of the indices j1, j2, . . . , jn coincide, the determinant D(ej1.ej2, . . . ejn) is zero, because there are two equal columns here. So, let us rewrite the sum, omitting all zero terms. The most convenient way to do that is using the notion of a permutation. Informally, a per- mutation of an ordered set {1, 2, . . . , n} is a rearrangement of its elements. A convenient formal way to represent such a rearrangement is by using a function σ : {1, 2, . . . , n} → {1, 2, . . . , n}, where σ(1), σ(2), . . . , σ(n) gives the new order of the set 1, 2, . . . , n. In other words, the permutation σ rearranges the ordered set 1, 2, . . . , n into σ(1), σ(2), . . . , σ(n). Such function σ has to be one-to-one (diﬀerent values for diﬀerent ar- guments) and onto (assumes all possible values from the target space). The functions which are one-to-one and onto are called bijections, and they give one-to-one correspondence between the domain and the target space. 1 Although it is not directly relevant here, let us notice, that it is well- known in combinatorics, that the number of diﬀerent permutations of the set {1, 2, . . . , n} is exactly n!. The set of all permutations of the set {1, 2, . . . , n} will be denoted Perm(n). 1 There is another canonical way to represent permutation by a bijection σ, namely in this representation σ(k) gives new position of the element number k. In this representation σ rearranges σ(1), σ(2), . . . , σ(n) into 1, 2, . . . , n. While in the ﬁrst representation it is easy to write the function if you know the rearrangement of the set 1, 2, . . . , n, the second one is more adapted to the composition of permutations: it coincides with the composition of functions. Namely if we ﬁrst perform the permutation that correspond to a function σ and then one that correspond to τ , the resulting permutation will correspond to τ ◦ σ. 88 3. Determinants Using the notion of a permutation, we can rewrite the determinant as D(v1, v2, . . . , vn) = ∑ σ∈Perm(n) aσ(1),1aσ(2),2 . . . aσ(n),nD(eσ(1), eσ(2), . . . , eσ(n)). The matrix with columns eσ(1), eσ(2), . . . , eσ(n) can be obtained from the identity matrix by ﬁnitely many column interchanges, so the determinant D(eσ(1), eσ(2), . . . , eσ(n)) is 1 or −1 depending on the number of column interchanges. To formalize that, we (informally) deﬁne the sign (denoted sign σ) of a permutation σ to be 1 if an even number of interchanges is necessary to rearrange the n-tuple 1, 2, . . . , n into σ(1), σ(2), . . . , σ(n), and sign(σ) = −1 if the number of interchanges is odd. It is a well-known fact from the combinatorics, that the sign of permuta- tion is well deﬁned, i.e. that although there are inﬁnitely many ways to get the n-tuple σ(1), σ(2), . . . , σ(n) from 1, 2, . . . , n, the number of interchanges is either always odd or always even. One of the ways to show that is to introduce an alternative deﬁnition. Let K = K(σ) be the number of disorders of σ, i.e. the number of pairs (j, k), j, k ∈ {1, 2, . . . , n}, j < k such that σ(j) > σ(k), and see if the number is even or odd. We call the permutation σ odd if K is odd and even if K is even. Then deﬁne sign σ := (−1)K(σ); note that this way sign σ is well deﬁned. We want to show that sign σ = (−1)K(σ) can indeed be computed by rearranging the n-tuple 1, 2, . . . , n into σ(1), σ(2), . . . , σ(n) and counting the number of interchanges, as was described above. If σ(k) = k ∀k, then the number of disorders K(σ) is 0, so sign of such identity permutation is 1. Note also, that any elementary transpose, which interchange two neighbors, changes the sign of a permutation, because it changes (increases or decreases) the number of disorders exactly by 1. So, to get from a permutation to another one always needs an even number of elementary transposes if the permutations have the same sign, and an odd number if the signs are diﬀerent. Finally, any interchange of two entries can be achieved by an odd num- ber of elementary transposes. This implies that sign changes under an in- terchange of two entries. So, to get from 1, 2, . . . , n to an even permutation (positive sign) one always need even number of interchanges, and odd num- ber of interchanges is needed to get an odd permutation (negative sign). 4. Formal deﬁnition. Existence and uniqueness of the determinant. 89 So, if we want determinant to satisfy basic properties 1–3 from Section 3, we must deﬁne it as (4.2) det A = ∑ σ∈Perm(n) aσ(1),1aσ(2),2 . . . aσ(n),n sign(σ), where the sum is taken over all permutations of the set {1, 2, . . . , n}. If we deﬁne the determinant this way, it is easy to check that it satisﬁes the basic properties 1–3 from Section 3. Indeed, it is linear in each column, because for each column every term (product) in the sum contains exactly one entry from this column. Interchanging two columns of A just adds an extra interchange to the permutation, so right side in (4.2) changes sign. Finally, for the identity matrix I, the right side of (4.2) is 1 (it has one non-zero term). Exercises. 4.1. Suppose the permutation σ takes (1, 2, 3, 4, 5) to (5, 4, 1, 2, 3). a) Find sign of σ; b) What does σ2 := σ ◦ σ do to (1, 2, 3, 4, 5)? c) What does the inverse permutation σ−1 do to (1, 2, 3, 4, 5)? d) What is the sign of σ−1? 4.2. Let P be a permutation matrix, i.e. an n × n matrix consisting of zeroes and ones and such that there is exactly one 1 in every row and every column. a) Can you describe the corresponding linear transformation? That will ex- plain the name. b) Show that P is invertible. Can you describe P −1? c) Show that for some N > 0 P N := P P . . . P| {z } N times = I. Use the fact that there are only ﬁnitely many permutations. 4.3. Why is there an even number of permutations of (1, 2, . . . , 9) and why are exactly half of them odd permutations? Hint: This problem can be hard to solve in terms of permutations, but there is a very simple solution using determinants. 4.4. If σ is an odd permutation, explain why σ2 is even but σ−1 is odd. 4.5. How many multiplications and additions is required to compute the determi- nant using formal deﬁnition (4.2) of the determinant of an n × n matrix? Do not count the operations needed to compute sign σ. 90 3. Determinants 5. Cofactor expansion. For an n × n matrix A = {aj,k}n j,k=1 let Aj,k denotes the (n − 1) × (n − 1) matrix obtained from A by crossing out row number j and column number k. Theorem 5.1 (Cofactor expansion of determinant). Let A be an n × n matrix. For each j, 1 ≤ j ≤ n, determinant of A can be expanded in the row number j as det A = aj,1(−1) j+1 det Aj,1 + aj,2(−1) j+2 det Aj,2 + . . . + aj,n(−1) j+n det Aj,n = n∑ k=1 aj,k(−1) j+k det Aj,k. Similarly, for each k, 1 ≤ k ≤ n, the determinant can be expanded in the column number k, det A = n∑ j=1 aj,k(−1) j+k det Aj,k. Proof. Let us ﬁrst prove the formula for the expansion in row number 1. The formula for expansion in row number 2 then can be obtained from it by interchanging rows number 1 and 2. Interchanging then rows number 2 and 3 we get the formula for the expansion in row number 3, and so on. Since det A = det AT , column expansion follows automatically. Let us ﬁrst consider a special case, when the ﬁrst row has one non- zero term a1,1. Performing column operations on columns 2, 3, . . . , n we transform A to the lower triangular form. The determinant of A then can be computed as the product of diagonal entries of the triangular matrix × correcting factor from the column operations . But the product of all diagonal entries except the ﬁrst one (i.e. without a1,1) times the correcting factor is exactly det A1,1, so in this particular case det A = a1,1 det A1,1. Let us now consider the case when all entries in the ﬁrst row except a1,2 are zeroes. This case can be reduced to the previous one by interchanging columns number 1 and 2, and therefore in this case det A = (−1)a1,2 det A1,2. The case when a1,3 is the only non-zero entry in the ﬁrst row, can be reduced to the previous one by interchanging rows 2 and 3, so in this case det A = a1,3 det A1,3. 5. Cofactor expansion. 91 Repeating this procedure we get that in the case when a1,k is the only non-zero entry in the ﬁrst row det A = (−1)1+ka1,k det A1,k. 2 In the general case, linearity of the determinant in each row implies that det A = det A (1) + det A(2) + . . . + det A(n) = n∑ k=1 det A(k) where the matrix A(k) is obtained from A by replacing all entries in the ﬁrst row except a1,k by 0. As we just discussed above det A(k) = (−1) 1+ka1,k det A1,k, so det A = n∑ k=1(−1) 1+ka1,k det A1,k. To get the cofactor expansion in the second row, we can interchange the ﬁrst and second rows and apply the above formula. The row exchange changes the sign, so we get det A = − n∑ k=1(−1) 1+ka2,k det A2,k = n∑ k=1(−1) 2+ka2,k det A2,k. Exchanging rows 3 and 2 and expanding in the second row we get formula det A = n∑ k=1(−1) 3+ka3,k det A3,k, and so on. To expand the determinant det A in a column one need to apply the row expansion formula for AT . □ Deﬁnition. The numbers Cj,k = (−1) j+k det Aj,k are called cofactors. 2In the case when a1,k is the only non-zero entry in the ﬁrst row it may be tempting to exchange columns number 1 and number k, to reduce the problem to the case a1,1 ̸= 0. However, when we exchange columns 1 and k we change the order of other columns: if we just cross out column number k, then column number 1 will be the ﬁrst of the remaining columns. But, if we exchange columns 1 and k, and then cross out column k (which is now the ﬁrst one), then the column 1 will be now column number k − 1. To avoid the complications of keeping track of the order of columns, we can, as we did above, exchange columns number k and k − 1, reducing everything to the situation we treated on the previous step. Such an operation does not change the order for the rest of the columns. 92 3. Determinants Using this notation, the formula for expansion of the determinant in the row number j can be rewritten as det A = aj,1Cj,1 + aj,2Cj,2 + . . . + aj,nCj,n = n∑ k=1 aj,kCj,k. Similarly, expansion in the column number k can be written as det A = a1,kC1,k + a2,kC2,k + . . . + an,kCn,k = n∑ j=1 aj,kCj,k Remark. Very often the cofactor expansion formula is used as the deﬁnitionVery often the cofactor expansion formula is used as the deﬁnition of determinant. of determinant. It is not diﬃcult to show that the quantity given by this formula satisﬁes the basic properties of the determinant: the normalization property is trivial, the proof of antisymmetry is easy. However, the proof of linearity is a bit tedious (although not too diﬃcult). Remark. Although it looks very nice, the cofactor expansion formula is not suitable for computing determinant of matrices bigger than 3 × 3. As one can count it requires more than n! multiplications (to be precise it requires ∑n k=2 n!/k! multiplications), and n! grows very rapidly. For exam- ple, cofactor expansion of a 20 × 20 matrix require more than 20! ≈ 2.4 · 1018 multiplications. It would take a computer performing a billion multiplica- tions per second over 77 years to perform 20! multiplications; performing the multiplications required for the cofactor expansion of the determinant of a 20 × 20 matrix will require more than 132 years.3 On the other hand, computing the determinant of an n × n matrix using row reduction requires (n3 + 2n − 3)/3 multiplications (and about the same number of additions). It would take a computer performing a million oper- ations per second (very slow, by today’s standards) a fraction of a second to compute the determinant of a 100 × 100 matrix by row reduction. It can only be practical to apply the cofactor expansion formula in higher dimensions if a row (or a column) has a lot of zero entries. However, the cofactor expansion formula is of great theoretical impor- tance, as the next section shows. 5.1. Cofactor formula for the inverse matrix. The matrix C = {Cj,k}n j,k=1 whose entries are cofactors of a given matrix A is called the cofactor matrix of A. Theorem 5.2. Let A be an invertible matrix and let C be its cofactor matrix. Then A−1 = 1 det A CT . 3The reader can check the numbers sung, for example, WolframAlpha 5. Cofactor expansion. 93 Proof. Let us ﬁnd the product ACT . The diagonal entry number j is obtained by multiplying jth row of A by jth column of A (i.e. jth row of C), so (ACT )j,j = aj,1Cj,1 + aj,2Cj,2 + . . . + aj,nCj,n = det A, by the cofactor expansion formula. To get the oﬀ diagonal terms we need to multiply kth row of A by jth column of CT , j ̸= k, to get ak,1Cj,1 + ak,2Cj,2 + . . . + ak,nCj,n. It follows from the cofactor expansions formula (expanding in jth row) that this is the determinant of the matrix obtained from A by replacing row number j by the row number k (and leaving all other rows as they were). But the rows j and k of this matrix coincide, so the determinant is 0. So, all oﬀ-diagonal entries of ACT are zeroes (and all diagonal ones equal det A), thus ACT = (det A) I. That means that the matrix 1 det A CT is a right inverse of A, and since A is square, it is the inverse. □ Recalling that for an invertible matrix A the equation Ax = b has a unique solution x = A−1b = 1 det A CT b, we get the following corollary of the above theorem. Corollary 5.3 (Cramer’s rule). For an invertible matrix A the entry number k of the solution of the equation Ax = b is given by the formula xk = det Bk det A , where the matrix Bk is obtained from A by replacing column number k of A by the vector b. 5.2. Some applications of the cofactor formula for the inverse. Example (Inverting 2 × 2 matrices). The cofactor formula really shines when one needs to invert a 2 × 2 matrix A = ( a b c d ) . The cofactors are just entries (1 × 1 matrices), the cofactor matrix is ( d −c −b a ) , 94 3. Determinants so the inverse matrix A−1 is given by the formula A−1 = 1 det A ( d −b −c a ) . While the cofactor formula for the inverse does not look practical for dimensions higher than 3, it has a great theoretical value, as the examples below illustrate. Example (Matrix with integer inverse). Suppose that we want to construct a matrix A with integer entries, such that its inverse also has integer entries (inverting such a matrix would make a nice homework problem: no messing with fractions). If det A = 1 and its entries are integer, the cofactor formula for inverses implies that A−1 also have integer entries. Note, that it is easy to construct an integer matrix A with det A = 1: one should start with a triangular matrix with 1 on the main diagonal, and then apply several row or column replacements (operations of the third type) to make the matrix look generic. Example (Inverse of a polynomial matrix). Another example is to consider a polynomial matrix A(x), i.e. a matrix whose entries are not numbers but polynomials aj,k(x) of the variable x. If det A(x) ≡ 1, then the inverse matrix A−1(x) is also a polynomial matrix. If det A(x) = p(x) ̸≡ 0, it follows from the cofactor expansion that p(x) is a polynomial, so A−1(x) has rational entries: moreover, p(x) is a multiple of each denominator. Exercises. 5.1. Evaluate the determinants using any method \f \f \f \f \f \f 0 1 1 1 2 −5 6 −4 3 \f \f \f \f \f \f , \f \f \f \f \f \f \f \f 1 −2 3 −12 −5 12 −14 19 −9 22 −20 31 −4 9 −14 15 \f \f \f \f \f \f \f \f . 5.2. Use row (column) expansion to evaluate the determinants. Note, that you don’t need to use the ﬁrst row (column): picking row (column) with many zeroes will simplify your calculations. \f \f \f \f \f \f 1 2 0 1 1 5 1 −3 0 \f \f \f \f \f \f , \f \f \f \f \f \f \f \f 4 −6 −4 4 2 1 0 0 0 −3 1 3 −2 2 −3 −5 \f \f \f \f \f \f \f \f . 5. Cofactor expansion. 95 5.3. For the n × n matrix A =          0 0 0 . . . 0 a0 −1 0 0 . . . 0 a1 0 −1 0 . . . 0 a2 ... ... ... . . . ... ... 0 0 0 . . . 0 an−2 0 0 0 . . . −1 an−1  | | | | | | |  compute det(A + tI), where I is n × n identity matrix. You should get a nice ex- pression involving a0, a1, . . . , an−1 and t. Row expansion and induction is probably the best way to go. 5.4. Using cofactor formula compute inverses of the matrices ( 1 2 3 4 ) , ( 19 −17 3 −2 ) , ( 1 0 3 5 ) ,   1 1 0 2 1 2 0 1 1   . 5.5. Let Dn be the determinant of the n × n tridiagonal matrix         1 −1 0 1 1 −1 1 . . . . . . . . . 1 −1 0 1 1  | | | | | |  . Using cofactor expansion show that Dn = Dn−1 + Dn−2. This yields that the sequence Dn is the Fibonacci sequence 1, 2, 3, 5, 8, 13, 21, . . . 5.6. Vandermonde determinant revisited. Our goal is to prove the formula \f \f \f \f \f \f \f \f \f 1 c0 c 2 0 . . . cn 0 1 c1 c 2 1 . . . cn 1 ... ... ... ... 1 cn c 2 n . . . cn n \f \f \f \f \f \f \f \f \f = ∏ 0≤j<k≤n(ck − cj) for the (n + 1) × (n + 1) Vandermonde determinant. We will apply induction. To do this a) Check that the formula holds for n = 1, n = 2. b) Call the variable cn in the last row x, and show that the determinant is a polynomial of degree n, A0 + A1x + A2x2 + . . . + Anxn, with the coeﬃcients Ak depending on c0, c1, . . . , cn−1. c) Show that the polynomial has zeroes at x = c0, c1, . . . , cn−1, so it can be represented as An · (x − c0)(x − c1) . . . (x − cn−1), where An as above. d) Assuming that the formula for the Vandermonde determinant is true for n − 1, compute An and prove the formula for n. 5.7. How many multiplication is needed to compute the determinant of an n × n matrix using the cofactor expansion? Prove the formula. 96 3. Determinants 6. Minors and rank. For a matrix A let us consider its k × k submatrix, obtained by taking k rows and k columns. The determinant of this matrix is called a minor of order k. Note, that an m × n matrix has (m k ) · (n k) diﬀerent k × k submatrices, and so it has (m k ) · (n k) minors of order k. Theorem 6.1. For a non-zero matrix A its rank equals to the maximal integer k such that there exists a non-zero minor of order k. Proof. Let us ﬁrst show, that if k > rank A then all minors of order k are 0. Indeed, since the dimension of the column space Ran A is rank A < k, any k columns of A are linearly dependent. Therefore, for any k × k submatrix of A its columns are linearly dependent, and so all minors of order k are 0. To complete the proof we need to show that there exists a non-zero minor of order k = rank A. There can be many such minors, but probably the easiest way to get such a minor is to take pivot rows and pivot columns (i.e. rows and columns of the original matrix, containing a pivot). This k × k submatrix has the same pivots as the original matrix, so it is invertible (pivot in every column and every row) and its determinant is non-zero. □ This theorem does not look very useful, because it is much easier to perform row reduction than to compute all minors. However, it is of great theoretical importance, as the following corollary shows. Corollary 6.2. Let A = A(x) be an m × n polynomial matrix (i.e. a matrix whose entries are polynomials of x). Then rank A(x) is constant everywhere, except maybe ﬁnitely many points, where the rank is smaller. Proof. Let r be the largest integer such that rank A(x) = r for some x. To show that such r exists, we ﬁrst try r = min{m, n}. If there exists x such that rank A(x) = r, we have found r. If not, we replace r by r − 1 and try again. After ﬁnitely many steps we either stop or hit 0. So, r exists. Let x0 be a point such that rank A(x0) = r, and let M be a minor of order k such that M (x0) ̸= 0. Since M (x) is the determinant of a k ×k polynomial matrix, M (x) is a polynomial. Since M (x0) ̸= 0, it is not identically zero, so it can be zero only at ﬁnitely many points. So, everywhere except maybe ﬁnitely many points rank A(x) ≥ r. But by the deﬁnition of r, rank A(x) ≤ r for all x. □ 7. Review exercises for Chapter 3. 7.1. True or false 7. Review exercises for Chapter 3. 97 a) Determinant is only deﬁned for square matrices. b) If two rows or columns of A are identical, then det A = 0. c) If B is the matrix obtained from A by interchanging two rows (or columns), then det B = det A. d) If B is the matrix obtained from A by multiplying a row (column) of A by a scalar α, then det B = det A. e) If B is the matrix obtained from A by adding a multiple of a row to some other row, then det B = det A. f) The determinant of a triangular matrix is the product of its diagonal en- tries. g) det(AT ) = − det(A). h) det(AB) = det(A) det(B). i) A matrix A is invertible if and only if det A ̸= 0. j) If A is an invertible matrix, then det(A−1) = 1/ det(A). 7.2. Let A be an n × n matrix. How are det(3A), det(−A) and det(A2) related to det A. 7.3. If the entries of both A and A−1 are integers, is it possible that det A = 3? Hint: what is det(A) det(A−1)? 7.4. Let v1, v2 be vectors in R2 and let A be the 2 × 2 matrix with columns v1, v2. Prove that | det A| is the area of the parallelogram with two sides given by the vectors v1, v2. Consider ﬁrst the case when v1 = (x1, 0)T . To treat general case v1 = (x1, y1) T left multiply A by a rotation matrix that transforms vector v1 into (̃x1, 0)T . Hint: what is the determinant of a rotation matrix? The following problem illustrates relation between the sign of the determinant and the so-called orientation of a system of vectors. 7.5. Let v1, v2 be vectors in R2. Show that D(v1, v2) > 0 if and only if there exists a rotation Tα such that the vector Tαv1 is parallel to e1 (and looking in the same direction), and Tαv2 is in the upper half-plane x2 > 0 (the same half-plane as e2). Hint: What is the determinant of a rotation matrix? Chapter 4 Introduction to spectral theory (eigenvalues and eigenvectors) Spectral theory is the main tool that helps us to understand the structure of a linear operator. In this chapter we consider only operators acting from a vector space to itself (or, equivalently, n × n matrices). If we have such a linear transformation A : V → V , we can multiply it by itself, take any power of it, or any polynomial. The main idea of spectral theory is to split the operator into simple blocks and analyze each block separately. To explain the main idea, let us consider diﬀerence equations. Many processes can be described by the equations of the following type xn+1 = Axn, n = 0, 1, 2, . . . , where A : V → V is a linear transformation, and xn is the state of the system at the time n. Given the initial state x0 we would like to know the state xn at the time n, analyze the long time behavior of xn, etc. 1 1The diﬀerence equations are discrete time analogues of the diﬀerential equation x′(t) = Ax(t). To solve the diﬀerential equation, one needs to compute etA := ∑∞ k=0 tkAn/k!, and spectral theory also helps in doing this. 99 100 4. Introduction to spectral theory At the ﬁrst glance the problem looks trivial: the solution xn is given by the formula xn = Anx0. But what if n is huge: thousands, millions? Or what if we want to analyze the behavior of xn as n → ∞? Here the idea of eigenvalues and eigenvectors comes in. Suppose that Ax0 = λx0, where λ is some scalar. Then A2x0 = λ2x0, A3x0 = λ3x0, . . . , Anx0 = λnx0, so the behavior of the solution is very well understood In this section we will consider only operators in ﬁnite-dimensional spac- es. Spectral theory in inﬁnitely many dimensions is signiﬁcantly more com- plicated, and most of the results presented here fail in inﬁnite-dimensional setting. 1. Main deﬁnitions 1.1. Eigenvalues, eigenvectors, spectrum. A scalar λ is called an eigenvalue of an operator A : V → V if there exists a non-zero vector v ∈ V such that Av = λv. The vector v is called the eigenvector of A (corresponding to the eigenvalue λ). If we know that λ is an eigenvalue, the eigenvectors are easy to ﬁnd: one just has to solve the equation Ax = λx, or, equivalently (A − λI)x = 0. So, ﬁnding all eigenvectors, corresponding to an eigenvalue λ is simply ﬁnd- ing the nullspace of A − λI. The nullspace Ker(A − λI), i.e. the set of all eigenvectors and 0 vector, is called the eigenspace. The set of all eigenvalues of an operator A is called spectrum of A, and is usually denoted σ(A). 1.2. Finding eigenvalues: characteristic polynomials. A scalar λ is an eigenvalue if and only if the nullspace Ker(A − λI) is non-trivial (so the equation (A − λI)x = 0 has a non-trivial solution). Let A act on Fn (i.e. A : Fn → Fn). Since the matrix of A is square, A − λI has a non-trivial nullspace if and only if it is not invertible. We know that a square matrix is not invertible if and only if its determinant is 0. Therefore λ ∈ σ(A), i.e. λ is an eigenvalue of A ⇐⇒ det(A − λI) = 0 If A is an n × n matrix, the determinant det(A − λI) is a polynomial of degree n of the variable λ. This polynomial is called the characteristic polynomial of A. So, to ﬁnd all eigenvalues of A one just needs to compute the characteristic polynomial and ﬁnd all its roots. 1. Main deﬁnitions 101 This method of ﬁnding the spectrum of an operator is not very practical in higher dimensions. Finding roots of a polynomial of high degree can be a very diﬃcult problem, and it is impossible to solve the equation of degree higher than 4 in radicals. So, in higher dimensions diﬀerent numerical methods of ﬁnding eigenvalues and eigenvectors are used. 1.3. Finding characteristic polynomial and eigenvalues of an ab- stract operator. So we know how to ﬁnd the spectrum of a matrix. But how do we ﬁnd eigenvalues of an operator acting in an abstract vector space? The recipe is simple: Take an arbitrary basis, and compute eigenvalues of the matrix of the operator in this basis. But how do we know that the result does not depend on a choice of the basis? There can be several possible explanations. One is based on the notion of similar matrices. Let us recall that square matrices A and B are called similar if there exist an invertible matrix S such that A = SBS−1. Note, that determinants of similar matrices coincide. Indeed det A = det(SBS−1) = det S det B det S−1 = det B because det S−1 = 1/ det S. Note that if A = SBS−1 then A − λI = SBS−1 − λSIS−1 = S(BS−1 − λIS−1) = S(B − λI)S−1, so the matrices A − λI and B − λI are similar. Therefore det(A − λI) = det(B − λI), i.e. characteristic polynomials of similar matrices coincide. If T : V → V is a linear transformation, and A and B are two bases in V , then [T ] AA = [I] AB [T ] BB [I]BA and since [I] BA = ([I] AB )−1 the matrices [T ]AA and [T ]BB are similar. In other words, matrices of a linear transformation in diﬀerent bases are similar. Therefore, we can deﬁne the characteristic polynomial of an operator as the characteristic polynomial of its matrix in some basis. As we have discussed above, the result does not depend on the choice of the basis, so characteristic polynomial of an operator is well deﬁned. 102 4. Introduction to spectral theory 1.4. Complex vs real spaces. The fundamental theorem of algebra as- serts that any polynomial (of degree at least 1) has a complex root. That implies that an operator in a ﬁnite-dimensional complex vector space has at least one eigenvalue, so its spectrum is non-empty. On the other hand it is easy to construct a linear transformation in a real vector space without real eigenvalues, the rotation Rα, α ̸= πn in R2 being one of examples. Since it is usually assumed that eigenvalues should belong to the ﬁeld of scalars (if an operator acts in a vector space over a ﬁeld F the eigenvalues should be in F), such operators have empty spectrum. Thus, the complex case (i.e. operators acting in complex vector spaces) seems to be the most natural setting for the spectral theory. Since R ⊂ C, we can always treat a real n × n matrix as an operator in Cn to allow complex eigenvalues. Treating real matrices as operators in Cn is typical in the spectral theory, and we will follow this agreement. Finding eigenvalues of a matrix (unless otherwise speciﬁed) will always mean ﬁnding all complex eigenvalues and not restricting oneself only to real ones. Note that an operator in an abstract real vector space also can be in- terpreted as an operator in a complex space. A na¨ıve approach would be to ﬁx a basis (recall that all spaces in this chapter are ﬁnite-dimensional), and then work with coordinates in this basis allowing complex coordinates: that will be essentially move from operators in Rn to operators Cn described above. This construction describes what is known as the complexiﬁcation of a real vector space, and the result does not depend on the choice of a basis. A “high brow” abstract construction of the complexiﬁcation, explaining why the result does not depend on the choice of a basis is described below in Section 8.2 of Chapter 5. 1.5. Multiplicities of eigenvalues. Let us remind the reader, that if p is a polynomial, and λ is its root (i.e. p(λ) = 0) then z − λ divides p(z), i.e. p can be represented as p(z) = (z − λ)q(z), where q is some polynomial. If q(λ) = 0, then q also can be divided by z − λ, so (z − λ)2 divides p and so on. The largest positive integer k such that (z − λ)k divides p(z) is called the multiplicity of the root λ. If λ is an eigenvalue of an operator (matrix) A, then it is a root of the characteristic polynomial p(z) = det(A − zI). The multiplicity of this root is called the (algebraic) multiplicity of the eigenvalue λ. Any polynomial p(z) = ∑n k=0 akzk of degree n has exactly n complex roots, counting multiplicity. The words counting multiplicities mean that if a root has multiplicity d we have to list (count) it d times. In other words, 1. Main deﬁnitions 103 p can be represented as p(z) = an(z − λ1)(z − λ2) . . . (z − λn). where λ1, λ2, . . . , λn are its complex roots, counting multiplicities. There is another notion of multiplicity of an eigenvalue: the dimension of the eigenspace Ker(A − λI) is called geometric multiplicity of the eigenvalue λ. Geometric multiplicity is not as widely used as algebraic multiplicity. So, when people say simply “multiplicity” they usually mean algebraic mul- tiplicity. Let us mention, that algebraic and geometric multiplicities of an eigen- value can diﬀer. Proposition 1.1. Geometric multiplicity of an eigenvalue cannot exceed its algebraic multiplicity. Proof. See Exercise 1.9 below. □ 1.6. Trace and determinant. Theorem 1.2. Let A be n×n matrix, and let λ1, λ2, . . . , λn be its (complex) eigenvalues (counting multiplicities). Then 1. trace A = λ1 + λ2 + . . . + λn. 2. det A = λ1λ2 . . . λn. Proof. See Exercises 1.10, 1.11 below. □ 1.7. Eigenvalues of a triangular matrix. Computing eigenvalues is equivalent to ﬁnding roots of a characteristic polynomial of a matrix (or using some numerical method), which can be quite time consuming. How- ever, there is one particular case, when we can just read eigenvalues oﬀ the matrix. Namely eigenvalues of a triangular matrix (counting multiplicities) are ex- actly the diagonal entries a1,1, a2,2, . . . , an,n By triangular here we mean either upper or lower triangular matrix. Since a diagonal matrix is a particular case of a triangular matrix (it is both upper and lower triangular the eigenvalues of a diagonal matrix are its diagonal entries The proof of the statement about triangular matrices is trivial: we need to subtract λ from the diagonal entries of A, and use the fact that deter- minant of a triangular matrix is the product of its diagonal entries. We get 104 4. Introduction to spectral theory the characteristic polynomial det(A − λI) = (a1,1 − λ)(a2,2 − λ) . . . (an,n − λ) and its roots are exactly a1,1, a2,2, . . . , an,n. Exercises. 1.1. True or false: a) Every linear operator in an n-dimensional vector space has n distinct eigen- values; b) If a matrix has one eigenvector, it has inﬁnitely many eigenvectors; c) There exists a square real matrix with no real eigenvalues; d) There exists a square matrix with no (complex) eigenvectors; e) Similar matrices always have the same eigenvalues; f) Similar matrices always have the same eigenvectors; g) A non-zero sum of two eigenvectors of a matrix A is always an eigenvector; h) A non-zero sum of two eigenvectors of a matrix A corresponding to the same eigenvalue λ is always an eigenvector. 1.2. Find characteristic polynomials, eigenvalues and eigenvectors of the following matrices: ( 4 −5 2 −3 ) , ( 2 1 −1 4 ) ,   1 3 3 −3 −5 −3 3 3 1   . 1.3. Compute eigenvalues and eigenvectors of the rotation matrix ( cos α − sin α sin α cos α ) . Note, that the eigenvalues (and eigenvectors) do not need to be real. 1.4. Compute characteristic polynomials and eigenvalues of the following matrices:     1 2 5 67 0 2 3 6 0 0 −2 5 0 0 0 3  | |  ,     2 1 0 2 0 π 43 2 0 0 16 1 0 0 0 54  | |  ,     4 0 0 0 1 3 0 0 2 4 e 0 3 3 1 1  | |  ,     4 0 0 0 1 0 0 0 2 4 0 0 3 3 1 1  | |  . Do not expand the characteristic polynomials, leave them as products. 1.5. Prove that eigenvalues (counting multiplicities) of a triangular matrix coincide with its diagonal entries 1.6. An operator A is called nilpotent if Ak = 0 for some k. Prove that if A is nilpotent, then σ(A) = {0} (i.e. that 0 is the only eigenvalue of A). 2. Diagonalization. 105 1.7. Show that characteristic polynomial of a block triangular matrix ( A ∗ 0 B ) , where A and B are square matrices, coincides with det(A − λI) det(B − λI). (Use Exercise 3.11 from Chapter 3). 1.8. Let v1, v2, . . . , vn be a basis in a vector space V . Assume also that the ﬁrst k vectors v1, v2, . . . , vk of the basis are eigenvectors of an operator A, corresponding to an eigenvalue λ (i.e. that Avj = λvj, j = 1, 2, . . . , k). Show that in this basis the matrix of the operator A has block triangular form ( λIk ∗ 0 B ) , where Ik is k × k identity matrix and B is some (n − k) × (n − k) matrix. 1.9. Use the two previous exercises to prove that geometric multiplicity of an eigenvalue cannot exceed its algebraic multiplicity. 1.10. Prove that determinant of a matrix A is the product of its eigenvalues (count- ing multiplicities). Hint: ﬁrst show that det(A − λI) = (λ1 − λ)(λ2 − λ) . . . (λn − λ), where λ1, λ2, . . . , λn are eigenvalues (counting multiplicities). Then compare the free terms (terms without λ) or plug in λ = 0 to get the conclusion. 1.11. Prove that the trace of a matrix equals the sum of eigenvalues in three steps. First, compute the coeﬃcient of λn−1 in the right side of the equality det(A − λI) = (λ1 − λ)(λ2 − λ) . . . (λn − λ). Then show that det(A − λI) can be represented as det(A − λI) = (a1,1 − λ)(a2,2 − λ) . . . (an,n − λ) + q(λ) where q(λ) is polynomial of degree at most n − 2. And ﬁnally, comparing the coeﬃcients of λ n−1 get the conclusion. 2. Diagonalization. One of the application of the spectral theory is the diagonalization of oper- ators, which means given an operator to ﬁnd a basis in which the matrix of the operator is diagonal. Such basis does not always exists, i.e not all opera- tors can be diagonalized (are diagonalizable). Importance of diagonalizable operators comes from the fact that the powers, and more general function of diagonal matrices are easy to compute, so if we diagonalize an operator we can easily compute functions of it. We will explain how to compute functions of diagonalizable operators in this section. We also give a necessary and suﬃcient condition for an operator to be diagonalizable, as well as some simple suﬃcient conditions. 106 4. Introduction to spectral theory Note also that for operators in Fn (matrices) the diagonalizability of A means that it can be represented as A = SDS−1, where D is a diagonal matrix (and S, of course, is invertible); we will explain this shortly. Unless otherwise speciﬁed, all results in this section hold for both com- plex and real vector spaces (and even for spaces over arbitrary ﬁelds). 2.1. Preliminaries. Suppose an operator A in a vector space V is such that V has a basis B = b1, b2, . . . , bn of eigenvectors of A, with λ1, λ2, . . . , λn being the corresponding eigenvalues. Then the matrix of A in this basis is the diagonal matrix with λ1, λ2, . . . , λn on the diagonal [A] BB = diag{λ1, λ2, . . . , λn} =      λ1 λ2 0 . . . 0 λn  | | |  .(2.1) On the other hand, if the matrix of an operator A in a basis B = b1, b2, . . . , bn is given by (2.1) then trivially Abk = λkbk, i.e λk are eigen- values and bk are corresponding eigenvectors. Note that the above reasoning hods for both complex and real vector spaces (and even for vector spaces over arbitrary ﬁelds) Applying the above reasoning to operators in Fn (matrices) we immedi- ately get the following theorem. Note, that while in this book F is either C or R, this theorem hods for an arbitrary ﬁeld F. Theorem 2.1. A matrix A (with values in F) admits a representation A = SDS−1, where D is a diagonal matrix and S is an invertible one (both with entries in F) if and only if there exists a basis in Fn of eigenvectors of A. Moreover, in this case diagonal entries of D are the eigenvalues and the columns of S are the corresponding eigenvectors (column number k corre- sponds to kth diagonal entry of D). Proof. Let D = diag{λ1, λ2, . . . , λn}, and let b1, b2, . . . , bn be the columns of S (note that since S is invertible its columns form a basis in Fn). Then the identity A = SDS−1 means that D = [A] B,B . Indeed, S = [I] S,B is the change of the coordinates matrix from B to the standard basis S, so we get from A = SDS−1 that D = S−1AS = [I] B,S A[I]S,B ], which means exactly that D = [A] B,B . And as we just discussed above, [A] B,B = D = diag{λ1, λ2, . . . , λn} if and only if λk are the eigenvalues and bk are the corresponding eigenvectors of A. □ 2. Diagonalization. 107 Remark. Note if a matrix admits the representation A = SDS−1 with a di- agonal matrix D, then a simple direct calculation shows that the columns of S are eigenvectors of A and diagonal entries of D are corresponding eigen- values. This gives an alternative proof of the corresponding statement in Theorem 2.1. As we discussed above, a diagonalizable operator A : V → V has exactly n = dim V eigenvalues (counting multiplicities). Any operator in a complex vector space V has n eigenvalues (counting multiplicities); an operator in a real space, on the other hand, could have no real eigenvalues. We will, as it is customary in the spectral theory, treat real matrices as operators in the complex space Cn, thus allowing complex eigenvalues and eigenvectors. Unless otherwise speciﬁed we will mean by the diagonalization of a matrix its complex diagonalization, i.e. a representation A = SDS−1 where matrices S and D can have complex entries. The question when a real matrix admits a real diagonalization (A = SDS−1 with real matrices S and D) is in fact a very simple one, see Theorem 2.9 below. 2.2. Some motivations: functions of operators. Let the matrix of an operator A in a basis B = b1, b2, . . . , bn is a diagonal one given by (2.1). Then it is easy to ﬁnd an N th power of the operator A. Namely, the matrix of AN in the basis B is [AN ]BB = diag{λ N 1 , λ N 2 , . . . , λN n } =      λN 1 λN 2 0 . . . 0 λN n  | | |  . Moreover, functions of the operator are also very easy to compute: for ex- ample the operator (matrix) exponent etA is deﬁned as e tA = I +tA+ t2A2 2! + t3A3 3! + . . . = ∞∑ k=0 tkAk k! , and its matrix in the basis B is [e tA]BB = diag{eλ1t, e λ2t, . . . , eλnt} =      eλ1t eλ2t 0 . . . 0 eλnt  | | |  . Let now A be an operator in Fn. To ﬁnd the matrices of the operators AN and etA in the standard basis S, we need to recall that the change of coordinate matrix [I]SB is the matrix with columns b1, b2, . . . , bn. Let us 108 4. Introduction to spectral theory call this matrix S, then according to the change of coordinates formula we have A = [A] SS = S      λ1 λ2 0 . . . 0 λn  | | |  S−1 = SDS−1, where we use D for the diagonal matrix in the middle. Similarly AN = SDN S−1 = S      λN 1 λN 2 0 . . . 0 λN n  | | |  S−1 , and similarly for etA. Another way of thinking about powers (or other functions) of diagonaliz- able operators is to see that if operator A can be represented as A = SDS−1, then AN = (SDS−1)(SDS−1) . . . (SDS−1) | {z } N times = SDN S−1 and it is easy to compute the N th power of a diagonal matrix. 2.3. The case of n distinct eigenvalues. We now present very simple suﬃcient condition for an operator to be diagonalizable, see Corollary 2.3 below. Theorem 2.2. Let λ1, λ2, . . . , λr be distinct eigenvalues of A, and let v1, v2, . . . , vr be the corresponding eigenvectors. Then vectors v1, v2, . . . , vr are linearly independent. Proof. We will use induction on r. The case r = 1 is trivial, because by the deﬁnition an eigenvector is non-zero, and a system consisting of one non-zero vector is linearly independent. Suppose that the statement of the theorem is true for r − 1. Suppose there exists a non-trivial linear combination (2.2) c1v1 + c2v2 + . . . + crvr = r∑ k=1 ckvk = 0. Applying A − λrI to (2.2) and using the fact that (A − λrI)vr = 0 we get r−1∑ k=1 ck(λk − λr)vk = 0. 2. Diagonalization. 109 By the induction hypothesis vectors v1, v2, . . . , vr−1 are linearly indepen- dent, so ck(λk − λr) = 0 for k = 1, 2, . . . , r − 1. Since λk ̸= λr we can conclude that ck = 0 for k < r. Then it follows from (2.2) that cr = 0, i.e. we have the trivial linear combination. □ Corollary 2.3. If an operator A : V → V has exactly n = dim V distinct While very simple, this is a very impor- tant statement, and it will be used a lot! Please remember it. eigenvalues, then it is diagonalizable. Proof. For each eigenvalue λk let vk be a corresponding eigenvector (just pick one eigenvector for each eigenvalue). By Theorem 2.2 the system v1, v2, . . . , vn is linearly independent, and since it consists of exactly n = dim V vectors it is a basis. □ 2.4. Bases of subspaces (AKA direct sums of subspaces). To de- scribe diagonalizable operators we need to introduce some new deﬁnitions. Let V1, V2, . . . , Vp be subspaces of a vector space V . We say that the system of subspaces is a basis in V if any vector v ∈ V admits a unique representation as a sum (2.3) v = v1 + v2 + . . . + vp = p∑ k=1 vk, vk ∈ Vk. We also say, that a system of subspaces V1, V2, . . . , Vp is linearly independent if the equation v1 + v2 + . . . + vp = 0, vk ∈ Vk has only trivial solution (vk = 0 ∀k = 1, 2, . . . , p). Another way to phrase that is to say that a system of subspaces V1, V2, . . . , Vp is linearly independent if and only if any system of non-zero vectors vk, where vk ∈ Vk, is linearly independent. We say that the system of subspaces V1, V2, . . . , Vp is generating (or complete, or spanning) if any vector v ∈ V admits representation as (2.3) (not necessarily unique). Remark 2.4. From the above deﬁnition one can immediately see that The- orem 2.2 in fact states that the system of eigenspaces Ek of an operator A Ek := Ker(A − λkI), λk ∈ σ(A), is linearly independent. Remark 2.5. It is easy to see that similarly to the bases of vectors, a system of subspaces V1, V2, . . . , Vp is a basis if and only if it is generating and linearly independent. We leave the proof of this fact as an exercise for the reader. 110 4. Introduction to spectral theory There is a simple example of a basis of subspaces. Let V be a vector space with a basis v1, v2, . . . , vn. Split the set of indices 1, 2, . . . , n into p subsets Λ1, Λ2, . . . , Λp, and deﬁne subspaces Vk := span{vj : j ∈ Λk}. Clearly the subspaces Vk form a basis of V . The following theorem shows that in the ﬁnite-dimensional case it is essentially the only possible example of a basis of subspaces. Theorem 2.6. Let V1, V2, . . . , Vp be a basis of subspaces, and let us have in each subspace Vk a basis (of vectors) Bk2. Then the union ∪kBk of these bases is a basis in V . To prove the theorem we need the following lemma Lemma 2.7. Let V1, V2, . . . , Vp be a linearly independent family of subspac- es, and let us have in each subspace Vk a linearly independent system Bk of vectors 3 Then the union B := ∪kBk is a linearly independent system. Proof. The proof of the lemma is almost trivial, if one thinks a bit about it. The main diﬃculty in writing the proof is a choice of a appropriate notation. Instead of using two indices (one for the number k and the other for the number of a vector in Bk, let us use “ﬂat” notation. Namely, let n be the number of vectors in B := ∪kBk. Let us order the set B, for example as follows: ﬁrst list all vectors from B1, then all vectors in B2, etc, listing all vectors from Bp last. This way, we index all vectors in B by integers 1, 2, . . . , n, and the set of indices {1, 2, . . . , n} splits into the sets Λ1, Λ2, . . . , Λp such that the set Bk consists of vectors bj : j ∈ Λk. Suppose we have a non-trivial linear combination (2.4) c1b1 + c2b2 + . . . + cnbn = n∑ j=1 cjbj = 0. Denote vk = ∑ j∈Λk cjbj. Then (2.4) can be rewritten as v1 + v2 + . . . + vp = 0. 2We do not list the vectors in Bk, one just should keep in mind that each Bk consists of ﬁnitely many vectors in Vk 3Again, here we do not name each vector in Bk individually, we just keep in mind that each set Bk consists of ﬁnitely many vectors. 2. Diagonalization. 111 Since vk ∈ Vk and the system of subspaces Vk is linearly independent, vk = 0 ∀k. Than means that for every k ∑ j∈Λk cjbj = 0, and since the system of vectors bj : j ∈ Λk (i.e. the system Bk) are linearly independent, we have cj = 0 for all j ∈ Λk. Since it is true for all Λk, we can conclude that cj = 0 for all j. □ Proof of Theorem 2.6. To prove the theorem we will use the same nota- tion as in the proof of Lemma 2.7, i.e. the system Bk consists of vectors bj, j ∈ Λk. Lemma 2.7 asserts that the system of vectors bj, j = 1, 2, . . . , n is lin- early independent, so it only remains to show that the system is complete. Since the system of subspaces V1, V2, . . . , Vp is a basis, any vector v ∈ V can be represented as v = v1 + v2 + . . . + vp = p∑ k=1 vk, vk ∈ Vk. Since the vectors bj, j ∈ Λk form a basis in Vk, the vectors vk can be represented as vk = ∑ j∈Λk cjbj, and therefore v = ∑n j=1 cjbj. □ 2.5. Criterion of diagonalizability. First of all let us recall a simple necessary condition. Since the eigenvalues (counting multiplicities) of a di- agonal matrix D = diag{λ1, λ2, . . . , λn} are exactly λ1, λ2, . . . , λn, we see that if an operator A : V → V is diagonalizable, it has exactly n = dim V eigenvalues (counting multiplicities). Theorem below holds for both real and complex vector spaces (and even for spaces over genera ﬁelds). Theorem 2.8. Let an operator A : V → V has exactly n = dim V eigen- values (counting multiplicities)4. Then A is diagonalizable if and only if for each eigenvalue λ the dimension of the eigenspace Ker(A − λI) (i.e. the geometric multiplicity of λ) coincides with the algebraic multiplicity of λ. Proof. First of all let us note, that for a diagonal matrix, the algebraic and geometric multiplicities of eigenvalues coincide, and therefore the same holds for the diagonalizable operators. 4Since any operator in a complex vector space has exactly n eigenvalues (counting multiplic- ities), this assumption is moot in the complex case. 112 4. Introduction to spectral theory Let us now prove the other implication. Let λ1, λ2, . . . , λp be eigenval- ues of A, and let Ek := Ker(A − λkI) be the corresponding eigenspaces. According to Remark 2.4, the subspaces Ek, k = 1, 2, . . . , p are linearly independent. Let Bk be a basis in Ek. By Lemma 2.7 the system B = ∪kBk is a linearly independent system of vectors. We know that each Bk consists of dim Ek(= multiplicity of λk) vectors. So the number of vectors in B equal to the sum of multiplicities of eigen- values λk. But the sum of multiplicities of the eigenvalues is the number of eigenvalues counting multiplicities, which is exactly n = dim V . So, we have a linearly independent system of n = dim V eigenvectors, which means it is a basis. □ 2.6. Real factorization. The theorem below is, in fact, already proven (iT is essentially Theorem 2.8 for real spaces). We state it here to summarize the situation with real diagonalization of real matrices. Theorem 2.9. A real n × n matrix A admits a real factorization (i.e. rep- resentation A = SDS−1 where S and D are real matrices, D is diagonal and S is invertible) if and only if it admits complex factorization and all eigenvalues of A are real. 2.7. Some example. 2.7.1. Real eigenvalues. Consider the matrix A = ( 1 2 8 1 ) . Its characteristic polynomial is equal to \f \f \f \f 1 − λ 2 8 1 − λ \f \f \f \f = (1 − λ)2 − 16 and its roots (eigenvalues) are λ = 5 and λ = −3. For the eigenvalue λ = 5 A − 5I = ( 1 − 5 2 8 1 − 5 ) = ( −4 2 8 −4 ) A basis in its nullspace consists of one vector (1, 2)T , so this is the corre- sponding eigenvector. Similarly, for λ = −3 A − λI = A + 3I = ( 4 2 8 4 ) 2. Diagonalization. 113 and the eigenspace Ker(A + 3I) is spanned by the vector (1, −2)T . The matrix A can be diagonalized as A = ( 1 2 8 1 ) = ( 1 1 2 −2 ) ( 5 0 0 −3 ) ( 1 1 2 −2 )−1 2.7.2. Complex eigenvalues. Consider the matrix A = ( 1 2 −2 1 ) . Its characteristic polynomial is \f \f \f \f 1 − λ 2 −2 1 − λ \f \f \f \f = (1 − λ) 2 + 22 and the eigenvalues (roots of the characteristic polynomial are λ = 1 ± 2i. For λ = 1 + 2i A − λI = ( −2i 2 −2 −2i ) This matrix has rank 1, so the eigenspace Ker(A − λT ) is spanned by one vector, for example by (1, i)T . Since the matrix A is real, we do not need to compute an eigenvector for λ = 1 − 2i: we can get it for free by taking the complex conjugate of the above eigenvector, see Exercise 2.2 below. So, for λ = 1 − 2i a corresponding eigenvector is (1, −i)T , and so the matrix A can be diagonalized as A = ( 1 1 i −i ) ( 1 + 2i 0 0 1 − 2i ) ( 1 1 i −i )−1 . 2.7.3. A non-diagonalizable matrix. Consider the matrix A = ( 1 1 0 1 ) . Its characteristic polynomial is \f \f \f \f 1 − λ 1 0 1 − λ \f \f \f \f = (1 − λ)2, so A has an eigenvalue 1 of multiplicity 2. But, it is easy to see that dim Ker(A − I) = 1 (1 pivot, so 2 − 1 = 1 free variable). Therefore, the geometric multiplicity of the eigenvalue 1 is diﬀerent from its algebraic mul- tiplicity, so A is not diagonalizable. There is also an explanation which does not use Theorem 2.8. Namely, we got that the eigenspace Ker(A − 1I) is one dimensional (spanned by the vector (1, 0)T ). If A were diagonalizable, it would have a diagonal form 114 4. Introduction to spectral theory ( 1 0 0 1 ) in some basis,5 and so the dimension of the eigenspace wold be 2. Therefore A cannot be diagonalized. Exercises. 2.1. Let A be n × n matrix. True or false: a) AT has the same eigenvalues as A. b) AT has the same eigenvectors as A. c) If A is is diagonalizable, then so is AT . Justify your conclusions. 2.2. Let A be a square matrix with real entries, and let λ be its complex eigenvalue. Suppose v = (v1, v2, . . . , vn) T is a corresponding eigenvector, Av = λv. Prove that the λ is an eigenvalue of A and Av = λv. Here v is the complex conjugate of the vector v, v := (v1, v2, . . . , vn) T . 2.3. Let A = ( 4 3 1 2 ) . Find A2004 by diagonalizing A. 2.4. Construct a matrix A with eigenvalues 1 and 3 and corresponding eigenvectors (1, 2)T and (1, 1)T . Is such a matrix unique? 2.5. Diagonalize the following matrices, if possible: a) ( 4 −2 1 1 ). b) ( −1 −1 6 4 ). c)   −2 2 6 5 1 −6 −5 2 9   (λ = 2 is one of the eigenvalues) 2.6. Consider the matrix A =   2 6 −6 0 5 −2 0 0 4   . a) Find its eigenvalues. Is it possible to ﬁnd the eigenvalues without comput- ing? b) Is this matrix diagonalizable? Find out without computing anything. c) If the matrix is diagonalizable, diagonalize it. 5Note, that the only linear transformation having matrix ( 1 0 0 1 ) in some basis is the identity transformation I. Since A is deﬁnitely not the identity, we can immediately conclude that A cannot be diagonalized, so counting dimension of the eigenspace is not necessary. 2. Diagonalization. 115 2.7. Diagonalize the matrix   2 0 6 0 2 4 0 0 4   . 2.8. Find all square roots of the matrix A = ( 5 2 −3 0 ) i.e. ﬁnd all matrices B such that B2 = A. Hint: Finding a square root of a diagonal matrix is easy. You can leave your answer as a product. 2.9. Let us recall that the famous Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, . . . is deﬁned as follows: we put ϕ0 = 0, ϕ1 = 1 and deﬁne ϕn+2 = ϕn+1 + ϕn. We want to ﬁnd a formula for ϕn. To do this a) Find a 2 × 2 matrix A such that ( ϕn+2 ϕn+1 ) = A ( ϕn+1 ϕn ) Hint: Combine the trivial equation ϕn+1 = ϕn+1 with the Fibonacci relation ϕn+2 = ϕn+1 + ϕn. b) Diagonalize A and ﬁnd a formula for An. c) Noticing that( ϕn+1 ϕn ) = An ( ϕ1 ϕ0 ) = An ( 1 0 ) ﬁnd a formula for ϕn. (You will need to compute an inverse and perform multiplication here). d) Show that the vector (ϕn+1/ϕn, 1)T converges to an eigenvector of A. What do you think, is it a coincidence? 2.10. Let A be a 5 × 5 matrix with 3 eigenvalues (not counting multiplicities). Suppose we know that one eigenspace is three-dimensional. Can you say if A is diagonalizable? 2.11. Give an example of a 3 × 3 matrix which cannot be diagonalized. After you constructed the matrix, can you make it “generic”, so no special structure of the matrix could be seen? 2.12. Let a non-zero matrix A satisfy A5 = 0. Prove that A cannot be diagonalized. More generally, any non-zero nilpotent matrix, i.e. a non-zero matrix satisfying AN = 0 for some N cannot be diagonalized. 2.13. Eigenvalues of a transposition: 116 4. Introduction to spectral theory a) Consider the transformation T in the space M2×2 of 2×2 matrices, T (A) = AT . Find all its eigenvalues and eigenvectors. Is it possible to diagonalize this transformation? Hint: While it is possible to write a matrix of this linear transformation in some basis, compute characteristic polynomial, and so on, it is easier to ﬁnd eigenvalues and eigenvectors directly from the deﬁnition. b) Can you do the same problem but in the space of n × n matrices? 2.14. Prove that two subspaces V1 and V2 are linearly independent if and only if V1 ∩ V2 = {0}. Chapter 5 Inner product spaces Theory of inner product spaces is developed only for real and complex spaces, so F in this Chapter is always R or C; the results usually do not generalize to spaces over arbitrary ﬁelds. Most of the results and calculations in this chapter hold (and the results have the same statements) in both real and complex cases. In rare situations when there is a diﬀerence between real and complex case, we state explicitly which case is considered: otherwise everything holds for both cases. Finally, when the results and calculations hold for both complex and real cases, we use formulas for the complex case; in the real case they give correct, although sometimes a bit more complicated, formulas. 1. Inner product in R n and C n. Inner product spaces. 1.1. Inner product and norm in Rn. In dimensions 2 and 3, we deﬁned the length of a vector x (i.e. the distance from its endpoint to the origin) by the Pythagorean rule, for example in R3 the length of the vector is deﬁned as ∥x∥ = √ x2 1 + x2 2 + x2 3. It is natural to generalize this formula for all n, to deﬁne the norm of the vector x ∈ Rn as ∥x∥ = √ x2 1 + x2 2 + . . . + x2 n. The word norm is used as a fancy replacement for the word length. 117 118 5. Inner product spaces The dot product in R3 was deﬁned as x · y = x1y2 + x2y2 + x3y3, where x = (x1, x2, x3)T and y = (y1, y2, y3)T . Similarly, in Rn one can deﬁne the inner product (x, y) of two vectorsWhile the notation x · y and term “dot product” is often used for the inner product, for reasons which will be clear later, we prefer the notation (x, y) x = (x1, x2, . . . , xn)T , y = (y1, y2, . . . , yn)T by (x, y) := x1y1 + x2y2 + . . . + xnyn = yT x, so ∥x∥ = √ (x, x). Note, that yT x = xT y, and we use the notation yT x only to be consis- tent. 1.2. Inner product and norm in Cn. Let us now deﬁne norm and inner product for Cn. As we have seen before, the complex space Cn is the most natural space from the point of view of spectral theory: even if one starts from a matrix with real coeﬃcients (or operator on a real vectors space), the eigenvalues can be complex, and one needs to work in a complex space. For a complex number z = x + iy, we have |z|2 = x2 + y2 = zz. If z ∈ Cn is given by z =      z1 z2 ... zn  | | |  =      x1 + iy1 x2 + iy2 ... xn + iyn  | | |  , it is natural to deﬁne its norm ∥z∥ by ∥z∥2 = n∑ k=1(x2 k + y2 k) = n∑ k=1 |zk|2. Let us try to deﬁne an inner product on Cn such that ∥z∥2 = (z, z). One of the choices is to deﬁne (z, w) by (z, w) = z1w1 + z2w2 + . . . + znwn = n∑ k=1 zkwk, and that will be our deﬁnition of the standard inner product in Cn. To simplify the notation, let us introduce a new notion. For a matrix A let us deﬁne its Hermitian adjoint, or simply adjoint A∗ by A∗ = AT , meaning that we take the transpose of the matrix, and then take the complex conjugate of each entry. Note, that for a real matrix A, A∗ = AT . Using the notion of A∗, one can write the standard inner product in Cn as (z, w) = w∗z. 1. Inner product in Rn and Cn. Inner product spaces. 119 Remark. It is easy to see that one can deﬁne a diﬀerent inner product in Cn such that ∥z∥ 2 = (z, z), namely the inner product given by (z, w)1 = z1w1 + z2w2 + . . . + znwn = z∗w. We did not specify what properties we want the inner product to satisfy, but z∗w and w∗z are the only reasonable choices giving ∥z∥2 = (z, z). Note, that the above two choices of the inner product are essentially equivalent: the only diﬀerence between them is notational, because (z, w)1 = (w, z). While the second choice of the inner product looks more natural, the ﬁrst one, (z, w) = w∗z is more widely used, so we will use it as well. 1.3. Inner product spaces. The inner product we deﬁned for Rn and Cn satisﬁes the following properties: 1. (Conjugate) symmetry: (x, y) = (y, x); note, that for a real space, this property is just symmetry, (x, y) = (y, x); 2. Linearity: (αx + βy, z) = α(x, z) + β(y, z) for all vector x, y, z and all scalars α, β; 3. Non-negativity: (x, x) ≥ 0 ∀x; 4. Non-degeneracy: (x, x) = 0 if and only if x = 0. Let V be a (complex or real) vector space. An inner product on V is a function, that assign to each pair of vectors x, y a scalar, denoted by (x, y) such that the above properties 1–4 are satisﬁed. Note that for a real space V we assume that (x, y) is always real, and for a complex space the inner product (x, y) can be complex. A space V together with an inner product on it is called an inner product space. Given an inner product space, one deﬁnes the norm on it by ∥x∥ = √ (x, x). 1.3.1. Examples. Example 1.1. Let V be Rn or Cn. We already have an inner product (x, y) = y∗x = ∑n k=1 xkyk deﬁned above. This inner product is called the standard inner product in Rn or Cn We will use symbol F to denote both C and R. When we have some statement about the space Fn, it means the statement is true for both Rn and Cn. Example 1.2. Let V be the space Pn of polynomials of degree at most n. Deﬁne the inner product by (f, g) = ∫ 1 −1 f (t)g(t)dt. 120 5. Inner product spaces It is easy to check, that the above properties 1–4 are satisﬁed. This deﬁnition works both for complex and real cases. In the real case we only allow polynomials with real coeﬃcients, and we do not need the complex conjugate here. Let us recall, that for a square matrix A, its trace is deﬁned as the sum of the diagonal entries, trace A := n∑ k=1 ak,k. Example 1.3. For the space Mm×n of m × n matrices let us deﬁne the so-called Frobenius inner product by (A, B) = trace(B∗A). Again, it is easy to check that the properties 1–4 are satisﬁed, i.e. that we indeed deﬁned an inner product. Note, that trace(B∗A) = ∑ j,k Aj,kBj,k, so this inner product coincides with the standard inner product in Cmn. 1.4. Properties of inner product. The statements we get in this section are true for any abstract inner product space, not only for Fn. To prove them we use only properties 1–4 of the inner product. First of all let us notice, that properties 1 and 2 imply that 2′. (x, αy + βz) = α(x, y) + β(x, z). Indeed, (x, αy + βz) = (αy + βz, x) = α(y, x) + β(z, x) = = α(y, x) + β (z, x) = α(x, y) + β(x, z) Note also that property 2 implies that for all vectors x (0, x) = (x, 0) = 0. Lemma 1.4. Let x be a vector in an inner product space V . Then x = 0 if and only if (1.1) (x, y) = 0 ∀y ∈ V. Proof. Since (0, y) = 0 we only need to show that (1.1) implies x = 0. Putting y = x in (1.1) we get (x, x) = 0, so x = 0. □ Applying the above lemma to the diﬀerence x − y we get the following 1. Inner product in Rn and Cn. Inner product spaces. 121 Corollary 1.5. Let x, y be vectors in an inner product space V . The equality x = y holds if and only if (x, z) = (y, z) ∀z ∈ V. The following corollary is very simple, but will be used a lot Corollary 1.6. Suppose two operators A, B : X → Y satisfy (Ax, y) = (Bx, y) ∀x ∈ X, ∀y ∈ Y. Then A = B. Proof. By the previous corollary (ﬁx x and take all possible y’s) we get Ax = Bx. Since this is true for all x ∈ X, the transformations A and B coincide. □ The following property relates the norm and the inner product. Theorem 1.7 (Cauchy–Schwarz inequality). |(x, y)| ≤ ∥x∥ · ∥y∥. Proof. The proof we are going to present, is not the shortest one, but it shows where the main ideas came from. Let us consider the real case ﬁrst. If y = 0, the statement is trivial, so we can assume that y ̸= 0. By the properties of an inner product, for all scalar t 0 ≤ ∥x − ty∥2 = (x − ty, x − ty) = ∥x∥2 − 2t(x, y) + t 2∥y∥2. In particular, this inequality should hold for t = (x,y) ∥y∥2 1, and for this point the inequality becomes 0 ≤ ∥x∥2 − 2 (x, y)2 ∥y∥2 + (x, y)2 ∥y∥2 = ∥x∥ 2 − (x, y)2 ∥y∥2 , which is exactly the inequality we need to prove. There are several possible ways to treat the complex case. One is to replace x by αx, where α is a complex constant, |α| = 1 such that (αx, y) is real, and then repeat the proof for the real case. The other possibility is again to consider 0 ≤ ∥x − ty∥ 2 = (x − ty, x − ty) = (x, x − ty) − t(y, x − ty) = ∥x∥ 2 − t(y, x) − t(x, y) + |t| 2∥y∥2. 1That is the point where the above quadratic polynomial has a minimum: it can be computed, for example by taking the derivative in t and equating it to 0 122 5. Inner product spaces Substituting t = (x,y) ∥y∥2 = (y,x) ∥y∥2 into this inequality, we get 0 ≤ ∥x∥ 2 − |(x, y)|2 ∥y∥2 which is the inequality we need. Note, that the above paragraph is in fact a complete formal proof of the theorem. The reasoning before that was only to explain why do we need to pick this particular value of t. □ An immediate Corollary of the Cauchy–Schwarz Inequality is the follow- ing lemma. Lemma 1.8 (Triangle inequality). For any vectors x, y in an inner product space ∥x + y∥ ≤ ∥x∥ + ∥y∥. Proof. ∥x + y∥2 = (x + y, x + y) = ∥x∥ 2 + ∥y∥ 2 + (x, y) + (y, x) ≤ ∥x∥ 2 + ∥y∥ 2 + 2|(x, y)| ≤ ∥x∥ 2 + ∥y∥ 2 + 2∥x∥ · ∥y∥ = (∥x∥ + ∥y∥) 2. □ The following polarization identities allow one to reconstruct the inner product from the norm: Lemma 1.9 (Polarization identities). For x, y ∈ V (x, y) = 1 4 (∥x + y∥2 − ∥x − y∥ 2) if V is a real inner product space, and (x, y) = 1 4 ∑ α=±1,±i α∥x + αy∥2 if V is a complex inner product space. The lemma is proved by direct computation. We leave the proof as an exercise for the reader. Another important property of the norm in an inner product space can be also checked by direct calculation. Lemma 1.10 (Parallelogram Identity). For any vectors u, v ∥u + v∥2 + ∥u − v∥2 = 2(∥u∥ 2 + ∥v∥ 2). 1. Inner product in Rn and Cn. Inner product spaces. 123 In 2-dimensional space this lemma relates sides of a parallelogram with its diagonals, which explains the name. It is a well-known fact from planar geometry. 1.5. Norm. Normed spaces. We have proved before that the norm ∥v∥ satisﬁes the following properties: 1. Homogeneity: ∥αv∥ = |α| · ∥v∥ for all vectors v and all scalars α. 2. Triangle inequality: ∥u + v∥ ≤ ∥u∥ + ∥v∥. 3. Non-negativity: ∥v∥ ≥ 0 for all vectors v. 4. Non-degeneracy: ∥v∥ = 0 if and only if v = 0. Suppose in a vector space V we assigned to each vector v a number ∥v∥ such that above properties 1–4 are satisﬁed. Then we say that the function v 7→ ∥v∥ is a norm. A vector space V equipped with a norm is called a normed space. Any inner product space is a normed space, because the norm ∥v∥ =√ (v, v) satisﬁes the above properties 1–4. However, there are many other normed spaces. For example, given p, 1 ≤ p < ∞ one can deﬁne the norm ∥ · ∥p on Rn or Cn by ∥x∥p = (|x1| p + |x2| p + . . . + |xn| p)1/p = ( n∑ k=1 |xk|p)1/p . One can also deﬁne the norm ∥ · ∥∞ (p = ∞) by ∥x∥∞ = max{|xk| : k = 1, 2, . . . , n}. The norm ∥ · ∥p for p = 2 coincides with the regular norm obtained from the inner product. To check that ∥ · ∥p is indeed a norm one has to check that it satisﬁes all the above properties 1–4. Properties 1, 3 and 4 are very easy to check, we leave it as an exercise for the reader. The triangle inequality (property 2) is easy to check for p = 1 and p = ∞ (and we proved it for p = 2). For all other p the triangle inequality is true, but the proof is not so simple, and we will not present it here. The triangle inequality for ∥ · ∥p even has special name: its called Minkowski inequality, after the German mathematician H. Minkowski. Note, that the norm ∥ · ∥p for p ̸= 2 cannot be obtained from an inner product. It is easy to see that this norm is not obtained from the standard inner product in Rn (Cn). But we claim more! We claim that it is impossible to introduce an inner product which gives rise to the norm ∥ · ∥p, p ̸= 2. This statement is actually quite easy to prove. By Lemma 1.10 any norm obtained from an inner product must satisfy the Parallelogram Identity. It 124 5. Inner product spaces is easy to see that the Parallelogram Identity fails for the norm ∥ · ∥p, p ̸= 2, and one can easily ﬁnd a counterexample in R2, which then gives rise to a counterexample in all other spaces. In fact, the Parallelogram Identity, as the theorem below asserts, com- pletely characterizes norms obtained from an inner product. Theorem 1.11. A norm in a normed space is obtained from some inner product if and only if it satisﬁes the Parallelogram Identity ∥u + v∥2 + ∥u − v∥2 = 2(∥u∥ 2 + ∥v∥ 2) ∀u, v ∈ V. Lemma 1.10 asserts that a norm obtained from an inner product satisﬁes the Parallelogram Identity. The converse implication is more complicated. If we are given a norm, and this norm came from an inner product, then we do not have any choice; this inner product must be given by the polarization identities, see Lemma 1.9. But, we need to show that (x, y) which we got from the polarization identities is indeed an inner product, i.e. that it satisﬁes all the properties. It is indeed possible to verify that if the norm satisﬁes the parallelogram identity then the inner product (x, y) obtained from the polarization iden- tities is indeed an inner product (i.e. satisﬁes all the properties of an inner product). However, the proof is a bit too involved, so we do not present it here. Exercises. 1.1. Compute (3 + 2i)(5 − 3i), 2 − 3i 1 − 2i , Re ( 2 − 3i 1 − 2i ) , (1 + 2i) 3, Im((1 + 2i) 3). 1.2. For vectors x = (1, 2i, 1 + i) T and y = (i, 2 − i, 3) T compute a) (x, y), ∥x∥ 2, ∥y∥ 2, ∥y∥; b) (3x, 2iy), (2x, ix + 2y); c) ∥x + 2y∥. Remark: After you have done part a), you can do parts b) and c) without actually computing all vectors involved, just by using the properties of inner product. 1.3. Let ∥u∥ = 2, ∥v∥ = 3, (u, v) = 2 + i. Compute ∥u + v∥2, ∥u − v∥ 2, (u + v, u − iv), (u + 3iv, 4iu). 1.4. Prove that for vectors in a inner product space ∥x ± y∥2 = ∥x∥ 2 + ∥y∥ 2 ± 2 Re(x, y) Recall that Re z = 1 2 (z + z) 1.5. Explain why each of the following is not an inner product on a given vector space: 2. Orthogonality. Orthogonal and orthonormal bases. 125 a) (x, y) = x1y1 − x2y2 on R2; b) (A, B) = trace(A + B) on the space of real 2 × 2 matrices’ c) (f, g) = ∫ 1 0 f ′(t)g(t)dt on the space of polynomials; f ′(t) denotes derivative. 1.6 (Equality in Cauchy–Schwarz inequality). Prove that |(x, y)| = ∥x∥ · ∥y∥ if and only if one of the vectors is a multiple of the other. Hint: Analyze the proof of the Cauchy–Schwarz inequality. 1.7. Prove the parallelogram identity for an inner product space V , ∥x + y∥ 2 + ∥x − y∥ 2 = 2(∥x∥ 2 + ∥y∥ 2). 1.8. Let v1, v2, . . . , vn be a spanning set (in particular, a basis) in an inner product space V . Prove that a) If (x, v) = 0 for all v ∈ V , then x = 0; b) If (x, vk) = 0 ∀k, then x = 0; c) If (x, vk) = (y, vk) ∀k, then x = y. 1.9. Consider the space R2 with the norm ∥ · ∥p, introduced in Section 1.5. For p = 1, 2, ∞, draw the “unit ball” Bp in the norm ∥ · ∥p Bp := {x ∈ R2 : ∥x∥p ≤ 1}. Can you guess what the balls Bp for other p look like? 2. Orthogonality. Orthogonal and orthonormal bases. Deﬁnition 2.1. Two vectors u and v are called orthogonal (also perpen- dicular ) if (u, v) = 0. We will write u ⊥ v to say that the vectors are orthogonal. Note, that for orthogonal vectors u and v we have the following, so-called Pythagorean identity: ∥u + v∥ 2 = ∥u∥2 + ∥v∥2 if u ⊥ v. The proof is straightforward computation, ∥u + v∥2 = (u + v, u + v) = (u, u) + (v, v) + (u, v) + (v, u) = ∥u∥2 + ∥v∥2 ((u, v) = (v, u) = 0 because of orthogonality). Deﬁnition 2.2. We say that a vector v is orthogonal to a subspace E if v is orthogonal to all vectors w in E. We say that subspaces E and F are orthogonal if all vectors in E are orthogonal to F , i.e. all vectors in E are orthogonal to all vectors in F The following lemma shows how to check that a vector is orthogonal to a subspace. 126 5. Inner product spaces Lemma 2.3. Let E be spanned by vectors v1, v2, . . . , vr. Then v ⊥ E if and only if v ⊥ vk, ∀k = 1, 2, . . . , r. Proof. By the deﬁnition, if v ⊥ E then v is orthogonal to all vectors in E. In particular, v ⊥ vk, k = 1, 2, . . . , r. On the other hand, let v ⊥ vk, k = 1, 2, . . . , r. Since the vectors vk span E, any vector w ∈ E can be represented as a linear combination ∑r k=1 αkvk. Then (v, w) = r∑ k=1 αk(v, vk) = 0, so v ⊥ w. □ Deﬁnition 2.4. A system of vectors v1, v2, . . . , vn is called orthogonal if any two vectors are orthogonal to each other (i.e. if (vj, vk) = 0 for j ̸= k). If, in addition ∥vk∥ = 1 for all k, we call the system orthonormal. Lemma 2.5 (Generalized Pythagorean identity). Let v1, v2, . . . , vn be an orthogonal system. Then \r \r \r \r \r n∑ k=1 αkvk \r \r \r \r \r 2 = n∑ k=1 |αk| 2∥vk∥ 2 This formula looks particularly simple for orthonormal systems, where ∥vk∥ = 1. Proof of the Lemma. \r \r \r \r \r n∑ k=1 αkvk \r \r \r \r \r 2 = ( n∑ k=1 αkvk, n∑ j=1 αjvj) = n∑ k=1 n∑ j=1 αkαj(vk, vj). Because of orthogonality (vk, vj) = 0 if j ̸= k. Therefore we only need to sum the terms with j = k, which gives exactly n∑ k=1 |αk| 2(vk, vk) = n∑ k=1 |αk|2∥vk∥2. □ Corollary 2.6. Any orthogonal system v1, v2, . . . , vn of non-zero vectors is linearly independent. Proof. Suppose for some α1, α2, . . . , αn we have ∑n k=1 αkvk = 0. Then by the Generalized Pythagorean identity (Lemma 2.5) 0 = ∥0∥ 2 = n∑ k=1 |αk|2∥vk∥2. 2. Orthogonality. Orthogonal and orthonormal bases. 127 Since ∥vk∥ ̸= 0 (vk ̸= 0) we conclude that αk = 0 ∀k, so only the trivial linear combination gives 0. □ Remark. In what follows we will usually mean by an orthogonal system an orthogonal system of non-zero vectors. Since the zero vector 0 is orthogonal to everything, it always can be added to any orthogonal system, but it is really not interesting to consider orthogonal systems with zero vectors. 2.1. Orthogonal and orthonormal bases. Deﬁnition 2.7. An orthogonal (orthonormal) system v1, v2, . . . , vn which is also a basis is called an orthogonal (orthonormal) basis. It is clear that in dim V = n then any orthogonal system of n non-zero vectors is an orthogonal basis. As we studied before, to ﬁnd coordinates of a vector in a basis one needs to solve a linear system. However, for an orthogonal basis ﬁnding coordinates of a vector is much easier. Namely, suppose v1, v2, . . . , vn is an orthogonal basis, and let x = α1v1 + α2v2 + . . . + αnvn = n∑ j=1 αjvj. Taking inner product of both sides of the equation with v1 we get (x, v1) = n∑ j=1 αj(vj, v1) = α1(v1, v1) = α1∥v1∥ 2 (all inner products (vj, v1) = 0 if j ̸= 1), so α1 = (x, v1) ∥v1∥2 . Similarly, multiplying both sides by vk we get (x, vk) = n∑ j=1 αj(vj, vk) = αk(vk, vk) = αk∥vk∥ 2 so (2.1) αk = (x, vk) ∥vk∥2 . Therefore, to ﬁnd coordinates of a vector in an orthogonal basis one does not need to solve a linear system, the coordinates are determined by the formula (2.1). 128 5. Inner product spaces This formula is especially simple for orthonormal bases, when ∥vk∥ = 1. Namely, if v1, v2, . . . , vn is an orthonormal basis, any vector v can be represented as (2.2) v = n∑ k=1(v, vk)vk. This formula is sometimes called (a baby version of) the abstract orthogonal Fourier decomposition. The classical (non-abstract) Fourier decomposition deals with a concrete orthonormal system (sines and cosines or complex exponentials). We call this formula a baby version because the real Fourier decomposition deals with inﬁnite orthonormal systems. Remark 2.8. The importance of orthonormal bases is that if we ﬁx an orthonormal basis in an inner product space V , we can work with coordinates in this basis the same way we work with vectors in Fn. Namely, as it wasThis is a very impor- tant remark allowing one to translate any statement about the standard inner prod- uct space Fn to an inner product space with an orthonormal basis v1, v2, . . . , vn discussed in the very beginning of the book, see Remark 2.4 in Chapter 1, if we have a vector space V (over a ﬁeld F) with a basis v1, v2, . . . , vn, then we can perform the standard vector operations (vector addition and multiplication by a scalar) by working with the columns of coordinates in the basis v1, v2, . . . , vn in absolutely the same way we work with vectors in the standard coordinate space Fn. Exercise 2.3 below shows that if we have an orthonormal basis in an inner product space V , we can compute the inner product of 2 vectors in V by taking columns of their coordinates in this orthonormal basis and computing the standard inner product (in Cn or Rn) of these columns. As it will be shown below in Section 3 any ﬁnite-dimensional inner prod- uct space has an orthonormal basis. Thus, the standard inner product spaces Cn (or Rn in the case of real spaces) are essentially the only examples of a ﬁnite-dimensional inner product spaces. Exercises. 2.1. Find all vectors in R4 orthogonal to vectors (1, 1, 1, 1) T and (1, 2, 3, 4)T . 2.2. Let A be a real m × n matrix. Describe (Ran AT ) ⊥, (Ran A) ⊥ 2.3. Let v1, v2, . . . , vn be an orthonormal basis in V . a) Prove that for any x = ∑n k=1 αkvk, y = ∑n k=1 βkvk (x, y) = n∑ k=1 αkβk. b) Deduce from this the Parseval’s identity (x, y) = n∑ k=1 (x, vk)(y, vk) 3. Orthogonal projection and Gram-Schmidt orthogonalization 129 c) Assume now that v1, v2, . . . , vn is only an orthogonal basis, not an or- thonormal one. Can you write down Parseval’s identity in this case? This problem shows that if we have an orthonormal basis, we can use the coordinates in this basis absolutely the same way we use the standard coordinates in Cn (or Rn). The problem below shows that we can deﬁne an inner product by declaring a basis to be an orthonormal one. 2.4. Let V be a vector space and let v1, v2, . . . , vn be a basis in V . For x =∑n k=1 αkvk, y = ∑n k=1 βkvk deﬁne ⟨x, y⟩ := ∑n k=1 αk ¯βk. Prove that ⟨x, y⟩ deﬁnes an inner product in V . 2.5. Let A be a real m × n matrix. Describe the set of all vectors in F m orthogonal to to Ran A. 3. Orthogonal projection and Gram-Schmidt orthogonalization Recalling the deﬁnition of orthogonal projection from the classical planar (2-dimensional) geometry, one can introduce the following deﬁnition. Let E be a subspace of an inner product space V . Deﬁnition 3.1. For a vector v its orthogonal projection PEv onto the subspace E is a vector w such that 1. w ∈ E ; 2. v − w ⊥ E. We will use notation w = PEv for the orthogonal projection. After introducing an object, it is natural to ask: 1. Does the object exist? 2. Is the object unique? 3. How does one ﬁnd it? We will show ﬁrst that the projection is unique. Then we present a method of ﬁnding the projection, proving its existence. The following theorem shows why the orthogonal projection is important and also proves that it is unique. Theorem 3.2. The orthogonal projection w = PEv minimizes the distance from v to E, i.e. for all x ∈ E ∥v − w∥ ≤ ∥v − x∥. Moreover, if for some x ∈ E ∥v − w∥ = ∥v − x∥, 130 5. Inner product spaces then x = w. Proof. Let y = w − x. Then v − x = v − w + w − x = v − w + y. Since v − w ⊥ E we have y ⊥ v − w and so by Pythagorean Theorem ∥v − x∥2 = ∥v − w∥2 + ∥y∥ 2 ≥ ∥v − w∥ 2. Note that equality happens only if y = 0 i.e. if x = w. □ The following proposition shows how to ﬁnd an orthogonal projection if we know an orthogonal basis in E. Proposition 3.3. Let v1, v2, . . . , vr be an orthogonal basis in E. Then the orthogonal projection PEv of a vector v is given by the formula P E v = r∑ k=1 αkvk, where αk = (v, vk) ∥vk∥2 . In other words (3.1) PE v = r∑ k=1 (v, vk) ∥vk∥2 vk. Note that the formula for αk coincides with (2.1), i.e. this formula applied to an orthogonal system (not a basis) gives us a projection onto its span. Remark 3.4. It is easy to see now from formula (3.1) that the orthogonal projection PE is a linear transformation. One can also see linearity of PE directly, from the deﬁnition and unique- ness of the orthogonal projection. Indeed, it is easy to check that for any x and y the vector αx + βy − (αP E x − βP E y) is orthogonal to any vector in E, so by the deﬁnition PE (αx + βy) = αP E x + βP E y. Remark 3.5. Recalling the deﬁnition of inner product in Cn and Rn one can get from the above formula (3.1) the matrix of the orthogonal projection PE onto E in Cn (Rn) is given by (3.2) PE = r∑ k=1 1 ∥vk∥2 vkv∗ k where columns v1, v2, . . . , vr form an orthogonal basis in E. Proof of Proposition 3.3. Let w := r∑ k=1 αkvk, where αk = (v, vk) ∥vk∥2 . 3. Orthogonal projection and Gram-Schmidt orthogonalization 131 We want to show that v − w ⊥ E. By Lemma 2.3 it is suﬃcient to show that v − w ⊥ vk, k = 1, 2, . . . , n. Computing the inner product we get for k = 1, 2, . . . , r (v − w, vk) = (v, vk) − (w, vk) = (v, vk) − r∑ j=1 αj(vj, vk) = (v, vk) − αk(vk, vk) = (v, vk) − (v, vk) ∥vk∥2 ∥vk∥2 = 0. □ So, if we know an orthogonal basis in E we can ﬁnd the orthogonal projection onto E. In particular, since any system consisting of one vector is an orthogonal system, we know how to perform orthogonal projection onto one-dimensional spaces. But how do we ﬁnd an orthogonal projection if we are only given a basis in E? Fortunately, there exists a simple algorithm allowing one to get an orthogonal basis from a basis. 3.1. Gram-Schmidt orthogonalization algorithm. Suppose we have a linearly independent system x1, x2, . . . , xn. The Gram-Schmidt method constructs from this system an orthogonal system v1, v2, . . . , vn such that span{x1, x2, . . . , xn} = span{v1, v2, . . . , vn}. Moreover, for all r ≤ n we get span{x1, x2, . . . , xr} = span{v1, v2, . . . , vr} Now let us describe the algorithm. Step 1. Put v1 := x1. Denote by E1 := span{x1} = span{v1}. Step 2. Deﬁne v2 by v2 = x2 − PE1x2 = x2 − (x2, v1) ∥v1∥2 v1. Deﬁne E2 = span{v1, v2}. Note that span{x1, x2} = E2. Step 3. Deﬁne v3 by v3 := x3 − PE2x3 = x3 − (x3, v1) ∥v1∥2 v1 − (x3, v2) ∥v2∥2 v2 Put E3 := span{v1, v2, v3}. Note that span{x1, x2, x3} = E3. Note also that x3 /∈ E2 so v3 ̸= 0. . . . 132 5. Inner product spaces Step r + 1. Suppose that we already made r steps of the process, con- structing an orthogonal system (consisting of non-zero vectors) v1, v2, . . . , vr such that Er := span{v1, v2, . . . , vr} = span{x1, x2, . . . , xr}. Deﬁne vr+1 := xr+1 − PEr xr+1 = xr+1 − r∑ k=1 (xr+1, vk) ∥vk∥2 vk Note,that xr+1 /∈ Er so vr+1 ̸= 0. . . . Continuing this algorithm we get an orthogonal system v1, v2, . . . , vn. 3.2. An example. Suppose we are given vectors x1 = (1, 1, 1) T , x2 = (0, 1, 2) T , x3 = (1, 0, 2) T , and we want to orthogonalize it by Gram-Schmidt. On the ﬁrst step deﬁne v1 = x1 = (1, 1, 1) T . On the second step we get v2 = x2 − PE1x2 = x2 − (x2, v1) ∥v1∥2 v1. Computing (x2, v1) = (  0 1 2   ,   1 1 1  ) = 3, ∥v1∥2 = 3, we get v2 =   0 1 2   − 3 3   1 1 1   =   −1 0 1   . Finally, deﬁne v3 = x3 − PE2x3 = x3 − (x3, v1) ∥v1∥2 v1 − (x3, v2) ∥v2∥2 v2. Computing (  1 0 2   ,   1 1 1   ) = 3, (  1 0 2   ,   −1 0 1   ) = 1, ∥v1∥2 = 3, ∥v2∥ 2 = 2 (∥v1∥2 was already computed before) we get v3 =   1 0 2   − 3 3   1 1 1   − 1 2   −1 0 1   =   1 2 −1 1 2   3. Orthogonal projection and Gram-Schmidt orthogonalization 133 Remark. Since the multiplication by a scalar does not change the orthog- onality, one can multiply vectors vk obtained by Gram-Schmidt by any non-zero numbers. In particular, in many theoretical constructions one normalizes vectors vk by dividing them by their respective norms ∥vk∥. Then the resulting system will be orthonormal, and the formulas will look simpler. On the other hand, when performing the computations one may want to avoid fractional entries by multiplying a vector by the least common denominator of its entries. Thus one may want to replace the vector v3 from the above example by (1, −2, 1)T . 3.3. Orthogonal complement. Decomposition V = E ⊕ E⊥. Deﬁnition. For a subspace E its orthogonal complement E⊥ is the set of all vectors orthogonal to E, E⊥ := {x : x ⊥ E}. If x, y ⊥ E then for any linear combination αx + βy ⊥ E (can you see why?). Therefore E⊥ is a subspace. By the deﬁnition of orthogonal projection any vector in an inner product space V admits a unique representation v = v1 + v2, v1 ∈ E, v2 ⊥ E (eqv. v2 ∈ E⊥) (where clearly v1 = PE v). This statement is often symbolically written as V = E ⊕ E⊥, which mean exactly that any vector admits the unique decomposition above. The following proposition gives an important property of the orthogonal complement. Proposition 3.6. For a subspace E (E⊥) ⊥ = E. The proof is left as an exercise, see Exercise 3.12 below. Exercises. 3.1. Apply Gram–Schmidt orthogonalization to the system of vectors (1, 2, −2)T , (1, −1, 4) T , (2, 1, 1)T . 3.2. Apply Gram–Schmidt orthogonalization to the system of vectors (1, 2, 3)T , (1, 3, 1)T . Write the matrix of the orthogonal projection onto 2-dimensional sub- space spanned by these vectors. 134 5. Inner product spaces 3.3. Complete an orthogonal system obtained in the previous problem to an or- thogonal basis in R3, i.e. add to the system some vectors (how many?) to get an orthogonal basis. Can you describe how to complete an orthogonal system to an orthogonal basis in general situation of Rn or Cn? 3.4. Find the distance from a vector (2, 3, 1) T to the subspace spanned by the vectors (1, 2, 3)T , (1, 3, 1) T . Note, that I am only asking to ﬁnd the distance to the subspace, not the orthogonal projection. 3.5. Find the orthogonal projection of a vector (1, 1, 1, 1) T onto the subspace spanned by the vectors v1 = (1, 3, 1, 1)T and v2 = (2, −1, 1, 0)T (note that v1 ⊥ v2). 3.6. Find the distance from a vector (1, 2, 3, 4) to the subspace spanned by the vectors v1 = (1, −1, 1, 0)T and v2 = (1, 2, 1, 1)T (note that v1 ⊥ v2). Can you ﬁnd the distance without actually computing the projection? That would simplify the calculations. 3.7. True or false: if E is a subspace of V , then dim E +dim(E⊥) = dim V ? Justify. 3.8. Let P be the orthogonal projection onto a subspace E of an inner product space V , dim V = n, dim E = r. Find the eigenvalues and the eigenvectors (eigenspaces). Find the algebraic and geometric multiplicities of each eigenvalue. 3.9. (Using eigenvalues to compute determinants). a) Find the matrix of the orthogonal projection onto the one-dimensional subspace in Rn spanned by the vector (1, 1, . . . , 1) T ; b) Let A be the n × n matrix with all entries equal 1. Compute its eigenvalues and their multiplicities (use the previous problem); c) Compute eigenvalues (and multiplicities) of the matrix A − I, i.e. of the matrix with zeroes on the main diagonal and ones everywhere else; d) Compute det(A − I). 3.10 (Legendre’s polynomials:). Let an inner product on the space of polynomials be deﬁned by (f, g) = ∫ 1 −1 f (t)g(t)dt. Apply Gram-Schmidt orthogonalization to the system 1, t, t2, t 3. Legendre’s polynomials are particular case of the so-called orthogonal polyno- mials, which play an important role in many branches of mathematics. 3.11. Let P = PE be the matrix of an orthogonal projection onto a subspace E. Show that a) The matrix P is self-adjoint, meaning that P ∗ = P . b) P 2 = P . Remark: The above 2 properties completely characterize orthogonal projection, i.e. any matrix P satisfying these properties is the matrix of some orthogonal pro- jection. We will discuss this some time later. 3. Orthogonal projection and Gram-Schmidt orthogonalization 135 3.12. Show that for a subspace E we have (E⊥) ⊥ = E. Hint: It is easy to see that E is orthogonal to E⊥ (why?). To show that any vector x orthogonal to E⊥ belongs to E use the decomposition V = E ⊕ E⊥ from Section 3.3 above. 3.13. Suppose P is the orthogonal projection onto a subspace E, and Q is the orthogonal projection onto the orthogonal complement E⊥. a) What are P + Q and P Q? b) Show that P − Q is its own inverse. 136 5. Inner product spaces 4. Least square solution. Formula for the orthogonal projection As it was discussed before in Chapter 2, the equation Ax = b has a solution if and only if b ∈ Ran A. But what do we do to solve an equation that does not have a solution? This seems to be a silly question, because if there is no solution, then there is no solution. But, situations when we want to solve an equation that does not have a solution can appear naturally, for example, if we obtained the equation from an experiment. If we do not have any errors, the right side b belongs to the column space Ran A, and equation is consistent. But, in real life it is impossible to avoid errors in measurements, so it is possible that an equation that in theory should be consistent, does not have a solution. So, what can one do in this situation? 4.1. Least square solution. The simplest idea is to write down the error ∥Ax − b∥ and try to ﬁnd x minimizing it. If we can ﬁnd x such that the error is 0, the system is consistent and we have exact solution. Otherwise, we get the so-called least square solution. The term least square arises from the fact that minimizing ∥Ax − b∥ is equivalent to minimizing ∥Ax − b∥ 2 = m∑ k=1 |(Ax)k − bk|2 = m∑ k=1 \f \f \f n∑ j=1 Ak,jxj − bk\f \f \f 2 i.e. to minimizing the sum of squares of linear functions. There are several ways to ﬁnd the least square solution. If we are in Rn, and everything is real, we can forget about absolute values. Then we can just take partial derivatives with respect to xj and ﬁnd the where all of them are 0, which gives us the minimum. 4.1.1. Geometric approach. However, there is a simpler way of ﬁnding the minimum. Namely, if we take all possible vectors x, then Ax gives us all possible vectors in Ran A, so minimum of ∥Ax − b∥ is exactly the distance from b to Ran A. Therefore the value of ∥Ax − b∥ is minimal if and only if Ax = PRan Ab, where PRan A stands for the orthogonal projection onto the column space Ran A. So, to ﬁnd the least square solution we simply need to solve the equation Ax = PRan Ab. 4. Least square solution. Formula for the orthogonal projection 137 If we know an orthogonal basis v1, v2, . . . , vn in Ran A, we can ﬁnd vector PRan Ab by the formula PRan Ab = n∑ k=1 (b, vk) ∥vk∥2 vk. If we only know a basis in Ran A, we need to use the Gram–Schmidt orthog- onalization to obtain an orthogonal basis from it. So, theoretically, the problem is solved, but the solution is not very simple: it involves Gram–Schmidt orthogonalization, which can be compu- tationally intensive. Fortunately, there exists a simpler solution. 4.1.2. Normal equation. Namely, Ax is the orthogonal projection PRan Ab if and only if b − Ax ⊥ Ran A (Ax ∈ Ran A for all x). If a1, a2, . . . , an are columns of A, then the condition Ax ⊥ Ran A can be rewritten as b − Ax ⊥ ak, ∀k = 1, 2, . . . , n. That means 0 = (b − Ax, ak) = a∗ k(b − Ax) ∀k = 1, 2, . . . , n. Joining rows a∗ k together we get that these equations are equivalent to A∗(b − Ax) = 0, which in turn is equivalent to the so-called normal equation A∗Ax = A∗b. A solution of this equation gives us the least square solution of Ax = b. Note, that the least square solution is unique if and only if A∗A is invertible. 4.2. Formula for the orthogonal projection. As we already discussed above, if x is a solution of the normal equation A∗Ax = A∗b (i.e. a least square solution of Ax = b), then Ax = PRan Ab. So, to ﬁnd the orthogonal projection of b onto the column space Ran A we need to solve the normal equation A∗Ax = A∗b, and then multiply the solution by A. If the operator A∗A is invertible, the solution of the normal equation A∗Ax = A∗b is given by x = (A∗A)−1A∗b, so the orthogonal projection PRan Ab can be computed as PRan Ab = A(A∗A)−1A∗b. Since this is true for all b, PRan A = A(A∗A)−1A∗ is the formula for the matrix of the orthogonal projection onto Ran A. 138 5. Inner product spaces The following theorem implies that for an m × n matrix A the matrix A∗A is invertible if and only if rank A = n. Theorem 4.1. For an m × n matrix A Ker A = Ker(A ∗A). Indeed, according to the rank theorem Ker A = {0} if and only if rank A is n. Therefore Ker(A∗A) = {0} if and only if rank A = n. Since the matrix A∗A is square, it is invertible if and only if rank A = n. We leave the proof of the theorem as an exercise. To prove the equality Ker A = Ker(A∗A) one needs to prove two inclusions Ker(A∗A) ⊂ Ker A and Ker A ⊂ Ker(A∗A). One of the inclusions is trivial, for the other one use the fact that ∥Ax∥2 = (Ax, Ax) = (A ∗Ax, x). 4.3. An example: line ﬁtting. Let us introduce a few examples where the least square solution appears naturally. Suppose that we know that two quantities x and y are related by the law y = a + bx. The coeﬃcients a and b are unknown, and we would like to ﬁnd them from experimental data. Suppose we run the experiment n times, and we get n pairs (xk, yk), k = 1, 2, . . . , n. Ideally, all the points (xk, yk) should be on a straight line, but because of errors in measurements, it usually does not happen: the point are usually close to some line, but not exactly on it. That is where the least square solution helps! Ideally, the coeﬃcients a and b should satisfy the equations a + bxk = yk, k = 1, 2, . . . , n (note that here, xk and yk are some ﬁxed numbers, and the unknowns are a and b). If it is possible to ﬁnd such a and b we are lucky. If not, the standard thing to do is to minimize the total quadratic error n∑ k=1 |a + bxk − yk|2. But, minimizing this error is exactly ﬁnding the least square solution of the system      1 x1 1 x2 ... ... 1 xn  | | |  [ a b ] =      y1 y2 ... yn  | | |  (recall that xk yk are some given numbers, and the unknowns are a and b). 4. Least square solution. Formula for the orthogonal projection 139 4.3.1. An example. Suppose our data (xk, yk) consist of pairs (−2, 4), (−1, 2), (0, 1), (2, 1), (3, 1). Then we need to ﬁnd the least square solution of       1 −2 1 −1 1 0 1 2 1 3  | | | |  [ a b ] =       4 2 1 1 1  | | | |  Then A ∗A = ( 1 1 1 1 1 −2 −1 0 2 3 )       1 −2 1 −1 1 0 1 2 1 3  | | | |  = ( 5 2 2 18 ) and A∗b = ( 1 1 1 1 1 −2 −1 0 2 3 )       4 2 1 1 1  | | | |  = ( 9 −5 ) so the normal equation A∗Ax = A∗b is rewritten as ( 5 2 2 18 ) ( a b ) = ( 9 −5 ) . The solution of this equation is a = 2, b = −1/2, so the best ﬁtting straight line is y = 2 − 1/2x. 4.4. Other examples: curves and planes. The least square method is not limited to the line ﬁtting. It can also be applied to more general curves, as well as to surfaces in higher dimensions. The only constraint here is that the parameters we want to ﬁnd be involved linearly. The general algorithm is as follows: 1. Find the equations that your data should satisfy if there is exact ﬁt; 2. Write these equations as a linear system, where unknowns are the parameters you want to ﬁnd. Note, that the system need not to be consistent (and usually is not); 3. Find the least square solution of the system. 140 5. Inner product spaces 4.4.1. An example: curve ﬁtting. For example, suppose we know that the relation between x and y is given by the quadratic law y = a + bx + cx2, so we want to ﬁt a parabola y = a + bx + cx2 to the data. Then our unknowns a, b, c should satisfy the equations a + bxk + cx 2 k = yk, k = 1, 2, . . . , n or, in matrix form      1 x1 x2 1 1 x2 x2 2 ... ... ... 1 xn x2 n  | | |    a b c   =      y1 y2 ... yn  | | |  For example, for the data from the previous example we need to ﬁnd the least square solution of       1 −2 4 1 −1 1 1 0 0 1 2 4 1 3 9  | | | |    a b c   =       4 2 1 1 1  | | | |  . Then A∗A =   1 1 1 1 1 −2 −1 0 2 3 4 1 0 4 9         1 −2 4 1 −1 1 1 0 0 1 2 4 1 3 9  | | | |  =   5 2 18 2 18 26 18 26 114   and A∗b =   1 1 1 1 1 −2 −1 0 2 3 4 1 0 4 9         4 2 1 1 1  | | | |  =   9 −5 31   . Therefore the normal equation A∗Ax = A∗b is   5 2 18 2 18 26 18 26 114     a b c   =   9 −5 31   which has the unique solution a = 86/77, b = −62/77, c = 43/154. Therefore, y = 86/77 − 62x/77 + 43x2/154 is the best ﬁtting parabola. 4. Least square solution. Formula for the orthogonal projection 141 4.4.2. Plane ﬁtting. As another example, let us ﬁt a plane z = a + bx + cy to the data (xk, yk, zk) ∈ R 3, k = 1, 2, . . . n. The equations we should have in the case of exact ﬁt are a + bxk + cyk = zk, k = 1, 2, . . . , n, or, in the matrix form      1 x1 y1 1 x2 y2 ... ... ... 1 xn yn  | | |    a b c   =      z1 z2 ... zn  | | |  . So, to ﬁnd the best ﬁtting plane, we need to ﬁnd the best square solution of this system (the unknowns are a, b, c). Exercises. 4.1. Find the least square solution of the system   1 0 0 1 1 1   x =   1 1 0   4.2. Find the matrix of the orthogonal projection P onto the column space of   1 1 2 −1 −2 4   . Use two methods: Gram–Schmidt orthogonalization and formula for the projection. Compare the results. 4.3. Find the best straight line ﬁt (least square solution) to the points (−2, 4), (−1, 3), (0, 1), (2, 0). 4.4. Fit a plane z = a + bx + cy to four points (1, 1, 3), (0, 3, 6), (2, 1, 5), (0, 0, 0). To do that a) Find 4 equations with 3 unknowns a, b, c such that the plane pass through all 4 points (this system does not have to have a solution); b) Find the least square solution of the system. 4.5. Minimal norm solution. let an equation Ax = b has a solution, and let A has non-trivial kernel (so the solution is not unique). Prove that a) There exist a unique solution x0 of Ax = b minimizing the norm ∥x∥, i.e. that there exists unique x0 such that Ax0 = b and ∥x0∥ ≤ ∥x∥ for any x satisfying Ax = b. b) x0 = P(Ker A)⊥ x for any x satisfying Ax = b. 142 5. Inner product spaces 4.6. Minimal norm least square solution. Applying previous problem to the equa- tion Ax = PRan A b show that a) There exists a unique least square solution x0 of Ax = b minimizing the norm ∥x∥. b) x0 = P(Ker A) ⊥ x for any least square solution x of Ax = b. 5. Adjoint of a linear transformation. Fundamental subspaces revisited. 5.1. Adjoint matrices and adjoint operators. Let as recall that for an m × n matrix A its Hermitian adjoint (or simply adjoint) A∗ is deﬁned by A∗ := AT . In other words, the matrix A∗ is obtained from the transposed matrix AT by taking complex conjugate of each entry. The following identity is the main property of adjoint matrix: (Ax, y) = (x, A∗y) ∀x ∈ Cn, ∀y ∈ Cm. Before proving this identity, let us introduce some useful formulas. Let us recall that for transposed matrices we have the identity (AB)T = BT AT . Since for complex numbers z and w we have zw = z w, the identity (AB) ∗ = B∗A∗ holds for the adjoint. Also, since (AT )T = A and z = z, (A∗)∗ = A. Now, we are ready to prove the main identity: (Ax, y) = y∗Ax = (A∗y) ∗x = (x, A ∗y); the ﬁrst and the last equalities here follow from the deﬁnition of inner prod- uct in Fn, and the middle one follows from the fact that (A ∗x) ∗ = x∗(A∗) ∗ = x∗A. 5.1.1. Uniqueness of the adjoint. The above main identity (Ax, y) = (x, A∗y) is often used as the deﬁnition of the adjoint operator. Let us ﬁrst notice that the adjoint operator is unique: if a matrix B satisﬁes (Ax, y) = (x, By) ∀x, y, then B = A∗. Indeed, by the deﬁnition of A∗ for a given y we have (x, A ∗y) = (x, By) ∀x, and therefore by Corollary 1.5 A∗y = By. Since it is true for all y, the linear transformations, and therefore the matrices A∗ and B coincide. 5. Adjoint of a linear transformation 143 5.1.2. Adjoint transformation in abstract setting. The above main identity (Ax, y) = (x, A∗y) can be used to deﬁne the adjoint operator in abstract setting, where A : V → W is an operator acting from one inner product space to another. Namely, we deﬁne A∗ : W → V to be the operator satisfying (Ax, y) = (x, A ∗y) ∀x ∈ V, ∀y ∈ W. Why does such an operator exists? We can simply construct it: consider orthonormal bases A = v1, v2, . . . , vn in V and B = w1, w2, . . . , wm in W . If [A] BA is the matrix of A with respect to these bases, we deﬁne the operator A∗ by deﬁning its matrix [A∗] AB as [A∗]AB = ([A] BA) ∗. We leave the proof that this indeed gives the adjoint operator as an exercise for the reader. Note, that the reasoning in the above Sect. 5.1.1 implies that the adjoint operator is unique. 5.1.3. Useful formulas. Below we present the properties of the adjoint op- erators (matrices) we will use a lot. We leave the proofs as an exercise for the reader. 1. (A + B)∗ = A∗ + B∗; 2. (αA)∗ = αA∗; 3. (AB)∗ = B∗A∗; 4. (A∗)∗ = A; 5. (y, Ax) = (A∗y, x). 5.2. Relation between fundamental subspaces. Theorem 5.1. Let A : V → W be an operator acting from one inner product space to another. Then 1. Ker A∗ = (Ran A)⊥; 2. Ker A = (Ran A∗)⊥; 3. Ran A = (Ker A∗)⊥; 4. Ran A∗ = (Ker A)⊥. Remark. Earlier in Section 7 of Chapter 2 the fundamental subspaces were deﬁned (as it is often done in the literature) using AT instead of A∗. Of course, there is no diﬀerence for real matrices, so in the real case the above theorem gives the geometric description of the fundamentals subspaces de- ﬁned there. Geometric interpretation of the fundamental subspaces deﬁned using AT is presented in Chapter 8 below, see Section 3 there (Theorem 3.7). The 144 5. Inner product spaces formulas in this theorem are essentially the same as in Theorem 5.1 here, only the interpretation is a bit diﬀerent. Proof of Theorem 5.1. First of all, let us notice, that since for a subspace E we have (E⊥)⊥ = E, the statements 1 and 3 are equivalent. Similarly, for the same reason, the statements 2 and 4 are equivalent as well. Finally, statement 2 is exactly statement 1 applied to the operator A∗ (here we use the fact that (A∗)∗ = A). So, to prove the theorem we only need to prove statement 1. We will present 2 proofs of this statement: a “matrix” proof, and an “invariant”, or “coordinate-free” one. In the “matrix” proof, we assume that A is an m × n matrix, i.e. that A : Fn → Fm. The general case can be always reduced to this one by picking orthonormal bases in V and W , and considering the matrix of A in this bases. Let a1, a2, . . . , an be the columns of A. Note, that x ∈ (Ran A)⊥ if and only if x ⊥ ak (i.e. (x, ak) = 0) ∀k = 1, 2, . . . , n. By the deﬁnition of the inner product in Fn, that means 0 = (x, ak) = a ∗ k x ∀k = 1, 2, . . . , n. Since a∗ k is the row number k of A∗, the above n equalities are equivalent to the equation A∗x = 0. So, we proved that x ∈ (Ran A)⊥ if and only if A∗x = 0, and that is exactly the statement 1. Now, let us present the “coordinate-free” proof. The inclusion x ∈ (Ran A)⊥ means that x is orthogonal to all vectors of the form Ay, i.e. that (x, Ay) = 0 ∀y. Since (x, Ay) = (A∗x, y), this identity is equivalent to (A∗x, y) = 0 ∀y, and by Lemma 1.4 this happens if and only if A∗x = 0. So we proved that x ∈ (Ran A)⊥ if and only if A∗x = 0, which is exactly the statement 1 of the theorem. □ 5.3. The “essential” part of a linear transformation. The above the- orem makes the structure of the operator A and the geometry of fundamental subspaces much more transparent. It follows from this theorem that the op- erator A can be represented as a composition of orthogonal projection onto Ran A∗ and an isomorphism from Ran A∗ to Ran A. 5. Adjoint of a linear transformation 145 Indeed, let ̃A : Ran A∗ → Ran A be the restriction of A to the domain Ran A∗ and the target space Ran A, ̃Ax = Ax, ∀x ∈ Ran A∗. Since Ker A = (Ran A∗)⊥, we have Ax = AP Ran A∗ x = ̃APRan A∗ x ∀x ∈ X; the fact that x − PRan A∗ x ∈ (Ran A∗)⊥ = Ker A is used here. Therefore we can write Ax = ̃APRan A∗ x ∀x ∈ X,(5.1) or, equivalently, A = ̃APRan A∗ . Note also that ̃A : Ran A∗ → Ran A is an invertible transformation. First we notice that Ker ̃A = {0}: if x ∈ Ran A∗ is such that ̃Ax = Ax = 0, then x ∈ Ker A = (Ran A∗)⊥, so x ∈ Ran A∗ ∩ (Ran A∗)⊥, thus x = 0. Then to see that ̃A is invertible, it is suﬃcient to she that ̃A is onto (surjective). But this immediately follows from (5.1): Ran ̃A = ̃A Ran A ∗ = APRan A∗ X = AX = Ran A. The isomorphism ̃A is sometimes called the “essential part” of the op- erator A (a non-standard terminology). The fact the “essential part” ̃A : Ran A∗ → Ran A of A is an isomor- phism implies the following “complex” rank theorem: rank A = rank A∗. But, of course, this theorem also follows from an elementary observation that complex conjugation does not change rank of a matrix, rank A = rank A. Exercises. 5.1. Show that for a square matrix A the equality det(A∗) = det(A) holds. 5.2. Find matrices of orthogonal projections onto all 4 fundamental subspaces of the matrix A =   1 1 1 1 3 2 2 4 3   . Note, that really you need only to compute 2 of the projections. If you pick an appropriate 2, the other 2 are easy to obtain from them (recall, how the projections onto E and E⊥ are related). 5.3. Let A be an m × n matrix. Show that Ker A = Ker(A∗A). To do that you need to prove 2 inclusions, Ker(A∗A) ⊂ Ker A and Ker A ⊂ Ker(A∗A). One of the inclusions is trivial, for the other one use the fact that ∥Ax∥2 = (Ax, Ax) = (A∗Ax, x). 5.4. Use the equality Ker A = Ker(A∗A) to prove that 146 5. Inner product spaces a) rank A = rank(A∗A); b) If Ax = 0 has only the trivial solution, A is left invertible. (You can just write a formula for a left inverse). 5.5. Suppose, that for a matrix A the matrix A∗A is invertible, so the orthogonal projection onto Ran A is given by the formula A(A∗A) −1A∗. Can you write formulas for the orthogonal projections onto the other 3 fundamental subspaces (Ker A, Ker A∗, Ran A∗)? 5.6. Let a matrix P be self-adjoint (P ∗ = P ) and let P 2 = P . Show that P is the matrix of an orthogonal projection. Hint: consider the decomposition x = x1 + x2, x1 ∈ Ran P , x2 ⊥ Ran P and show that P x1 = x1, P x2 = 0. For one of the equalities you will need self-adjointness, for the other one the property P 2 = P . 6. Isometries and unitary operators. Unitary and orthogonal matrices. 6.1. Main deﬁnitions. Deﬁnition. An operator U : X → Y is called an isometry, if it preserves the norm, ∥U x∥ = ∥x∥ ∀x ∈ X. The following theorem shows that an isometry preserves the inner prod- uct Theorem 6.1. An operator U : X → Y is an isometry if and only if it preserves the inner product, i.e if and only if (x, y) = (U x, U y) ∀x, y ∈ X. Proof. The proof uses the polarization identities (Lemma 1.9). For exam- ple, if X is a complex space (U x, U y) = 1 4 ∑ α=±1,±i α∥U x + αU y∥2 = 1 4 ∑ α=±1,±i α∥U (x + αy)∥2 = 1 4 ∑ α=±1,±i α∥x + αy∥2 = (x, y). 6. Isometries and unitary operators. Unitary and orthogonal matrices. 147 Similarly, for a real space X (U x, U y) = 1 4 (∥U x + U y∥ 2 − ∥U x − U y∥2) = 1 4 (∥U (x + y)∥ 2 − ∥U (x − y)∥2) = 1 4 (∥x + y∥2 − ∥x − y∥ 2) = (x, y). □ Lemma 6.2. An operator U : X → Y is an isometry if and only if U ∗U = I. Proof. If U ∗U = I, then by the deﬁnition of adjoint operator (x, x) = (U ∗U x, x) = (U x, U x) ∀x ∈ X. Therefore ∥x∥ = ∥U x∥, and so U is an isometry. On the other hand, if U is an isometry, then by the deﬁnition of adjoint operator and by Theorem 6.1 we have for all x ∈ X (U ∗U x, y) = (U x, U y) = (x, y) ∀y ∈ X, and therefore by Corollary 1.5 U ∗U x = x. Since it is true for all x ∈ X, we have U ∗U = I. □ The above lemma implies that an isometry is always left invertible (U ∗ being a left inverse). Deﬁnition. An isometry U : X → Y is called a unitary operator if it is invertible. Proposition 6.3. An isometry U : X → Y is a unitary operator if and only if dim X = dim Y . Proof. Since U is an isometry, it is left invertible, and since dim X = dim Y , it is invertible (a left invertible square matrix is invertible). On the other hand, if U : X → Y is invertible, dim X = dim Y (only square matrices are invertible, isomorphic spaces have equal dimensions). □ A square matrix U is called unitary if U ∗U = I, i.e. a unitary matrix is a matrix of a unitary operator acting in Fn. A unitary matrix with real entries is called an orthogonal matrix. An orthogonal matrix can be interpreted a matrix of a unitary operator acting in the real space Rn. Few properties of unitary operators: 1. For a unitary transformation U , U −1 = U ∗; 148 5. Inner product spaces 2. If U is unitary, U ∗ = U −1 is also unitary; 3. If U is a isometry, and v1, v2, . . . , vn is an orthonormal basis, then U v1, U v2, . . . , U vn is an orthonormal system. Moreover, if U is unitary, U v1, U v2, . . . , U vn is an orthonormal basis. 4. A product of unitary operators is a unitary operator as well. 6.2. Examples. First of all, let us notice, that a matrix U is an isometry if and only if its columns form an or- thonormal system. This statement can be checked directly by computing the product U ∗U . It is easy to check that the columns of the rotation matrix ( cos α − sin α sin α cos α ) are orthogonal to each other, and that each column has norm 1. Therefore, the rotation matrix is an isometry, and since it is square, it is unitary. Since all entries of the rotation matrix are real, it is an orthogonal matrix. The next example is more abstract. Let X and Y be inner product spaces, dim X = dim Y = n, and let x1, x2, . . . , xn and y1, y2, . . . , yn be orthonormal bases in X and Y respectively. Deﬁne an operator U : X → Y by U xk = yk, k = 1, 2, . . . , n. Since for a vector x = c1x1 + c2x2 + . . . + cnxn ∥x∥ 2 = |c1| 2 + |c2| 2 + . . . + |cn| 2 and ∥U x∥2 = ∥U ( n∑ k=1 ckxk)∥ 2 = ∥ n∑ k=1 ckyk∥2 = n∑ k=1 |ck|2, one can conclude that ∥U x∥ = ∥x∥ for all x ∈ X, so U is a unitary operator. 6.3. Properties of unitary operators. Proposition 6.4. Let U be a unitary matrix. Then 1. | det U | = 1. In particular, for an orthogonal matrix det U = ±1; 2. If λ is an eigenvalue of U , then |λ| = 1 Remark. Note, that for an orthogonal matrix, an eigenvalue (unlike the determinant) does not have to be real. Our old friend, the rotation matrix gives an example. 6. Isometries and unitary operators. Unitary and orthogonal matrices. 149 Proof of Proposition 6.4. Let det U = z. Since det(U ∗) = det(U ), see Problem 5.1, we have |z|2 = zz = det(U ∗U ) = det I = 1, so | det U | = |z| = 1. Statement 1 is proved. To prove statement 2 let us notice that if U x = λx then ∥U x∥ = ∥λx∥ = |λ| · ∥x∥, so |λ| = 1. □ 6.4. Unitary equivalent operators. Deﬁnition. Operators (matrices) A and B are called unitarily equivalent if there exists a unitary operator U such that A = U BU ∗. Since for a unitary U we have U −1 = U ∗, any two unitary equivalent matrices are similar as well. The converse is not true, it is easy to construct a pair of similar matrices, which are not unitarily equivalent. The following proposition gives a way to construct a counterexample. Proposition 6.5. A matrix A is unitarily equivalent to a diagonal one if and only if it has an orthogonal (orthonormal) basis of eigenvectors. Proof. Let A = U BU ∗ and let Bx = λx. Then AU x = U BU ∗U x = U Bx = U (λx) = λU x, i.e. U x is an eigenvector of A. So, let A be unitarily equivalent to a diagonal matrix D, i.e. let A = U DU ∗. The vectors ek of the standard basis are eigenvectors of D, so the vectors U ek are eigenvectors of A. Since U is unitary, the system U e1, U e2, . . . , U en is an orthonormal basis. Now let A has an orthogonal basis u1, u2, . . . , un of eigenvectors. Divid- ing each vector uk by its norm if necessary, we can always assume that the system u1, u2, . . . , un is an orthonormal basis. Let D be the matrix of A in the basis B = u1, u2, . . . , un. Clearly, D is a diagonal matrix. Denote by U the matrix with columns u1, u2, . . . , un. Since the columns form an orthonormal basis, U is unitary. The standard change of coordinate formula implies A = [A] SS = [I] SB [A]BB [I] BS = U DU −1 and since U is unitary, A = U DU ∗. □ 150 5. Inner product spaces Exercises. 6.1. Orthogonally diagonalize the following matrices, ( 1 2 2 1 ) , ( 0 −1 1 0 ) ,   0 2 2 2 0 2 2 2 0   i.e. for each matrix A ﬁnd a unitary matrix U and a diagonal matrix D such that A = U DU ∗ 6.2. True or false: a matrix is unitarily equivalent to a diagonal one if and only if it has an orthogonal basis of eigenvectors. 6.3. Prove the polarization identities (Ax, y) = 1 4 [ (A(x + y), x + y) − (A(x − y), x − y) ] (real case, A = A∗), and (Ax, y) = 1 4 ∑ α=±1,±i α(A(x + αy), x + αy) (complex case, A is arbitrary). 6.4. Show that a product of unitary (orthogonal) matrices is unitary (orthogonal) as well. 6.5. Let U : X → X be a linear transformation on a ﬁnite-dimensional inner product space. True or false: a) If ∥U x∥ = ∥x∥ for all x ∈ X, then U is unitary. b) If ∥U ek∥ = ∥ek∥, k = 1, 2 . . . , n for some orthonormal basis e1, e2, . . . , en, then U is unitary. Justify your answers with a proof or a counterexample. 6.6. Let A and B be unitarily equivalent n × n matrices. a) Prove that trace(A∗A) = trace(B∗B). b) Use a) to prove that n∑ j,k=1 |Aj,k|2 = n∑ j,k=1 |Bj,k| 2. c) Use b) to prove that the matrices ( 1 2 2 i ) and ( i 4 1 1 ) are not unitarily equivalent. 6.7. Which of the following pairs of matrices are unitarily equivalent: a) ( 1 0 0 1 ) and ( 0 1 1 0 ). b) ( 0 1 1 0 ) and ( 0 1/2 1/2 0 ). 7. Rigid motions in Rn 151 c)   0 1 0 −1 0 0 0 0 1   and   2 0 0 0 −1 0 0 0 0  . d)   0 1 0 −1 0 0 0 0 1   and   1 0 0 0 −i 0 0 0 i  . e)   1 1 0 0 2 2 0 0 3   and   1 0 0 0 2 0 0 0 3  . Hint: It is easy to eliminate matrices that are not unitarily equivalent: remember, that unitarily equivalent matrices are similar, and trace, determinant and eigenval- ues of similar matrices coincide. Also, the previous problem helps in eliminating non unitarily equivalent matri- ces. Finally, a matrix is unitarily equivalent to a diagonal one if and only if it has an orthogonal basis of eigenvectors. 6.8. Let U be a 2 × 2 orthogonal matrix with det U = 1. Prove that U is a rotation matrix. 6.9. Let U be a 3 × 3 orthogonal matrix with det U = 1. Prove that a) 1 is an eigenvalue of U . b) If v1, v2, v3 is an orthonormal basis, such that U v1 = v1 (remember, that 1 is an eigenvalue), then in this basis the matrix of U is   1 0 0 0 cos α − sin α 0 sin α cos α   , where α is some angle. Hint: Show, that since v1 is an eigenvector of U , all entries below 1 must be zero, and since v1 is also an eigenvector of U ∗ (why?), all entries right of 1 also must be zero. Then show that the lower right 2 × 2 matrix is an orthogonal one with determinant 1, and use the previous problem. 7. Rigid motions in Rn A rigid motion in an inner product space V is a transformation f : V → V preserving the distance between point, i.e. such that ∥f (x) − f (y)∥ = ∥x − y∥ ∀x, y ∈ V. Note, that in the deﬁnition we do not assume that the transformation f is linear. Clearly, any unitary transformation is a rigid motion. Another example of a rigid motion is a translation (shift) by a ∈ V , f (x) = x + a. 152 5. Inner product spaces The main result of this section is the following theorem, stating that any rigid motion in a real inner product space is a composition of an orthogonal transformation and a translation. Theorem 7.1. Let f be a rigid motion in a real inner product space X, and let T (x) := f (x) − f (0). Then T is an orthogonal transformation. To prove this theorem we need the following simple lemma. Lemma 7.2. Let T be as deﬁned in Theorem 7.1. Then for all x, y ∈ X 1. ∥T x∥ = ∥x∥; 2. ∥T (x) − T (y)∥ = ∥x − y∥; 3. (T (x), T (y)) = (x, y). Proof. To prove statement 1 notice that ∥T (x)∥ = ∥f (x) − f (0)∥ = ∥x − 0∥ = ∥x∥. Statement 2 follows from the following chain of identities: ∥T (x) − T (y)∥ = ∥(f (x) − f (0)) − (f (y) − f (0))∥ = ∥f (x) − f (y)∥ = ∥x − y∥. An alternative explanation would that T is a composition of 2 rigid motions (f followed by the translation by a = −f (0)), and one can easily see that a composition of rigid motions is a rigid motion. Since T (0) = 0, and so ∥T (x)∥ = ∥T (x) − T (0)∥, statement 1 can be treated as a particular case of statement 2. To prove statement 3, let us notice that in a real inner product space ∥T (x) − T (y)∥2 = ∥T (x)∥2 + ∥T (y)∥2 − 2(T (x), T (y)), and ∥x − y∥2 = ∥x∥2 + ∥y∥2 − 2(x, y). Recalling that ∥T (x) − T (y)∥ = ∥x − y∥ and ∥T (x)∥ = ∥x∥, ∥T (y)∥ = ∥y∥, we immediately get the desired conclusion. □ Proof of Theorem 7.1. First of all notice that for all x ∈ X ∥T (x)∥ = ∥f (x) − f (0)∥ = ∥x − 0∥ = ∥x∥, so T preserves the norm, ∥T x∥ = ∥x∥. We would like to say that the identyty ∥T x∥ = ∥x∥ means T is an isometry, but to be able to say that we need to prove that T is a linear transformation. To do that, let us ﬁx an orthonormal basis e1, e2, . . . , en in X, and let bk := T (ek), k = 1, 2, . . . , n. Since T preserves the inner product (statement 7. Rigid motions in Rn 153 3 of Lemma 7.2), we can conclude that b1, b2, . . . , bn is an orthonormal system. In fact, since dim X = n (because basis e1, e2, . . . , en consists of n vectors), we can conclude that b1, b2, . . . , bn is an orthonormal basis. Let x = ∑n k=1 αkek. Recall that by the abstract orthogonal Fourier decomposition (2.2) we have that αk = (x, ek). Applying the abstract or- thogonal Fourier decomposition (2.2) to T (x) and the orthonormal basis b1, b2, . . . , bn we get T (x) = n∑ k=1(T (x), bk)bk. Since (T (x), bk) = (T (x), T (ek)) = (x, ek) = αk, we get that T ( n∑ k=1 αkek) = n∑ k=1 αkbk. This means that T is a linear transformation whose matrix with respect to the bases S := e1, e2, . . . , en and B := b1, b2, . . . , bn is identity matrix, [T ] B,S = I. An alternative way to show that T is a linear transformation is the following direct calculation ∥T (x + αy) − (T (x) + αT (y))∥ 2 = ∥(T (x + αy) − T (x)) − αT (y)∥2 = ∥T (x + αy) − T (x)∥2 + α2∥T (y)∥ 2 − 2α(T (x + αy) − T (x), T (y)) = ∥x + αy − x∥2 + α2∥y∥ 2 − 2α(T (x + αy), T (y)) + 2α(T (x), T (y)) = α2∥y∥ 2 + α2∥y∥2 − 2α(x + αy, y) + 2α(x, y) = 2α2∥y∥2 − 2α(x, y) − 2α2(y, y) + 2α(x, y) = 0 Therefore T (x − αy) = T (x) + αT (y), which implies that T is linear (taking x = 0 or α = 1 we get two properties from the deﬁnition of a linear transformation). So, T is a linear transformation satisfying ∥T x∥ = ∥x∥, i.e. T is an isometry. Since T : X → X, T is unitary transformation (see Proposition 6.3). That completes the proof, since an orthogonal transformation is simply a unitary transformation in a real inner product space. □ Exercises. 7.1. Give an example of a rigid motion T in Cn, T (0) = 0, which is not a linear transformation. 154 5. Inner product spaces 8. Complexiﬁcation and decomplexiﬁcation This section is probably a bit more abstract than the rest of the chapter, and can be skipped at the ﬁrst reading. 8.1. Decomplexiﬁcation. 8.1.1. Decomplexiﬁcation of a vector space. Any complex vector space can be interpreted a real vector space: we just need to forget that we can multiply vectors by complex numbers and act as only multiplication by real numbers is allowed. For example, the space Cn is canonically identiﬁed with the real space R2n: each complex coordinate zk = xk + iyk gives us 2 real ones xk and yk. “Canonically” here means that this is a standard, most natural way of identifying Cn and R2n. Note, that while the above deﬁnition gives us a canonical way to get real coordinates from complex ones, it does not say anything about ordering real coordinates. In fact, there are two standard ways to order the coordinates xk, yk. One way is to take ﬁrst the real parts and then the imaginary parts, so the ordering is x1, x2, . . . , xn, y1, y2, . . . , yn. The other standard alternative is the ordering x1, y1, x2, y2, . . . , xn, yn. The material of this section does not depend on the choice of ordering of coordinates, so the reader does not have to worry about picking an ordering. 8.1.2. Decomplexiﬁcation of an inner product. It turns out that if we are given a complex inner product (in a complex space), we can in a canonical way get a real inner product from it. To see how we can do that, let as ﬁrst consider the above example of Cn canonically identiﬁes with R2n. Let (x, y) C denote the standard inner product in Cn, and (x, y) R be the standard inner product in R2n (note that the standard inner product in Rn does not depend on the ordering of coordinates). Then (see Exercise 8.1 below) (8.1) (x, y) R = Re(x, y)C This formula can be used to canonically deﬁne a real inner product from the complex one in general situation. Namely, it is an easy exercise to show that if (x, y)C is an inner product in a complex inner product space, then (x, y) R deﬁned by (8.1) is a real inner product (on the corresponding real space). Summarizing we can say that To decomplexify a complex inner product space we simply “for- get” that we can multiply by complex numbers, i.e. we only allow multiplication by reals. The canonical real inner product in the decomplexiﬁed space is given by formula (8.1) 8. Complexiﬁcation and decomplexiﬁcation 155 Remark. Any (complex) linear linear transformation on Cn (or, more gen- erally, on a complex vector space) gives as a real linear transformation: it is simply the fact that if T (αx + βy) = αT x + βT y holds for α, β ∈ C, then it of course holds for α, β ∈ R. The converse is not true, i.e. a (real) linear transformation on the de- complexiﬁcation R2n of Cn does not always give a (complex) linear trans- formation of Cn (the same in the abstract settings). For example, if one considers the case n = 1, then the multiplication by a complex number z (general form of a linear transformation in C1) treated as a linear transformation in R2 has a very speciﬁc structure (can you describe it?). 8.2. Complexiﬁcation. We can also do a converse, namely get a complex inner product space from a real one: in fact, you probably already did it before, without paying much attention to it. Namely, given a real inner product space Rn we can obtain a complex space Cn out of it by allowing complex coordinates (with the standard inner product in both cases). The space Rn in this case will be a real 2subspace of Cn consisting of vectors with real coordinates. Abstractly, this construction can be described as follows: given a real vector space X we can deﬁne its complexiﬁcation X C as the collection of all pairs [x1, x2], x1, x2 ∈ X with the addition and multiplication by a real number α are deﬁned coordinate-wise, [x1, x2] + [y1, y2] = [x1 + y1, x2 + y2], α[x1, x2] = [αx1, αx2]. If X = Rn then the vector x1 consists of real parts of complex coordinates of Cn and the vector x2 of the imaginary parts. Thus informally one can write the pair [x1, x2] as x1 + ix2. To deﬁne multiplication by complex numbers we deﬁne multiplication by i as i[x1, x2] = [−x2, x1] (writing [x1, x2] as x2 + ix2 we can see that it must be deﬁned this way) and deﬁne multiplication by arbitrary complex numbers using second distributive property (α + β)v = αv + βv. If, in addition, X is an inner product space we can extend the inner product to X C by ([x1, x2], [y1, y2]) XC = (x1, y1)X + (x2, y2)X ; The easiest way to see that everything is well deﬁned, is to ﬁx a basis (an orthonormal basis in the case of a real inner product space) and see what 2Real subspace mean the set closed with respect to sum and multiplication by real numbers 156 5. Inner product spaces this construction gives us in coordinates. Then we can see that if we treat vector x1 as the vector consisting of the real parts of complex coordinates, and vector x2 as the vector consisting of imaginary parts of coordinates, then this construction is exactly the standard complexiﬁcation of Rn (by allowing complex coordinates) described above. The fact that we can express this construction in coordinate-free way, without picking a basis and working with coordinates, means that the result does not depend on the choice of a basis. So, the easiest way to think about complexiﬁcation is probably as follows: To construct a complexiﬁcation of a real vector space X we can pick a basis (an orthonormal basis if X is a real inner product space) and then work with coordinates, allowing the complex ones. The resulting space does not depend on the choice of a basis; we can get from one coordinates to the others by the standard change of coordinate formula. Note, that any linear transformation T in the real space X gives rise to a linear transformation T C in the complexiﬁcation X C. The easiest way to see that is to ﬁx a basis in X (an orthonormal basis if X is a real inner product space) and to work in a coordinate representation: in this case T C has the same matrix as T . In the abstract representation we can write T C[x1, x2] = [T x1, T x2]. On the other hand, not all linear transformations in X C can be obtained from the transformations in X; if we do complexiﬁcation in coordinates, only the transformations with real matrices work. Note, that this is completely opposite to the situation in the case of decomplexiﬁcation, described in Section 8.1. An attentive reader probably already noticed that the operations of com- plexiﬁcation and decomplixiﬁcation are not the inverse of each other. First, the space and its complexiﬁcation have the same dimension, while the de- complixiﬁcation of an n-dimensional space has dimension 2n. Moreover, as we just discussed, the relation between real and complex linear transforma- tions is completely opposite in these cases. In the next section we discuss the operation, inverse in some sense to decomplexiﬁcation. 8.3. Introducing complex structure to a real space. The construction described in this section works only for real spaces of even dimension. 8.3.1. An elementary way to introduce a complex structure. Let X be a real inner product space of dimension 2n. We want invert the decomplexiﬁcation 8. Complexiﬁcation and decomplexiﬁcation 157 procedure to introduce a complex structure on X, i.e. to identify this space with a complex space such that its decomplexiﬁcation (see Section 8.1) give us the original space X. The simplest idea is to ﬁx an orthonormal basis in X and then split the coordinates in this basis into two equal parts. We than treat one half of the coordinates (say coordinates x1, x2, . . . , xn) as real parts of complex coordinates, and treat the rest as the imaginary parts. Then we have to join real and imaginary parts together: for example if we treat x1, x2, . . . , xn as real parts and xn+1, xn+2, . . . , x2n as imaginary parts, we can deﬁne complex coordinates zk = xk + ixn+k. Of course, the result will generally depend on the choice of the orthonor- mal basis and on the way we split the real coordinates into real and imagi- nary parts and on how we join them. One can also see from the decomplexiﬁcation construction described in Section 8.1 that all complex structures on a real inner product space X can be obtained in this way. 8.3.2. From elementary to abstract construction of complex structure. The above construction can be described in an abstract, coordinate-free way. Namely, let us split the space X as X = E ⊕ E⊥, where E is a subspace, dim E = n (so dim E⊥ = n as well), and let U0 : E → E⊥ be a unitary (more precisely, orthogonal, since our spaces are real) transformation. Note, that if v1, v2, . . . , vn is an orthonormal basis in E, then the system U0v1, U0v2, . . . , U0vn is an orthonormal basis in E⊥, so v1, v2, . . . , vn, U0v1, U0v2, . . . , U0vn is an orthonormal basis in the whole space X. If x1, x2, . . . , x2n are coordinates of a vector x in this basis, and we treat xk + ixn+k, k = 1, 2, . . . , n as complex coordinates of x, then the multiplication by i is represented by the orthogonal transformation U which is given in the orthogonal basis of subspaces E, E⊥ by the block matrix U = ( 0 −U ∗ 0 U0 0 ) . This means that i ( x1 x2 ) = U ( x1 x2 ) = ( 0 −U ∗ 0 U0 0 ) ( x1 x2 ) x1 ∈ E, x2 ∈ E⊥. Clearly, U is an orthogonal transformation such that U 2 = −I. There- fore, any complex structure on X is given by an orthogonal transformation U , satisfying U 2 = −I; the transformation U gives us the multiplication by the imaginary unit i. 158 5. Inner product spaces The converse is also true, namely any orthogonal transformation U sat- isfying U 2 = −I deﬁnes a complex structure on a real inner product space X. Let us explain how. 8.3.3. An abstract construction of complex structure. Let us ﬁrst consider an abstract explanation. To deﬁne a complex structure, we need to deﬁne the multiplication of vectors by complex numbers (initially we only can multiply by real numbers). In fact we need only to deﬁne the multiplication by i, the rest will follow from linearity in the original real space. And the multiplication by i is given by the orthogonal transformation U satisfying U 2 = −I. Namely, if the multiplication by i is given by U , ix = U x, then the complex multiplication must be deﬁned by (8.2) (α + βi)x := αx + βU x = (αI + βU )x, α, β ∈ R, x ∈ X. We will use this formula now as the deﬁnition of complex multiplication. It is not hard to check that for the complex multiplication deﬁned above by (8.2) all axioms of comples wector space are satisﬁed. One can see that, for example by using linearity in the real space X and noticing that that with respect to algebraic operations (addition and multiplication) the linear transformations of form αI = βU, α, β ∈ R, behave absolutely the same way as complex numbers α + βi, i.e such trans- formations give us a representation of the ﬁeld of complex numbers C. This means that ﬁrst, a sum and a product of transformations of the form αI + βU is a transformation of the same form, and to get the coeeﬁcients α, β of the result we can perform the operation on the corresponding complex numbers and take the real and imaginary parts of the result. Note, that here we need the identity U 2 = −I, but we do not need the fact that U is an orthogonal transformation. Thus, we got the structure of a complex vector space. To get a complex inner product space we need to introduce complex inner product, such that the original real inner product is the real part of it. We really do not have nay choice here: noticing that for a complex inner product Im(x, y) = Re [−i(x, y)R] = Re(x, iy) R, we see that the only way to deﬁne the complex inner product is (8.3) (x, y) C := (x, y) R + i(x, U y) R. 8. Complexiﬁcation and decomplexiﬁcation 159 Let us show that this is indeed an inner product. We will need the fact that U ∗ = −U , see Exercise 8.4 below (by U ∗ here we mean the adjoint with respect to the original real inner product). To show that (y, x)C = (x, y)C we use the udentity U ∗ = −U and symmetry of the real inner product: (y, x)C = (y, x)R + i(y, U x) = (x, y)R + i(U x, y) R = (x, y)R − i(x, U y) R = (x, y)R + i(x, U y) R = (x, y)C. To prove the linearity of the complex inner product, let us ﬁrst notice that (x, y) C is real linear in the ﬁrst (in fact in each) argument, i.e. that (αx + βy, z)C = α(x, z) C + β(y, z) C for α, β ∈ R; this is true because each summand in the right side of (8.3) is real linear in argument. Using real linearity of (x, y) C and the identity U ∗ = −U (which implies that (U x, y) R = −(x, U y)R) together with the orthogonality of U , we get the following chain of equalities ((αI + βU )x, y)C = α(x, y) C + β(U x, y) C = α(x, y) C + β [(U x, y)R + i(U x, U y) R] = α(x, y) C + β [−(x, U y) R + i(x, y) R] = α(x, y) C + βi [ (x, y) R + i(x, U y)R] = α(x, y) C + βi(x, y) C = (α + βi)(x, y)C, which proves complex linearity. Finally, to prove non-negativity of (x, x) C let us notice (see Exercise 8.3 below) that (x, U x)R = 0, so (x, x) C = (x, x)R = ∥x∥2 ≥ 0. 8.3.4. The abstract construction via the elementary one. For a reader who is not comfortable with such “high brow” and abstract proof, there is another, more hands on, explanation. Namely, it can be shown, see Exercise 8.5 below, that there exists a subspace E, dim E = n (recall that dim X = 2n), such that the matrix of U with respect to the decomposition X = E ⊕ E⊥ is given by U = ( 0 −U ∗ 0 U0 0 ) , where U0 : E → E⊥ is some orthogonal transformation. 160 5. Inner product spaces Let v1, v2, . . . , vn be an orthonormal basis in E. Then the system U0v1, U0v2, . . . , U0vn is an orthonormal basis in E⊥, so v1, v2, . . . , vn, U0v1, U0v2, . . . , U0vn is an orthonormal basis in the whole space X. Considering the coordinates x1, x2, . . . , x2n in this basis and treating xk + ixn+k as complex coordinates, we get an elementary, “coordinate” way of deﬁning complex structure, which was already described above. But if we look carefully, we see that multipli- cation by i is given by the transformation U : it is trivial for x ∈ E and for y ∈ E⊥, and so it is true for all real linear combinations of αx + βy, i.e. for all vectors in X. But that means that the abstract introduction of complex structure and the corresponding elementary approach give us the same result! And since the elementary approach clearly gives us the a complex structure, the abstract approach gives us the same complex structure. Exercises. 8.1. Prove formula (8.1). Namely, show that if x = (z1, z2, . . . , zn) T , y = (w1, w2, . . . , wn) T , zk = xk + iyk, wk = uk + ivk, xk, yk, uk, vk ∈ R, then Re( n∑ k=1 zkwk) = n∑ k=1 xkuk + n∑ k=1 ykvk. 8.2. Show that if (x, y)C is an inner product in a complex inner product space, then (x, y) R deﬁned by (8.1) is a real inner product space. 8.3. Let U be an orthogonal transformation (in a real inner product space X), satisfying U 2 = −I. Prove that for all x ∈ X U x ⊥ x. 8.4. Show, that if U is an orthogonal transformation satisfying U 2 = −I, then U ∗ = −U . 8.5. Let U be an orthogonal transformation in a real inner product space, satisfying U 2 = −I. Show that in this case dim X = 2n, and that there exists a subspace E ⊂ X, dim E = n, and an orthogonal transformation U0 : E → E⊥ such that U in the decomposition X = E ⊕ E⊥ is given by the block matrix U = ( 0 −U ∗ 0 U0 0 ) . This statement can be easily obtained from Theorem 5.1 of Chapter 6, if one notes that the only rotation Rα in R2 satisfying R2 α = −I are rotations through α = ±π/2. However, one can ﬁnd an elementary proof here, not using this theorem. For example, the statement is trivial if dim X = 2: in this case we can take for E any one-dimensional subspace, see Exercise 8.3. 8. Complexiﬁcation and decomplexiﬁcation 161 Then it is not hard to show, that such operator U does not exists in R2, and one can use induction in dim X to complete the proof. Chapter 6 Structure of operators in inner product spaces. In this chapter we are again assuming that all spaces are ﬁnite-dimensional. Again, we are dealing only with complex or real spaces, theory of inner product spaces does not apply to spaces over general ﬁelds. When we are not mentioning what space are we in, everything work for both complex and real spaces. To avoid writing essentially the same formulas twice we will use the notation for the complex case: in the real case it give correct, although sometimes a bit more complicated, formulas. 1. Upper triangular (Schur) representation of an operator. Theorem 1.1. Let A : X → X be an operator acting in a complex inner product space. There exists an orthonormal basis u1, u2, . . . , un in X such that the matrix of A in this basis is upper triangular. In other words, any n × n matrix A can be represented as A = U T U ∗, where U is a unitary, and T is an upper triangular matrix. Proof. We prove the theorem using the induction in dim X. If dim X = 1 the theorem is trivial, since any 1 × 1 matrix is upper triangular. Suppose we proved that the theorem is true if dim X = n − 1, and we want to prove it for dim X = n. 163 164 6. Structure of operators in inner product spaces. Let λ1 be an eigenvalue of A, and let u1, ∥u1∥ = 1 be a corresponding eigenvector, Au1 = λ1u1. Denote E = u⊥ 1 , and let v2, . . . , vn be some orthonormal basis in E (clearly, dim E = dim X−1 = n−1), so u1, v2, . . . , vn is an orthonormal basis in X. In this basis the matrix of A has the form (1.1)      λ1 ∗ 0 ... A1 0  | | |  ; here all entries below λ1 are zeroes, and ∗ means that we do not care what entries are in the ﬁrst row right of λ1. We do care enough about the lower right (n − 1) × (n − 1) block, to give it name: we denote it as A1. Note, that A1 deﬁnes a linear transformation in E, and since dim E = n − 1, the induction hypothesis implies that there exists an orthonormal basis (let us denote it as u2, . . . , un) in which the matrix of A1 is upper triangular. So, matrix of A in the orthonormal basis u1, u2, . . . , un has the form (1.1), where matrix A1 is upper triangular. Therefore, the matrix of A in this basis is upper triangular as well. □ Remark. Note, that the subspace E = u ⊥ 1 introduced in the proof is not invariant under A, i.e. the inclusion AE ⊂ E does not necessarily hold. That means that A1 is not a part of A, it is some operator constructed from A. Note also, that AE ⊂ E if and only if all entries denoted by ∗ (i.e. all entries in the ﬁrst row, except λ1) are zero. Remark. Note, that even if we start from a real matrix A, the matrices U and T can have complex entries. The rotation matrix ( cos α − sin α sin α cos α ) , α ̸= kπ, k ∈ Z is not unitarily equivalent (not even similar) to a real upper triangular ma- trix. Indeed, eigenvalues of this matrix are complex, and the eigenvalues of an upper triangular matrix are its diagonal entries. Remark. An analogue of Theorem 1.1 can be stated and proved for an arbitrary vector space, without requiring it to have an inner product. In this case the theorem claims that any operator have an upper triangular form in some basis. A proof can be modeled after the proof of Theorem 1.1. An alternative way is to equip V with an inner product by ﬁxing a basis in V and declaring it to be an orthonormal one, see Problem 2.4 in Chapter 5. 2. Spectral theorem for self-adjoint and normal operators. 165 Note, that the version for inner product spaces (Theorem 1.1) is stronger than the one for the vector spaces, because it says that we always can ﬁnd an orthonormal basis, not just a basis. The following theorem is a real-valued version of Theorem 1.1 Theorem 1.2. Let A : X → X be an operator acting in a real inner product space. Suppose that all eigenvalues of A are real (meaning that A has exactly n = dim X real eigenvalues, counting multiplicities). Then there exists an orthonormal basis u1, u2, . . . , un in X such that the matrix of A in this basis is upper triangular. In other words, any real n × n matrix A with all real eigenvalues can be represented as T = U T U ∗ = U T U T , where U is an orthogonal, and T is a real upper triangular matrices. Proof. To prove the theorem we just need to analyze the proof of Theorem 1.1. Let us assume (we can always do this without loss of generality) that the operator (matrix) A acts in Rn. Suppose, the theorem is true for (n − 1) × (n − 1) matrices. As in the proof of Theorem 1.1 let λ1 be a real eigenvalue of A, u1 ∈ Rn, ∥u1∥ = 1 be a corresponding eigenvector, and let v2, . . . , vn be on orthonormal system (in Rn) such that u1, v2, . . . , vn is an orthonormal basis in Rn. The matrix of A in this basis has form (1.1), where A1 is some real matrix. If we can prove that matrix A1 has only real eigenvalues, then we are done. Indeed, then by the induction hypothesis there exists an orthonormal basis u2, . . . , un in E = u⊥ 1 such that the matrix of A1 in this basis is upper triangular, so the matrix of A in the basis u1, u2, . . . , un is also upper triangular. To show that A1 has only real eigenvalues, let us notice that det(A − λI) = (λ1 − λ) det(A1 − λ) (take the cofactor expansion in the ﬁrst row, for example), and so any eigen- value of A1 is also an eigenvalue of A. But A has only real eigenvalues! □ Exercises. 1.1. Use the upper triangular representation of an operator to give an alternative proof of the fact that determinant is the product and the trace is the sum of eigenvalues counting multiplicities. 2. Spectral theorem for self-adjoint and normal operators. In this section we deal with matrices (operators) which are unitarily equiv- alent to diagonal matrices. 166 6. Structure of operators in inner product spaces. Let us recall that an operator is called self-adjoint if A = A∗. A matrix of a self-adjoint operator (in some orthonormal basis), i.e. a matrix satisfying A∗ = A is called a Hermitian matrix. The terms self-adjoint and Hermitian essentially mean the same. Usu- ally people say self-adjoint when speaking about operators (transforma- tions), and Hermitian when speaking about matrices. We will try to follow this convention, but since we often do not distinguish between operators and their matrices, we will sometimes mix both terms. Theorem 2.1. Let A = A∗ be a self-adjoint operator in an inner product space X (the space can be complex or real). Then all eigenvalues of A are real, and there exists and orthonormal basis of eigenvectors of A in X. This theorem can be restated in matrix form as follows Theorem 2.2. Let A = A∗ be a self-adjoint (and therefore square) matrix. Then A can be represented as A = U DU ∗, where U is a unitary matrix and D is a diagonal matrix with real entries. Moreover, if the matrix A is real, matrix U can be chosen to be real (i.e. orthogonal). Proof. To prove Theorems 2.1 and 2.2 let us ﬁrst apply Theorem 1.1 (The- orem 1.2 if X is a real space) to ﬁnd an orthonormal basis in X such that the matrix of A in this basis is upper triangular. Now let us ask ourself a question: What upper triangular matrices are self-adjoint? The answer is immediate: an upper triangular matrix is self-adjoint if and only if it is a diagonal matrix with real entries. Theorem 2.1 (and so Theorem 2.2) is proved. □ Remark. In many textbooks only real matrices are considered, and The- orem 2.2 is often called the “Spectral Theorem for symmetric matrices”. However, we should emphasize that the conclusion of Theorem 2.2 fails for complex symmetric matrices: the theorem holds for Hermitian matrices, and in particular for real symmetric matrices. Let us give an independent proof to the fact that eigenvalues of a self- adjoint operators are real. Let A = A∗ and Ax = λx, x ̸= 0. Then (Ax, x) = (λx, x) = λ(x, x) = λ∥x∥2. On the other hand, (Ax, x) = (x, A ∗x) = (x, Ax) = (x, λx) = λ(x, x) = λ∥x∥2, 2. Spectral theorem for self-adjoint and normal operators. 167 so λ∥x∥2 = λ∥x∥2. Since ∥x∥ ̸= 0 (x ̸= 0), we can conclude λ = λ, so λ is real. It also follows from Theorem 2.1 that eigenspaces of a self-adjoint oper- ator are orthogonal. Let us give an alternative proof of this result. Proposition 2.3. Let A = A∗ be a self-adjoint operator, and let u, v be its eigenvectors, Au = λu, Av = µv. Then, if λ ̸= µ, the eigenvectors u and v are orthogonal. Proof. This proposition follows from the spectral theorem (Theorem 1.1), but here we are giving a direct proof. Namely, (Au, v) = (λu, v) = λ(u, v). On the other hand (Au, v) = (u, A ∗v) = (u, Av) = (u, µv) = µ(u, v) = µ(u, v) (the last equality holds because eigenvalues of a self-adjoint operator are real), so λ(u, v) = µ(u, v). If λ ̸= µ it is possible only if (u, v) = 0. □ Now let us try to ﬁnd what matrices are unitarily equivalent to a diagonal one. It is easy to check that for a diagonal matrix D D∗D = DD∗. Therefore A∗A = AA∗ if the matrix of A in some orthonormal basis is diagonal. Deﬁnition. An operator (matrix) N is called normal if N ∗N = N N ∗. Clearly, any self-adjoint operator (A∗A = AA∗) is normal. Also, any unitary operator U : X → X is normal since U ∗U = U U ∗ = I. Note, that a normal operator is an operator acting in one space, not from one space to another. So, if U is a unitary operator acting from one space to another, we cannot say that U is normal. Theorem 2.4. Any normal operator N in a complex vector space has an orthonormal basis of eigenvectors. In other words, any matrix N satisfying N ∗N = N N ∗ can be represented as N = U DU ∗, where U is a unitary matrix, and D is a diagonal one. Remark. Note, that in the above theorem even if N is a real matrix, we did not claim that matrices U and D are real. Moreover, it can be easily shown, that if D is real, N must be self-adjoint. 168 6. Structure of operators in inner product spaces. Proof of Theorem 2.4. To prove Theorem 2.4 we apply Theorem 1.1 to get an orthonormal basis, such that the matrix of N in this basis is upper triangular. To complete the proof of the theorem we only need to show that an upper triangular normal matrix must be diagonal. We will prove this using induction in the dimension of matrix. The case of 1 × 1 matrix is trivial, since any 1 × 1 matrix is diagonal. Suppose we have proved that any (n − 1) × (n − 1) upper triangular normal matrix is diagonal, and we want to prove it for n × n matrices. Let N be n × n upper triangular normal matrix. We can write it as N =      a1,1 a1,2 . . . a1,n 0 ... N1 0  | | |  where N1 is an upper triangular (n − 1) × (n − 1) matrix. Let us compare upper left entries (ﬁrst row ﬁrst column) of N ∗N and N N ∗. Direct computation shows that that (N ∗N )1,1 = a1,1a1,1 = |a1,1| 2 and (N N ∗)1,1 = |a1,1| 2 + |a1,2|2 + . . . + |a1,n|2. So, (N ∗N )1,1 = (N N ∗)1,1 if and only if a1,2 = . . . = a1,n = 0. Therefore, the matrix N has the form N =      a1,1 0 . . . 0 0 ... N1 0  | | |  It follows from the above representation that N ∗N =      |a1,1|2 0 . . . 0 0 ... N ∗ 1 N1 0  | | |  , N N ∗ =      |a1,1|2 0 . . . 0 0 ... N1N ∗ 1 0  | | |  so N ∗ 1 N1 = N1N ∗ 1 . That means the matrix N1 is also normal, and by the induction hypothesis it is diagonal. So the matrix N is also diagonal. □ The following proposition gives a very useful characterization of normal operators. Proposition 2.5. An operator N : X → X is normal if and only if ∥N x∥ = ∥N ∗x∥ ∀x ∈ X. 2. Spectral theorem for self-adjoint and normal operators. 169 Proof. Let N be normal, N ∗N = N N ∗. Then ∥N x∥2 = (N x, N x) = (N ∗N x, x) = (N N ∗x, x) = (N ∗x, N ∗x) = ∥N ∗x∥ 2 so ∥N x∥ = ∥N ∗x∥. Now let ∥N x∥ = ∥N ∗x∥ ∀x ∈ X. The Polarization Identities (Lemma 1.9 in Chapter 5) imply that for all x, y ∈ X (N ∗N x, y) = (N x, N y) = 1 4 ∑ α=±1,±i α∥N x + αN y∥2 = 1 4 ∑ α=±1,±i α∥N (x + αy)∥ 2 = 1 4 ∑ α=±1,±i α∥N ∗(x + αy)∥2 = 1 4 ∑ α=±1,±i α∥N ∗x + αN ∗y∥2 = (N ∗x, N ∗y) = (N N ∗x, y) and therefore (see Corollary 1.6) N ∗N = N N ∗. □ Exercises. 2.1. True or false: a) Every unitary operator U : X → X is normal. b) A matrix is unitary if and only if it is invertible. c) If two matrices are unitarily equivalent, then they are also similar. d) The sum of self-adjoint operators is self-adjoint. e) The adjoint of a unitary operator is unitary. f) The adjoint of a normal operator is normal. g) If all eigenvalues of a linear operator are 1, then the operator must be unitary or orthogonal. h) If all eigenvalues of a normal operator are 1, then the operator is identity. i) A linear operator may preserve norm but not the inner product. 2.2. True or false: The sum of normal operators is normal? Justify your conclusion. 2.3. Show that an operator unitarily equivalent to a diagonal one is normal. 2.4. Orthogonally diagonalize the matrix, A = ( 3 2 2 3 ) . Find all square roots of A, i.e. ﬁnd all matrices B such that B2 = A. 170 6. Structure of operators in inner product spaces. Note, that all square roots of A are self-adjoint. 2.5. True or false: any self-adjoint matrix has a self-adjoint square root. Justify. 2.6. Orthogonally diagonalize the matrix, A = ( 7 2 2 4 ) , i.e. represent it as A = U DU ∗, where D is diagonal and U is unitary. Among all square roots of A, i.e. among all matrices B such that B2 = A, ﬁnd one that has positive eigenvalues. You can leave B as a product. 2.7. True or false: a) A product of two self-adjoint matrices is self-adjoint. b) If A is self-adjoint, then Ak is self-adjoint. Justify your conclusions 2.8. Let A be m × n matrix. Prove that a) A∗A is self-adjoint. b) All eigenvalues of A∗A are non-negative. c) A∗A + I is invertible. 2.9. Give a proof if the statement is true, or give a counterexample if it is false: a) If A = A∗ then A + iI is invertible. b) If U is unitary, U + 3 4 I is invertible. c) If a matrix A is real, A − iI is invertible. 2.10. Orthogonally diagonalize the rotation matrix Rα = ( cos α − sin α sin α cos α ) , where α is not a multiple of π. Note, that you will get complex eigenvalues in this case. 2.11. Orthogonally diagonalize the matrix A = ( cos α sin α sin α − cos α ) . Hints: You will get real eigenvalues in this case. Also, the trigonometric identities sin 2x = 2 sin x cos x, sin 2 x = (1 − cos 2x)/2, cos 2 x = (1 + cos 2x)/2 (applied to x = α/2) will help to simplify expressions for eigenvectors. 2.12. Can you describe the linear transformation with matrix A from the previous problem geometrically? Is has a very simple geometric interpretation. 2.13. Prove that a normal operator with unimodular eigenvalues (i.e. with all eigenvalues satisfying |λk| = 1) is unitary. Hint: Consider diagonalization 2.14. Prove that a normal operator with real eigenvalues is self-adjoint. 3. Polar and singular value decompositions. 171 2.15. Show by example that conclusion of Theorem 2.2 fails for complex symmetric matrices. Namely a) construct a (diagonalizable) 2×2 complex symmetric matrix not admitting an orthogonal basis of eigenvectors; b) construct a 2 × 2 complex symmetric matrix which cannot be diagonalized. 3. Polar and singular value decompositions. 3.1. Positive deﬁnite operators. Square roots. Deﬁnition. A self adjoint operator A : X → X is called positive deﬁnite if (Ax, x) > 0 ∀x ̸= 0, and it is called positive semideﬁnite if (Ax, x) ≥ 0 ∀x ∈ X. We will use the notation A > 0 for positive deﬁnite operators, and A ≥ 0 for positive semi-deﬁnite. The following theorem describes positive deﬁnite and semideﬁnite oper- ators. Theorem 3.1. Let A = A∗. Then 1. A > 0 if and only if all eigenvalues of A are positive. 2. A ≥ 0 if and only if all eigenvalues of A are non-negative. Proof. Pick an orthonormal basis such that matrix of A in this basis is diagonal (see Theorem 2.1). To ﬁnish the proof it remains to notice that a diagonal matrix is positive deﬁnite (positive semideﬁnite) if and only if all its diagonal entries are positive (non-negative). □ Corollary 3.2. Let A = A∗ ≥ 0 be a positive semideﬁnite operator. There exists a unique positive semideﬁnite operator B such that B2 = A Such B is called (positive) square root of A and is denoted as √A or A1/2. Proof. Let us prove that √A exists. Let v1, v2, . . . , vn be an orthonor- mal basis of eigenvectors of A, and let λ1, λ2, . . . , λn be the corresponding eigenvalues. Note, that since A ≥ 0, all λk ≥ 0. In the basis v1, v2, . . . , vn the matrix of A is a diagonal matrix diag{λ1, λ2, . . . , λn} with entries λ1, λ2, . . . , λn on the diagonal. Deﬁne the matrix of B in the same basis as diag{ √λ1, √λ2, . . . , √λn}. Clearly, B = B∗ ≥ 0 and B2 = A. 172 6. Structure of operators in inner product spaces. To prove that such B is unique, let us suppose that there exists an op- erator C = C∗ ≥ 0 such that C2 = A. Let u1, u2, . . . , un be an orthonormal basis of eigenvectors of C, and let µ1, µ2, . . . , µn be the corresponding eigen- values (note that µk ≥ 0 ∀k). The matrix of C in the basis u1, u2, . . . , un is a diagonal one diag{µ1, µ2, . . . , µn}, and therefore the matrix of A = C2 in the same basis is diag{µ2 1, µ2 2, . . . , µ2 n}. This implies that any eigenvalue λ of A is of form µ2 k, and, moreover, if Ax = λx, then Cx = √λx. Therefore in the basis v1, v2, . . . , vn above, the matrix of C has the diagonal form diag{√λ1, √λ2, . . . , √λn}, i.e. B = C. □ 3.2. Modulus of an operator. Singular values. Consider an operator A : X → Y . Its Hermitian square A∗A is a positive semideﬁnite operator acting in X. Indeed, (A∗A)∗ = A∗A∗∗ = A∗A and (A ∗Ax, x) = (Ax, Ax) = ∥Ax∥2 ≥ 0 ∀x ∈ X. Therefore, there exists a (unique) positive-semideﬁnite square root R =√A∗A. This operator R is called the modulus of the operator A, and is often denoted as |A|. The modulus of A shows how “big” the operator A is: Proposition 3.3. For a linear operator A : X → Y ∥|A|x∥ = ∥Ax∥ ∀x ∈ X. Proof. For any x ∈ X ∥|A|x∥ 2 = (|A|x, |A|x) = (|A|∗|A|x, x) = (|A| 2x, x) = (A∗Ax, x) = (Ax, Ax) = ∥Ax∥2 □ Corollary 3.4. Ker A = Ker |A| = (Ran |A|)⊥. Proof. The ﬁrst equality follows immediately from Proposition 3.3, the sec- ond one follows from the identity Ker T = (Ran T ∗)⊥ (|A| is self-adjoint). □ Theorem 3.5 (Polar decomposition of an operator). Let A : X → X be an operator (square matrix). Then A can be represented as A = U |A|, where U is a unitary operator. Remark. The unitary operator U is generally not unique. As one will see from the proof of the theorem, U is unique if and only if A is invertible. 3. Polar and singular value decompositions. 173 Remark. The polar decomposition A = U |A| also holds for operators A : X → Y acting from one space to another. But in this case we can only guarantee that U is an isometry from Ran |A| = (Ker A)⊥ to Y . If dim X ≤ dim Y this isometry can be extended to an isometry from the whole X to Y (if dim X = dim Y this will be a unitary operator). Proof of Theorem 3.5. Consider a vector x ∈ Ran |A|. Then vector x can be represented as x = |A|v for some vector v ∈ X. Deﬁne U0x := Av. By Proposition 3.3 ∥U0x∥ = ∥Av∥ = ∥|A|v∥ = ∥x∥ so it looks like U is an isometry from Ran |A| to X. But ﬁrst we need to prove that U0 is well deﬁned. Let v1 be another vector such that x = |A|v1. But x = |A|v = |A|v1 means that v − v1 ∈ Ker |A| = Ker A (cf Corollary 3.4), so Av = Av1, meaning that U0x is well deﬁned. By the construction A = U0|A|. We leave as an exercise for the reader to check that U0 is a linear transformation. To extend U0 to a unitary operator U , let us ﬁnd some unitary transfor- mation U1 : Ker A → (Ran A)⊥ = Ker A∗. It is always possible to do this, since for square matrices dim Ker A = dim Ker A∗ (the Rank Theorem). It is easy to check that U = U0 + U1 is a unitary operator, and that A = U |A|. □ 3.3. Singular values. Schmidt decomposition. Deﬁnition. Eigenvalues of |A| are called the singular values of A. In other words, if λ1, λ2, . . . , λn are eigenvalues of A∗A then √λ1, √λ2, . . . , √λn are singular values of A. Remark. Very often in the literature the singular values are deﬁned as the non-negative square roots of the eigenvalues of A∗A, without any reference to the modulus |A|. I consider the notion of the modulus of an operator to be an important one, so it was introduced above. However, the notion of the modulus of an operator is not required for what follows (deﬁning the Schur and singular value decompositions). Moreover, as it will be shown below, the modulus of A can be easily constructed from the singular value decomposition. Consider an operator A : X → Y , and let σ1, σ2, . . . , σn be the singu- lar values of A counting multiplicities. Assume also that σ1, σ2, . . . , σr are the non-zero singular values of A, counting multiplicities. This means, in particular, that σk = 0 for k > r. 174 6. Structure of operators in inner product spaces. By the deﬁnition of singular values the numbers σ2 1, σ2 2, . . . , σ2 n are eigen- values of A∗A. Let v1, v2, . . . , vn be an orthonormal basis 1 of eigenvectors of A∗A, A∗Avk = σ2 kvk. Proposition 3.6. The system wk := 1 σk Avk, k = 1, 2, . . . , r is an orthonormal system. Proof. (Avj, Avk) = (A∗Avj, vk) = (σ2 j vj, vk) = σ2 j (vj, vk) = { 0, j ̸= k σ2 j , j = k since v1, v2, . . . , vr is an orthonormal system. □ In the notation of the above proposition, the operator A can be repre- sented as (3.1) A = r∑ k=1 σkwkv∗ k, or, equivalently (3.2) Ax = r∑ k=1 σk(x, vk)wk. Indeed, we know that v1, v2, . . . , vn is an orthonormal basis in X. Then substituting x = vj into the right side of (3.2) we get r∑ k=1 σk(vj, vk)wk = σj(vj, vj)wj = σjwj = Avj if j = 1, 2, . . . , r, and r∑ k=1 σk(v∗ kvj)wk = 0 = Avj for j > r. So the operators in the left and right sides of (3.1) coincide on the basis v1, v2, . . . , vn, so they are equal. Deﬁnition. The above decomposition (3.1) (or (3.2)) is called the Schmidt decomposition of the operator A. Remark. Shmidt decomposition of an operator is not unique. Why? 1We know, that for a self-adjoint operator (A∗A in our case) there exists an orthonormal basis of eigenvectors. 3. Polar and singular value decompositions. 175 Lemma 3.7. Let A can be represented as A = r∑ k=1 σkwkv∗ k where σk > 0 and v1, v2, . . . , vr, w1, w2, . . . , wr are some orthonormal sys- tems. Then this representation gives a Schmidt decomposition of A. Proof. We only need to show that v1, v2, . . . , vr are eigenvectors of A∗A, A∗Avk = σ2 kvk. Since w1, w2, . . . , wr is an orthonormal system, w∗ kwj = (wj, wk) = δk,j := { 0, j ̸= k 1, j = k, and therefore A ∗A = r∑ k=1 σ2 kvkv∗ k. Since v1, v2, . . . , vr is an orthonormal system A∗Avj = r∑ k=1 σ2 kvkv∗ kvj = σ2 j vj thus vk are eigenvectors of A∗A. □ Corollary 3.8. Let A = r∑ k=1 σkwkv∗ k be a Schmidt decomposition of A. Then A∗ = r∑ k=1 σkvkw∗ k is a Scmidt decomposition of A∗ 3.4. Matrix representation of the Shmidt decomposition. Singular value decomposition. The Shmidt decomposition can be written in a nice matrix form. Namely, let us assume that A : Fn → Fm, where F is either C or R (we can always do that by ﬁxing orthonormal bases in X and Y and working with coordinates in these bases). Let σ1, σ2, . . . , σr be non-zero singular values of A, and let A = r∑ k=1 σkwkv∗ k be a Scmidt decomposition of A. 176 6. Structure of operators in inner product spaces. As one can easily see, this equality can be rewritten as (3.3) A = ̃W ̃Σ ̃V ∗, where ̃Σ = diag{σ1, σ2, . . . , σr} and ̃V and ̃W are matrices with columns v1, v2, . . . , vr and w1, w2, . . . , wr respectively. (Can you tell what is the size of each matrix?) Note, that since v1, v2, . . . , vr and w1, w2, . . . , wr are orthonormal sys- tems, the matrices ̃V and ̃W are isometries. Note also that r = rank A, see Exercise 3.1 below. If the matrix A is invertible, then m = n = r, the matrices ̃V , ̃W are unitary and ̃Σ is an invertible diagonal matrix. It turns out that it is always possible to write a representation similar (3.3) with unitary V and W instead of ̃V and ̃W , and in many situations it is more convenient to work with such a representation. To write this representation one needs ﬁrst to complete the systems v1, v2, . . . , vr and w1, w2, . . . , wr to orthogonal bases in Fn and Fm respectively. Recall, that to complete, say v1, v2, . . . , vr to an orthonormal basis in Fn one just needs to ﬁnd and orthonormal basis vr+1, . . . , vn in Ker V ∗; then the system v1, v2, . . . , vn will be an orthonormal basis in Fn. And one can always get an orthonormal basis from an arbitrary one using Gram–Schmidt orthogonalization. Then A can be represented as (3.4) A = W ΣV ∗, where V ∈ M F n×n and W ∈ M F m×m are unitary matrices with columns v1, v2, . . . , vn and w1, w2, . . . , wm respectively, and Σ is a “diagonal” m × n matrix (3.5) Σj,k = { σk j = k ≤ r : 0 otherwise. In other words, to get the matrix Σ one has to take the diagonal matrix diag{σ1, σ2, . . . , σr} and make it to an m × n matrix by adding extra zeroes “south and east”. Deﬁnition 3.9. For a matrix A ∈ M F m×n (recall that here F is always C or R) its singular value decomposition (SVD) is a decomposition of form (3.4), i.e. a decomposition A = W ΣV ∗, where W ∈ M F n×n, V ∈ M F m×m are unitary matrices and Σ ∈ M R+ m×n is a “diagonal” one (meaning that σk,k ≥ 0 for all k = 1, 2, . . . , min{m, n}, and σj,k = 0 for all j ̸= k). The representation (3.3) is often called the reduced or compact SVD. More precisely the reduced SVD is a representation A = ̃W ̃Σ ̃V ∗, where ̃Σ ∈ M R+ r×r, r ≤ min{m, n} is a diagonal matrix with strictly positive diagonal 3. Polar and singular value decompositions. 177 entries, and ̃W ∈ M F n×r, ̃V ∈ M F m×r are isometries; moreover, we require that at least one of the matrices ̃W and ̃V is not square. Remark 3.10. It is easy to see that if A = W ΣV ∗ is a singular value decomposition of A, then σk := σk,k are singular values of A, i.e. σ2 k are eigenvalues of A∗A. Moreover, the columns vk of V are the corresponding eigenvectors of A∗A, A∗Avk = σ2 kvk. Note also that if σk ̸= 0 then wk = 1 σk Avk. All that means that any singular value decomposition A = W ΣV ∗ can be obtained from a Schmidt decomposition (3.2) by the construction described above in this section. The reduced singular value decomposition can be interpreted as a matrix form of the Schmidt decomposition (3.2) for a non-invertible matrix A. For an invertible matrix A the matrix form of the Schmidt decomposition gives the singular value decomposition. Remark 3.11. An alternative way to interpret the singular value decom- position A = W ΣV ∗ is to say that Σ is the matrix of A in the (orthonormal) bases A = v1, v2, . . . , vn and B := w1, w2, . . . , wn, i.e that Σ = [A] B,A. We will use this interpretation later. 3.4.1. From singular value decomposition to the polar decomposition. Note, that if we know the singular value decomposition A = W ΣV ∗ of a square matrix A, we can write a polar decomposition of A: (3.6) A = W ΣV ∗ = (W V ∗)(V ΣV ∗) = U |A| where |A| = V ΣV ∗ and U = W V ∗. To see that this indeed give us a polar decomposition let us notice that V ΣV ∗ is a self-adjoint, positive semideﬁnite operator and that A∗A = V ΣW ∗W ΣV ∗ = V ΣΣV ∗ = V ΣV ∗V ΣV ∗ = (V ΣV ∗) 2. So by the deﬁnition of |A| as the unique positive semideﬁnite square root of A∗A, we can see that |A| = V ΣV ∗. The transformation W V ∗ is clearly unitary, as a product of two unitary transformations, so (3.6) indeed gives us a polar decomposition of A. Note, that this reasoning only works for square matrices, because if A is not square, then the product V Σ is not deﬁned (dimensions do not match, can you see how?). Exercises. 3.1. Show that the number of non-zero singular values of a matrix A coincides with its rank. 178 6. Structure of operators in inner product spaces. 3.2. Find Schmidt decompositions A = r∑ k=1 skwkv∗ k for the following matrices A: ( 2 3 0 2 ) ,   7 1 0 0 5 5   ,   1 1 0 1 −1 1   . 3.3. Let A be an invertible matrix, and let A = W ΣV ∗ be its singular value decomposition. Find a singular value decomposition for A∗ and A−1. 3.4. Find singular value decomposition A = W ΣV ∗ where V and W are unitary matrices for the following matrices: a) A =   −3 1 6 −2 6 −2  ; b) A = ( 3 2 2 2 3 −2 ) . 3.5. Find singular value decomposition of the matrix A = ( 2 3 0 2 ) Use it to ﬁnd a) max∥x∥≤1 ∥Ax∥ and the vectors where the maximum is attained; b) min∥x∥=1 ∥Ax∥ and the vectors where the minimum is attained; c) the image A(B) of the closed unit ball in R2, B = {x ∈ R2 : ∥x∥ ≤ 1}. Describe A(B) geometrically. 3.6. Show that for a square matrix A, | det A| = det |A|. 3.7. True or false a) Singular values of a matrix are also eigenvalues of the matrix. b) Singular values of a matrix A are eigenvalues of A∗A. c) Is s is a singular value of a matrix A and c is a scalar, then |c|s is a singular value of cA. d) The singular values of any linear operator are non-negative. e) Singular values of a self-adjoint matrix coincide with its eigenvalues. 3.8. Let A be an m × n matrix. Prove that non-zero eigenvalues of the matrices A∗A and AA∗ (counting multiplicities) coincide. Can you say when zero eigenvalue of A∗A and zero eigenvalue of AA∗ have the same multiplicity? 3.9. Let s be the largest singular value of an operator A, and let λ be the eigenvalue of A with largest absolute value. Show that |λ| ≤ s. 3.10. Show that the rank of a matrix is the number of its non-zero singular values (counting multiplicities). 4. Applications of the singular value decomposition. 179 3.11. Show that the operator norm of a matrix A coincides with its Frobenius norm if and only if the matrix has rank one. Hint: The previous problem might help. 3.12. For the matrix A A = ( 2 −3 0 2 ) , describe the inverse image of the unit ball, i.e. the set of all x ∈ R2 such that ∥Ax∥ ≤ 1. Use singular value decomposition. 4. Applications of the singular value decomposition. As we discussed above, the singular value decomposition is simply diago- nalization with respect to two diﬀerent orthonormal bases. Since we have two diﬀerent bases here, we cannot say much about spectral properties of an operator from its singular value decomposition. For example, the diagonal entries of Σ in the singular value decomposition (3.5) are not the eigenvalues of A. Note, that for A = W ΣV ∗ as in (3.5) we generally have An ̸= W ΣnV ∗, so this diagonalization does not help us in computing functions of a matrix. However, as the examples below show, singular values tell us a lot about so-called metric properties of a linear transformation. Final remark: performing singular value decomposition requires ﬁnding eigenvalues and eigenvectors of the Hermitian (self-adjoint) matrix A∗A. To ﬁnd eigenvalues we usually computed characteristic polynomial, found its roots, and so on... This looks like quite a complicated process, especially if one takes into account that there is no formula for ﬁnding roots of polyno- mials of degree 5 and higher. However, there are very eﬀective numerical methods of ﬁnd eigenvalues and eigenvectors of a hermitian matrix up to any given precision. These methods do not involve computing the characteristic polynomial and ﬁnding its roots. They compute approximate eigenvalues and eigenvectors directly by an iterative procedure. Because a Hermitian matrix has an orthogonal basis of eigenvectors, these methods work extremely well. We will not discuss these methods here, it goes beyond the scope of this book. However, you should believe me that there are very eﬀective nu- merical methods for computing eigenvalues and eigenvectors of a Hermitian matrix and for ﬁnding the singular value decomposition. These methods are extremely eﬀective, and just a little more computationally intensive than solving a linear system. 180 6. Structure of operators in inner product spaces. 4.1. Image of the unit ball. Consider for example the following problem: let A : Rn → Rm be a linear transformation, and let B = {x ∈ Rn : ∥x∥ ≤ 1} be the closed unit ball in Rn. We want to describe A(B), i.e. we want to ﬁnd out how the unit ball is transformed under the linear transformation. Let us ﬁrst consider the simplest case when A is a diagonal matrix A = diag{σ1, σ2, . . . , σn}, σk > 0, k = 1, 2, . . . , n. Then for x = (x1, x2, . . . , xn)T and (y1, y2, . . . , yn)T = y = Ax we have yk = σkxk (equivalently, xk = yk/σk) for k = 1, 2, . . . , n, so y = (y1, y2, . . . , yn) T = Ax for ∥x∥ ≤ 1, if and only if the coordinates y1, y2, . . . , yn satisfy the inequality y2 1 σ2 1 + y2 2 σ2 2 + · · · + y2 n σ2 n = n∑ k=1 y2 k σ2 k ≤ 1 (this is simply the inequality ∥x∥2 = ∑k |xk|2 ≤ 1). The set of points in Rn satisfying the above inequalities is called an el- lipsoid. If n = 2 it is an ellipse with half-axes σ1 and σ2, for n = 3 it is an ellipsoid with half-axes σ1, σ2 and σ2. In Rn the geometry of this set is also easy to visualize, and we call that set an ellipsoid with half axes σ1, σ2, . . . , σn. The vectors e1, e2, . . . , en or, more precisely the correspond- ing lines are called the principal axes of the ellipsoid. The singular value decomposition essentially says that any operator in an inner product space is diagonal with respect to a pair of orthonormal bases, see Remark 3.11. Namely, consider the orthogonal bases A = v1, v2, . . . , vn and B = w1, w2, . . . , wn from the singular value decomposition (3.1). Then the matrix of A in these bases is diagonal [A]B,A = diag{σn : n = 1, 2, . . . , n}. Assuming that all σk > 0 and essentially repeating the above reasoning, it is easy to show that any point y = Ax ∈ A(B) if and only if it satisﬁes the inequality y2 1 σ2 1 + y2 2 σ2 2 + · · · + y2 n σ2 n = n∑ k=1 y2 k σ2 k ≤ 1. where y1, y2, . . . , yn are coordinates of y in the orthonormal basis B = w1, w2, . . . , wn, not in the standard one. Similarly, (x1, x2, . . . , xn)T = [x]A. But that is essentially the same ellipsoid as before, only “rotated” (with diﬀerent but still orthogonal principal axes)! There is also an alternative explanation which is presented below. Consider the general case, when the matrix A is not necessarily square, and (or) not all singular values are non-zero. Consider ﬁrst the case of a “diagonal” matrix Σ of form (3.5). It is easy to see that the image ΣB of 4. Applications of the singular value decomposition. 181 the unit ball B is the ellipsoid (not in the whole space but in the Ran Σ) with half axes σ1, σ2, . . . , σr. Consider now the general case, A = W ΣV ∗, where V , W are unitary operators. Unitary transformations do not change the unit ball (because they preserve norm), so V ∗(B) = B. We know that Σ(B) is an ellipsoid in Ran Σ with half-axes σ1, σ2, . . . , σr. Unitary transformations do not change geometry of objects, so W (Σ(B)) is also an ellipsoid with the same half-axes. It is not hard to see from the decomposition A = W ΣV ∗ (using the fact that both W and V ∗ are invertible) that W transforms Ran Σ to Ran A, so we can conclude: the image A(B) of the closed unit ball B is an ellipsoid in Ran A with half axes σ1, σ2, . . . , σr. Here r is the number of non-zero singular values, i.e. the rank of A. 4.2. Operator norm of a linear transformation. Given a linear trans- formation A : X → Y let us consider the following optimization problem: ﬁnd the maximum of ∥Ax∥ on the closed unit ball B = {x ∈ X : ∥x∥ ≤ 1}. Again, singular value decomposition allows us to solve the problem. For a diagonal matrix A with non-negative entries the maximum is exactly max- imal diagonal entry. Indeed, let s1, s2, . . . , sr be non-zero diagonal entries of A and let s1 be the maximal one. Since for x = (x1, x2, . . . , xn)T (4.1) Ax = r∑ k=1 skxkek, we can conclude that ∥Ax∥2 = r∑ k=1 s2 k|xk| 2 ≤ s 2 1 r∑ k=1 |xk|2 = s2 1 · ∥x∥ 2, so ∥Ax∥ ≤ s1∥x∥. On the other hand, ∥Ae1∥ = ∥s1e1∥ = s1∥e1∥, so indeed s1 is the maximum of ∥Ax∥ on the closed unit ball B. Note, that in the above reasoning we did not assume that the matrix A is square; we only assumed that all entries outside the “main diagonal” are 0, so formula (4.1) holds. To treat the general case let us consider the singular value decompo- sition (3.5), A = W ΣV , where W , V are unitary operators, and Σ is the diagonal matrix with non-negative entries. Since unitary transformations do not change the norm, one can conclude that the maximum of ∥Ax∥ on the unit ball B is the maximal diagonal entry of Σ i.e. that the maximum of ∥Ax∥ on the unit ball B is the maximal singular value of A. 182 6. Structure of operators in inner product spaces. Deﬁnition. The quantity max{∥Ax∥ : x ∈ X, ∥x∥ ≤ 1} is called the oper- ator norm of A and denoted ∥A∥. It is an easy exercise to see that ∥A∥ satisﬁes all properties of the norm: 1. ∥αA∥ = |α| · ∥A∥; 2. ∥A + B∥ ≤ ∥A∥ + ∥B∥; 3. ∥A∥ ≥ 0 for all A; 4. ∥A∥ = 0 if and only if A = 0, so it is indeed a norm on a space of linear transformations from from X to Y . One of the main properties of the operator norm is the inequality ∥Ax∥ ≤ ∥A∥ · ∥x∥, which follows easily from the homogeneity of the norm ∥x∥. In fact, it can be shown that the operator norm ∥A∥ is the best (smallest) number C ≥ 0 such that ∥Ax∥ ≤ C∥x∥ ∀x ∈ X. This is often used as a deﬁnition of the operator norm. On the space of linear transformations we already have one norm, the Frobenius, or Hilbert-Schmidt norm ∥A∥2, ∥A∥2 2 = trace(A∗A). So, let us investigate how these two norms compare. Let s1, s2, . . . , sr be non-zero singular values of A (counting multiplici- ties), and let s1 be the largest eigenvalues. Then s2 1, s2 2, . . . , s2 r are non-zero eigenvalues of A∗A (again counting multiplicities). Recalling that the trace equals the sum of the eigenvalues we conclude that ∥A∥ 2 2 = trace(A∗A) = r∑ k=1 s 2 k. On the other hand we know that the operator norm of A equals its largest singular value, i.e. ∥A∥ = s1. So we can conclude that ∥A∥ ≤ ∥A∥2, i.e. that the operator norm of a matrix cannot be more than its Frobenius norm. This statement also admits a direct proof using the Cauchy–Schwarz in- equality, and such a proof is presented in some textbooks. The beauty of the proof we presented here is that it does not require any computations and illuminates the reasons behind the inequality. 4. Applications of the singular value decomposition. 183 4.3. Condition number of a matrix. Suppose we have an invertible matrix A and we want to solve the equation Ax = b. The solution, of course, is given by x = A−1b, but we want to investigate what happens if we know the data only approximately. That happens in the real life, when the data is obtained, for example by some experiments. But even if we have exact data, round-oﬀ errors during computations by a computer may have the same eﬀect of distorting the data. Let us consider the simplest model, suppose there is a small error in the right side of the equation. That means, instead of the equation Ax = b we are solving Ax = b + ∆b, where ∆b is a small perturbation of the right side b. So, instead of the exact solution x of Ax = b we get the approximate solution x+∆x of A(x+∆x) = b+∆b. We are assuming that A is invertible, so ∆x = A−1∆b. We want to know how big is the relative error in the solution ∥∆x∥/∥x∥ in comparison with the relative error in the right side ∥∆b∥/∥b∥. It is easy to see that ∥∆x∥ ∥x∥ = ∥A−1∆b∥ ∥x∥ = ∥A−1∆b∥ ∥b∥ ∥b∥ ∥x∥ = ∥A−1∆b∥ ∥b∥ ∥Ax∥ ∥x∥ . Since ∥A−1∆b∥ ≤ ∥A−1∥ · ∥∆b∥ and ∥Ax∥ ≤ ∥A∥ · ∥x∥ we can conclude that ∥∆x∥ ∥x∥ ≤ ∥A−1∥ · ∥A∥ · ∥∆b∥ ∥b∥ . The quantity ∥A∥·∥A−1∥ is called the condition number of the matrix A. It estimates how the relative error in the solution x depends on the relative error in the right side b. Let us see how this quantity is related to singular values. Let the num- bers s1, s2, . . . , sn be the singular values of A, and let us assume that s1 is the largest singular value and sn is the smallest. We know that the (operator) norm of an operator equals its largest singular value, so ∥A∥ = s1, ∥A−1∥ = 1 sn , so ∥A∥ · ∥A−1∥ = s1 sn . In other words The condition number of a matrix equals to the ratio of the largest and the smallest singular values. 184 6. Structure of operators in inner product spaces. We deduced above that ∥∆x∥ ∥x∥ ≤ ∥A−1∥ · ∥A∥ · ∥∆b∥ ∥b∥ . It is not hard to see that this estimate is sharp, i.e. that it is possible to pick the right side b and the error ∆b such that we have equality ∥∆x∥ ∥x∥ = ∥A−1∥ · ∥A∥ · ∥∆b∥ ∥b∥ . We just put b = w1 and ∆b = αwn, where w1 and wn are respectively the ﬁrst and the last column of the matrix W in the singular value decomposition A = W ΣV ∗, and α ̸= 0 is an arbitrary scalar. Here, as usual, the singular values are assumed to be in non-increasing order s1 ≥ s2 ≥ . . . ≥ sn, so s1 is the largest and sn is the smallest eigenvalue. We leave the details as an exercise for the reader. A matrix is called well conditioned if its condition number is not too big. If the condition number is big, the matrix is called ill conditioned. What is “big” here depends on the problem: with what precision you can ﬁnd your right side, what precision is required for the solution, etc. 4.4. Eﬀective rank of a matrix. Theoretically, the rank of a matrix is easy to compute: one just needs to row reduce matrix and count pivots. However, in practical applications not everything is so easy. The main rea- son is that very often we do not know the exact matrix, we only know its approximation up to some precision. Moreover, even if we know the exact matrix, most computer programs introduce round-oﬀ errors in the computations, so eﬀectively we cannot dis- tinguish between a zero pivot and a very small pivot. A simple na¨ıve idea of working with round-oﬀ errors is as follows. When computing the rank (and other objects related to it, like column space, kernel, etc) one simply sets up a tolerance (some small number) and if the pivot is smaller than the tolerance, count it as zero. The advantage of this approach is its simplicity, since it is very easy to program. However, the main disadvantage is that is is impossible to see what the tolerance is responsible for. For example, what do we lose is we set the tolerance equal to 10−6? How much better will 10−8 be? While the above approach works well for well conditioned matrices, it is not very reliable in the general case. A better approach is to use singular values. It requires more computa- tions, but gives much better results, which are easier to interpret. In this approach we also set up some small number as a tolerance, and then per- form singular value decomposition. Then we simply treat singular values smaller than the tolerance as zero. The advantage of this approach is that we can see what we are doing. The singular values are the half-axes of the 4. Applications of the singular value decomposition. 185 ellipsoid A(B) (B is the closed unit ball), so by setting up the tolerance we just deciding how “thin” the ellipsoid should be to be considered “ﬂat”. 4.5. Moore–Penrose (pseudo)inverse. As we discussed in Section 4 of Chapter 5 above, the least square solution gives us, in the case when an equation Ax = b does not have a solutions, the “next best thing” (and gives us the solution of Ax = b when it exists). Note, that the question of uniqueness is not addressed by the least square solution: a solution of the normal equation A∗Ax = A∗b does not have to be unique. A natural distinguished solution would be a solution of minimal norm; such a solution is indeed unique, and can be obtained by taking an arbitrary solution and then taking its projection onto (Ker A∗A)⊥ = (Ker A)⊥, see problems 4.5 and 4.6 in Chapter 5. It is not hard to see that if A = ̃W ̃Σ ̃V ∗ is a reduced singular value decomposition of A, then the minimal norm least square solution x0 is given by x0 = ̃V ̃Σ−1̃W ∗b.(4.2) Indeed, x0 is a least square solution of Ax = b (i.e. a solution of Ax = PRan Ab): Ax0 = ̃W ̃Σ ̃V ̃V ∗ ̃Σ−1̃W ∗b = ̃W ̃Σ̃Σ−1̃W ∗b = ̃W ̃W ∗b = PRan Ab; in the last equality in the chain we used the fact that ̃W ̃W ∗ = PRan ̃W (PRan ̃W = ̃W (̃W ∗̃W )−1̃W ∗ = ̃W ̃W ∗) and that Ran ̃W = Ran A (see Prob- lem 4.4 below). The general solution of Ax = PRan Ab is given by x = x0 + y, y ∈ Ker A, so x0 is indeed a unique minimal norm solution of Ax = PRan Ab, or equiv- alently, the minimal norm least square solution of Ax = b. Deﬁnition 4.1. The operator A+ := ̃V ̃Σ−1̃W ∗, where A = ̃W ̃Σ ̃V ∗ is a reduced singular value decomposition of A, is called the Moore–Penrose in- verse (or Moore–Penrose pseudoinverse) of the operator A. In other words, the Moore–Penrose inverse is the operator giving the unique least square solution of Ax = b. Remark 4.2. In the literature the Moore–Penrose inverse is usually deﬁned as a matrix A+ such that 1. AA+A = A; 2. A+AA+ = A+; 3. (AA+)∗ = AA+; 186 6. Structure of operators in inner product spaces. 4. (A+A)∗ = A+A. It is very easy to check that the operator A+ := ̃V ̃Σ−1̃W ∗ satisﬁes properties 1–4 above. It is also possible (although a bit harder) to show that an operator A+ satisfying properties 1–4 is unique. Indeed, right and left multiplying identity 1 by A+, we get that (A+A)2 = A+A and (AA+)2 = AA+; together with properties 3 and 4 this means that A+A and AA+ ore orthogonal projections (see Problem 5.6 in Capter 5). Trivially, Ker A ⊂ Ker A+A. On the other hand, identity 1 implies that Ker A+A ⊂ Ker A (why?), so Ker A+A = Ker A. But this means that A+A is the orthogonal projection onto (Ker A)⊥ = Ran A∗, A+A = PRan A∗ . Property 1 also implies that AA+y = y for all y ∈ Ran A. Since AA+ is an orthogonal projection, we conclude that Ran A ⊂ Ran AA+. The opposite inclusion Ran AA+ ⊂ Ran A is trivial, so AA+ is the orthogonal projection onto Ran A, AA + = PRan A. Knowing A+A and AA+ we can rewrite property 2 as PRan A∗ A+ = A+ or A+PRan A = A+ . Combining the above identities we get P Ran A∗ A+PRan A = A+. Finally, for any b in the target space of A x0 := A +b = PRan A∗ A+b ∈ Ran A∗ and Ax0 = AA +b = PRan Ab, i.e. x0 is a least square solution of Ax = b. Since x0 ∈ Ran A∗ = (Ker A)⊥, x0 is, as we discussed above, the least square solution of minimal norm. But, as we had shown before, such minimal norm solution is given by (4.2), so A+ = ̃V ̃Σ−1̃W ∗. □ Exercises. 4.1. Find norms and condition numbers for the following matrices: a) A = ( 4 0 1 3 ). b) A = ( 5 3 −3 3 ). 5. Structure of orthogonal matrices 187 For the matrix A from part a) present an example of the right side b and the error ∆b such that ∥∆x∥ ∥x∥ = ∥A∥ · ∥A−1∥ · ∥∆b∥ ∥b∥ ; here Ax = b and A∆x = ∆b. 4.2. Let A be a normal operator, and let λ1, λ2, . . . , λn be its eigenvalues (counting multiplicities). Show that singular values of A are |λ1|, |λ2|, . . . , |λn|. 4.3. Find singular values, norm and condition number of the matrix A =   2 1 1 1 2 1 1 1 2   You can do this problem practically without any computations, if you use the previous problem and can answer the following questions: a) What are singular values (eigenvalues) of an orthogonal projection PE onto some subspace E? b) What is the matrix of the orthogonal projection onto the subspace spanned by the vector (1, 1, 1)T ? c) How the eigenvalues of the operators T and aT + bI, where a and b are scalars, are related? Of course, you can also just honestly do the computations. 4.4. Let A = ̃W ̃Σ ̃V ∗ be a reduced singular value decomposition of A. Show that Ran A = Ran ̃W , and then by taking adjoint that Ran A∗ = Ran ̃V . 4.5. Write a formula for the Moore–Penrose inverse A+ in terms of the singular value decomposition A = W ΣV ∗. 4.6. Tychonov’s regularization: Prove that the Moore–Penrose inverse A+ can be computed as the limits A+ = lim ε→0+ (A∗A + εI) −1A∗ = lim ε→0+ A∗(AA∗ + εI) −1. 5. Structure of orthogonal matrices An orthogonal matrix U with det U = 1 is often called a rotation. The theorem below explains this name. Theorem 5.1. Let U be an orthogonal operator in Rn and let det U = 1.2 Then there exists an orthonormal basis v1, v2, . . . , vn such that the matrix 2For an orthogonal matrix U det U = ±1. 188 6. Structure of operators in inner product spaces. of U in this basis has the block diagonal form        Rϕ1 Rϕ2 0 . . . Rϕk0 In−2k  | | | | |  , where Rϕk are 2-dimensional rotations, Rϕk = ( cos ϕk − sin ϕk sin ϕk cos ϕk ) and In−2k stands for the identity matrix of size (n − 2k) × (n − 2k). Proof. We know that if p is a polynomial with real coeﬃcient and λ is its complex root, p(λ) = 0, then λ is a root of p as well, p(λ) = 0 (this can easily be checked by plugging λ into p(z) = ∑n k=0 akzk). Therefore, all complex eigenvalues of a real matrix A can be split into pairs λk, λk. We know, that eigenvalues of a unitary matrix have absolute value 1, so all complex eigenvalues of A can be written as λk = cos αk + i sin αk, λk = cos αk − i sin αk. Fix a pair of complex eigenvalues λ and λ, and let u ∈ Cn be the eigenvector of U , U u = λu. Then U u = λu. Now, split u into real and imaginary parts, i.e. deﬁne x := Re u = (u + u)/2, y = Im u = (u − u)/(2i), so u = x + iy (note, that x, y are real vectors, i.e. vectors with real entries). Then U x = U 1 2 (u + u) = 1 2 (λu + λu) = Re(λu). Similarly, U y = 1 2i U (u − u) = 1 2i (λu − λu) = Im(λu). Since λ = cos α + i sin α, we have λu = (cos α + i sin α)(x + iy) = ((cos α)x − (sin α)y) + i((cos α)y + (sin α)x). so U x = Re(λu) = (cos α)x−(sin α)y, U y = Im(λu) = (cos α)y+(sin α)x. In other word, U leaves the 2-dimensional subspace Eλ spanned by the vec- tors x, y invariant and the matrix of the restriction of U onto this subspace 5. Structure of orthogonal matrices 189 is the rotation matrix R−α = ( cos α sin α − sin α cos α ) . Note, that the vectors u and u (eigenvectors of a unitary matrix, cor- responding to diﬀerent eigenvalues) are orthogonal, so by the Pythagorean Theorem ∥x∥ = ∥y∥ = √2 2 ∥u∥. It is easy to check that x ⊥ y, so x, y is an orthogonal basis in Eλ. If we multiply each vector in the basis x, y by the same non-zero number, we do not change matrices of linear transformations, so without loss of generality we can assume that ∥x∥ = ∥y∥ = 1 i.e. that x, y is an orthogonal basis in Eλ. Let us complete the orthonormal system v1 = x, v2 = y to an orthonor- mal basis in Rn. Since U Eλ ⊂ Eλ, i.e. Eλ is an invariant subspace of U , the matrix of U in this basis has the block triangular form     R−α ∗ 0 U1  | |  where 0 stands for the (n − 2) × 2 block of zeroes. Since the rotation matrix R−α is invertible, we have U Eλ = Eλ. There- fore U ∗Eλ = U −1Eλ = Eλ, so the matrix of U in the basis we constructed is in fact block diagonal,     R−α 0 0 U1  | |  . Since U is unitary I = U ∗U =     I 0 0 U ∗ 1 U1  | |  , so, since U1 is square, it is also unitary. If U1 has complex eigenvalues we can apply the same procedure to de- crease its size by 2 until we are left with a block that has only real eigenval- ues. Real eigenvalues can be only +1 or −1, so in some orthonormal basis 190 6. Structure of operators in inner product spaces. the matrix of U has the form           R−α1 R−α2 0 . . . R−αd −Ir0 Il  | | | | | | | |  ; here Ir and Il are identity matrices of size r × r and l × l respectively. Since det U = 1, the multiplicity of the eigenvalue −1 (i.e. r) must be even. Note, that the 2 × 2 matrix −I2 can be interpreted as the rotation through the angle π. Therefore, the above matrix has the form given in the conclusion of the theorem with ϕk = −αk or ϕk = π □ Let us give a diﬀerent interpretation of Theorem 5.1. Deﬁne Tj to be a rotation thorough ϕj in the plane spanned by the vectors vj, vj+1. Then Theorem 5.1 simply says that U is the composition of the rotations Tj, j = 1, 2, . . . , k. Note, that because the rotations Tj act in mutually orthogonal planes, they commute, i.e. it does not matter in what order we take the composition. So, the theorem can be interpreted as follows: Any rotation in Rn can be represented as a composition of at most n/2 commuting planar rotations. If an orthogonal matrix has determinant −1, its structure is described by the following theorem. Theorem 5.2. Let U be an orthogonal operator in Rn, and let det U = −1.Then there exists an orthonormal basis v1, v2, . . . , vn such that the ma- trix of U in this basis has block diagonal form          Rϕ1 Rϕ2 0 . . . Rϕk Ir0 −1  | | | | | | |  , where r = n − 2k − 1 and Rϕk are 2-dimensional rotations, Rϕk = ( cos ϕk − sin ϕk sin ϕk cos ϕk ) and In−2k stands for the identity matrix of size (n − 2k) × (n − 2k). 5. Structure of orthogonal matrices 191 We leave the proof as an exercise for the reader. The modiﬁcation that one should make to the proof of Theorem 5.1 are pretty obvious. Note, that it follows from the above theorem that an orthogonal 2 × 2 matrix U with determinant −1 is always a reﬂection. Let us now ﬁx an orthonormal basis, say the standard basis in Rn. We call an elementary rotation 3 a rotation in the xj-xk plane, i.e. a linear transformation which changes only the coordinates xj and xk, and it acts on these two coordinates as a plane rotation. Theorem 5.3. Any rotation U (i.e. an orthogonal transformation U with det U = 1) can be represented as a product at most n(n − 1)/2 elementary rotations. To prove the theorem we will need the following simple lemmas. Lemma 5.4. Let x = (x1, x2)T ∈ R2. There exists a rotation Rα of R2 which moves the vector x to the vector (a, 0)T , where a = √ x1 1 + x2 2. The proof is elementary, and we leave it as an exercise for the reader. One can just draw a picture or/and write a formula for Rα. Lemma 5.5. Let x = (x1, x2, . . . , xn)T ∈ Rn. There exist n − 1 elementary rotations R1, R2, . . . , Rn−1 such that Rn−1 . . . , R2R1x = (a, 0, 0, . . . , 0)T , where a = √ x2 1 + x2 2 + . . . + x2 n. Proof. The idea of the proof of the lemma is very simple. We use an elementary rotation R1 in the xn−1-xn plane to “kill” the last coordinate of x (Lemma 5.4 guarantees that such rotation exists). Then use an elementary rotation R2 in xn−2-xn−1 plane to “kill” the coordinate number n − 1 of R1x (the rotation R2 does not change the last coordinate, so the last coordinate of R2R1x remains zero), and so on. . . For a formal proof we will use induction in n. The case n = 1 is trivial, since any vector in R1 has the desired form. The case n = 2 is treated by Lemma 5.4. Assuming now that Lemma is true for n − 1, let us prove it for n. By Lemma 5.4 there exists a 2 × 2 rotation matrix Rα such that Rα ( xn−1 xn ) = ( an−1 0 ) , where an−1 = √x2 n−1 + x2 n. So if we deﬁne the n × n elementary rotation R1 by R1 = ( In−2 0 0 Rα ) 3This term is not widely accepted. 192 6. Structure of operators in inner product spaces. (In−2 is (n − 2) × (n − 2) identity matrix), then R1x = (x1, x2, . . . , xn−2, an−1, 0) T . We assumed that the conclusion of the lemma holds for n − 1, so there exist n − 2 elementary rotations (let us call them R2, R3, . . . , Rn−1) in Rn−1 which transform the vector (x1, x2, . . . , xn−1, an−1)T ∈ Rn−1 to the vector (a, 0, . . . , 0)T ∈ Rn−1. In other words Rn−1 . . . R3R2(x1, x2, . . . , xn−1, an−1) T = (a, 0, . . . , 0) T . We can always assume that the elementary rotations R2, R3, . . . , Rn−1 act in Rn, simply by assuming that they do not change the last coordinate. Then Rn−1 . . . R3R2R1x = (a, 0, . . . , 0) T ∈ Rn. Let us now show that a = √ x2 1 + x2 2 + . . . + x2 n. It can be easily checked directly, but we apply the following indirect reasoning. We know that or- thogonal transformations preserve the norm, and we know that a ≥ 0. But, then we do not have any choice, the only possibility for a is a =√x2 1 + x2 2 + . . . + x2 n. □ Lemma 5.6. Let A be an n × n matrix with real entries. There exist el- ementary rotations R1, R2, . . . , RN , N ≤ n(n − 1)/2 such that the matrix B = RN . . . R2R1A is upper triangular, and, moreover, all its diagonal en- tries except the last one Bn,n are non-negative. Proof. We will use induction in n. The case n = 1 is trivial, since we can say that any 1 × 1 matrix is of desired form. Let us consider the case n = 2. Let a1 be the ﬁrst column of A. By Lemma 5.4 there exists a rotation R which “kills” the second coordinate of a1, making the ﬁrst coordinate non-negative. Then the matrix B = RA is of desired form. Let us now assume that lemma holds for (n − 1) × (n − 1) matrices, and we want to prove it for n × n matrices. For the n × n matrix A let a1 be its ﬁrst column. By Lemma 5.5 we can ﬁnd n − 1 elementary rotations (say R1, R2, . . . , Rn−1 which transform a1 into (a, 0, . . . , 0)T . So, the matrix Rn−1 . . . R2R1A has the following block triangular form Rn−1 . . . R2R1A = ( a ∗ 0 A1 ) , where A1 is an (n − 1) × (n − 1) block. We assumed that lemma holds for n − 1, so A1 can be transformed by at most (n−1)(n−2)/2 rotations into the desired upper triangular form. Note, that these rotations act in Rn−1 (only on the coordinates x2, x3, . . . , xn), but 6. Orientation 193 we can always assume that they act on the whole Rn simply by assuming that they do not change the ﬁrst coordinate. Then, these rotations do not change the vector (a, 0, . . . , 0)T (the ﬁrst column of Rn−1 . . . R2R1A), so the matrix A can be transformed into the desired upper triangular form by at most n − 1 + (n − 1)(n − 2)/2 = n(n − 1)/2 elementary rotations. □ Proof of Theorem 5.3. By Lemma 5.5 there exist elementary rotations R1, R2, . . . , RN such that the matrix U1 = RN . . . R2R2U is upper triangular, and all diagonal entries, except maybe the last one, are non-negative. Note, that the matrix U1 is orthogonal. Any orthogonal matrix is nor- mal, and we know that an upper triangular matrix can be normal only if it is diagonal. Therefore, U1 is a diagonal matrix. We know that an eigenvalue of an orthogonal matrix can either be 1 or −1, so we can have only 1 or −1 on the diagonal of U1. But, we know that all diagonal entries of U1, except may be the last one, are non-negative, so all the diagonal entries of U1, except may be the last one, are 1. The last diagonal entry can be ±1. Since elementary rotations have determinant 1, we can conclude that det U1 = det U = 1, so the last diagonal entry also must be 1. So U1 = I, and therefore U can be represented as a product of elementary rotations U = R−1 1 R−1 2 . . . R−1 N . Here we use the fact that the inverse of an elementary rotation is an elementary rotation as well. □ 6. Orientation 6.1. Motivation. In Figures 1, 2 below we see 3 orthonormal bases in R2 and R3 respectively. In each ﬁgure, the basis b) can be obtained from the standard basis a) by a rotation, while it is impossible to rotate the standard basis to get the basis c) (so that ek goes to vk ∀k). You have probably heard the word “orientation” before, and you prob- ably know that bases a) and b) have positive orientation, and orientation of the bases c) is negative. You also probably know some rules to determine e1 e2 v1 v2 v1 v2 a) b) c) Figure 1. Orientation in R2 194 6. Structure of operators in inner product spaces. the orientation, like the right hand rule from physics. So, if you can see a basis, say in R3, you probably can say what orientation it has. But what if you only given coordinates of the vectors v1, v2, v3? Of course, you can try to draw a picture to visualize the vectors, and then to see what the orientation is. But this is not always easy. Moreover, how do you “explain” this to a computer? It turns out that there is an easier way. Let us explain it. We need to check whether it is possible to get a basis v1, v2, v3 in R3 by rotating the standard basis e1, e2, en. There is unique linear transformation U such that U ek = vk, k = 1, 2, 3; its matrix (in the standard basis) is the matrix with columns v1, v2, v3. It is an orthogonal matrix (because it transforms an orthonormal basis to an orthonormal basis), so we need to see when it is rotation. Theorems 5.1 and 5.2 give us the answer: the matrix U is a rotation if and only if det U = 1. Note, that (for 3 × 3 matrices) if det U = −1, then U is the composition of a rotation about some axis and a reﬂection in the plane of rotation, i.e. in the plane orthogonal to this axis. This gives us a motivation for the formal deﬁnition below. 6.2. Formal deﬁnition. Let A and B be two bases in a real vector space X. We say that the bases A and B have the same orientation, if the change of coordinates matrix [I]B,A has positive determinant, and say that they have diﬀerent orientations if the determinant of [I] B,A is negative. Note, that since [I]A,B = [I]−1 B,A, one can use the matrix [I]A,B in the deﬁnition. We usually assume that the standard basis e1, e2, . . . , en in Rn has pos- itive orientation. In an abstract space one just needs to ﬁx a basis and declare that its orientation is positive. e1 e3 e2 v1 v2 v3 v1 v2 v3 a) b) c) Figure 2. Orientation in R3 6. Orientation 195 If an orthonormal basis v1, v2, . . . , vn in Rn has positive orientation (i.e. the same orientation as the standard basis) Theorems 5.1 and 5.2 say that the basis v1, v2, . . . , vn is obtained from the standard basis by a rota- tion. 6.3. Continuous transformations of bases and orientation. Deﬁnition. We say that a basis A = {a1, a2, . . . , an} can be continuously transformed to a basis B = {b1, b2, . . . , bn} if there exists a continuous family of bases V(t) = {v1(t), v2(t), . . . , vn(t)}, t ∈ [a, b] such that vk(a) = ak, vk(b) = bk, k = 1, 2 . . . , n. “Continuous family of bases” mean that the vector-functions vk(t) are con- tinuous (their coordinates in some bases are continuous functions) and, which is essential, the system v1(t), v2(t), . . . , vn(t) is a basis for all t ∈ [a, b]. Note, that performing a change of variables, we can always assume, if necessary that [a, b] = [0, 1]. Theorem 6.1. Two bases A = {a1, a2, . . . , an} and B = {b1, b2, . . . , bn} have the same orientation, if and only if one of the bases can be continuously transformed to the other. Proof. Suppose the basis A can be continuously transformed to the basis B, and let V(t), t ∈ [a, b] be a continuous family of bases, performing this transformation. Consider a matrix-function V (t) whose columns are the coordinate vectors [vk(t)]A of vk(t) in the basis A. Clearly, the entries of V (t) are continuous functions and V (a) = I, V (b) = [I]A,B. Note, that because V(t) is always a basis, det V (t) is never zero. Then, the Intermediate Value Theorem asserts that det V (a) and det V (b) has the same sign. Since det V (a) = det I = 1, we can conclude that det[I]A,B = det V (b) > 0, so the bases A and B have the same orientation. To prove the opposite implication, i.e. the “only if” part of the theorem, one needs to show that the identity matrix I can be continuously trans- formed through invertible matrices to any matrix B satisfying det B > 0. In other words, that there exists a continuous matrix-function V (t) on an interval [a, b] such that for all t ∈ [a, b] the matrix V (t) is invertible and such that V (a) = I, V (b) = B. We leave the proof of this fact as an exercise for the reader. There are several ways to prove that, on of which is outlined in Problems 6.2—6.5 below. □ 196 6. Structure of operators in inner product spaces. Exercises. 6.1. Let Rα be the rotation through α, so its matrix in the standard basis is ( cos α − sin α sin α cos α ) . Find the matrix of Rα in the basis v1, v2, where v1 = e2, v2 = e1. 6.2. Let Rα be the rotation matrix Rα = ( cos α − sin α sin α cos α ) . Show that the 2 × 2 identity matrix I2 can be continuously transformed through invertible matrices into Rα. 6.3. Let U be an n × n orthogonal matrix, and let det U > 0. Show that the n × n identity matrix In can be continuously transformed through invertible matrices into U . Hint: Use the previous problem and representation of a rotation in Rn as a product of planar rotations, see Section 5. 6.4. Let A be an n × n positive deﬁnite Hermitian matrix, A = A∗ > 0. Show that the n × n identity matrix In can be continuously transformed through invertible matrices into A. Hint: What about diagonal matrices? 6.5. Using polar decomposition and Problems 6.3, 6.4 above, complete the proof of the “only if” part of Theorem 6.3 Chapter 7 Bilinear and quadratic forms While the study of real quadratic forms (i.e. real homogeneous polynomials of degree 2) was probably the initial motivation for the subject of this chap- ter, complex quadratic forms (Ax, x), x ∈ Cn, A = A∗ are also of signiﬁcant interest. So, unless otherwise speciﬁed, result and calculations hold in both real and complex case. To avoid writing twice essentially the same formulas, we use the notation adapted to the complex case: in particular, in the real case the notation A∗ is used instead of AT . 1. Main deﬁnition 1.1. Bilinear forms on Rn. A bilinear form on Rn is a function L = L(x, y) of two arguments x, y ∈ Rn which is linear in each argument, i.e. such that 1. L(αx1 + βx2, y) = αL(x1, y) + βL(x2, y); 2. L(x, αy1 + βy2) = αL(x, y1) + βL(x, y2). One can consider bilinear form whose values belong to an arbitrary vector space, but in this book we only consider forms that take real values. If x = (x1, x2, . . . , xn)T and y = (y1, y2, . . . , yn)T , a bilinear form can be written as L(x, y) = n∑ j,k=1 aj,kxkyj, 197 198 7. Bilinear and quadratic forms or in matrix form L(x, y) = (Ax, y) where A =      a1,1 a1,2 . . . a1,n a2,1 a2,2 . . . a2,n ... ... . . . ... an,1 an,2 . . . an,n  | | |  . The matrix A is determined uniquely by the bilinear form L. 1.2. Quadratic forms on Rn. There are several equivalent deﬁnition of a quadratic form. One can say that a quadratic form on Rn is the “diagonal” of a bilinear form L, i.e. that any quadratic form Q is deﬁned by Q[x] = L(x, x) = (Ax, x). Another, more algebraic way, is to say that a quadratic form is a homo- geneous polynomial of degree 2, i.e. that Q[x] is a polynomial of n variables x1, x2, . . . , xn having only terms of degree 2. That means that only terms ax2 k and cxjxk are allowed. There many ways (in fact, inﬁnitely many) to write a quadratic form Q[x] as Q[x] = (Ax, x). For example, the quadratic form Q[x] = x2 1 + x2 2 − 4x1x2 on R2 can be represented as (Ax, x) where A can be any of the matrices ( 1 −4 0 1 ) , ( 1 0 −4 1 ) , ( 1 −2 −2 1 ) . In fact, any matrix A of form ( 1 a − 4 −a 1 ) will work. But if we require the matrix A to be symmetric, then such a matrix is unique: Any quadratic form Q[x] on Rn admits unique representation Q[x] = (Ax, x) where A is a (real) symmetric matrix. For example, for the quadratic form Q[x] = x 2 1 + 3x 2 2 + 5x 2 3 + 4x1x2 − 16x1x3 + 7x2x3 on R3, the corresponding symmetric matrix A is   1 2 −8 2 3 3.5 −8 3.5 5   . 1. Main deﬁnition 199 1.3. Quadratic forms on Cn. One can also deﬁne a quadratic form on Cn (or any complex inner product space) by taking a self-adjoint transformation A = A∗ and deﬁning Q by Q[x] = (Ax, x). While our main examples will be in Rn, all the theorems are true in the setting of Cn as well. Bearing this in mind, we will always use A∗ instead of AT The only essential diﬀerence with the real case is that in the complex case we do not have any freedom of choice: if the quadratic form is real, the corresponding matrix has to be Hermitian (self-adjoint). Note that if A = A∗ then (Ax, x) = (x, A ∗x) = (x, Ax) = (Ax, x), so (Ax, x) ∈ R. The converse is also true. Lemma 1.1. Let (Ax, x) be real for all x ∈ Cn. Then A = A∗. We leave the proof as an exercise for the reader, see Problem 1.4 below. One of the possible ways to prove Lemma 1.1 is to use the following version of polarization identities. Lemma 1.2. Let A be an operator in an inner product space X. 1. If X is a complex space, then for any x, y ∈ X (Ax, y) = 1 4 ∑ α∈C:α4=1 α(A(x + αy), x + αy). 2. If X is a real space and A = A∗, then any x, y ∈ X (Ax, y) = 1 4 [(A(x + y), x + y) − (A(x − y), x − y) ]. For the proof of Lemma 1.2 see Exercise 6.3 in Chapter 5 above. Exercises. 1.1. Find the matrix of the bilinear form L on R3, L(x, y) = x1y1 + 2x1y2 + 14x1y3 − 5x2y1 + 2x2y2 − 3x2y3 + 8x3y1 + 19x3y2 − 2x3y3. 1.2. Deﬁne the bilinear form L on R2 by L(x, y) = det[x, y], i.e. to compute L(x, y) we form a 2 × 2 matrix with columns x, y and compute its determinant. Find the matrix of L. 1.3. Find the matrix of the quadratic form Q on R3 Q[x] = x2 1 + 2x1x2 − 3x1x3 − 9x2 2 + 6x2x3 + 13x2 3. 200 7. Bilinear and quadratic forms 1.4. Prove Lemma 1.1 above. Hint: Use the polarization identity, see Lemma 1.2. Alternatively, you can consider the expression (A(x + zy), x + zy) and show that if it is real for all z ∈ C then (Ax, y) = (y, A∗x). 2. Diagonalization of quadratic forms You have probably met quadratic forms before, when you studied second order curves in the plane. Maybe you even studied the second order surfaces in R3. We want to present a uniﬁed approach to classiﬁcation of such objects. Suppose we are given a set in Rn deﬁned by the equation Q[x] = 1, where Q is some quadratic form. If Q has some simple form, for example if the corresponding matrix is diagonal, i.e. if Q[x] = a1x2 1 + a2x2 2 + . . . + anx2 n, we can easily visualize this set, especially if n = 2, 3. In higher dimensions, it is also possible, if not to visualize, then to understand the structure of the set very well. So, if we are given a general, complicated quadratic form, we want to simplify it as much as possible, for example to make it diagonal. The stan- dard way of doing that is the change of variables. 2.1. Orthogonal diagonalization. Let us have a quadratic form Q[x] = (Ax, x) in Fn (F is R or C). Introduce new variables y = (y1, y2, . . . , yn)T ∈ Fn, with y = S−1x, where S is some invertible n × n matrix, so x = Sy. Then, Q[x] = Q[Sy] = (ASy, Sy) = (S∗ASy, y), so in the new variables y the quadratic form has matrix S∗AS. So, we want to ﬁnd an invertible matrix S such that the matrix S∗AS is diagonal. Note, that it is diﬀerent from the diagonalization of matrices we had before: we tried to represent a matrix A as A = SDS−1, so the matrix D = S−1AS was diagonal. However, for unitary matrices U , we have U ∗ = U −1, and we can orthogonally diagonalize symmetric matrices. So we can apply the orthogonal diagonalization we studied before to the quadratic forms. Namely, we can represent the matrix A as A = U DU ∗ = U DU −1. Recall, that D is a diagonal matrix with eigenvalues of A on the diagonal, and U is the matrix of eigenvectors (we need to pick an orthogonal basis of eigenvectors). Then D = U ∗AU , so in the variables y = U −1x the quadratic form has diagonal matrix. 2. Diagonalization of quadratic forms 201 Let us analyze the geometric meaning of the orthogonal diagonaliza- tion. The columns u1, u2, . . . , un of the unitary matrix U form an orthonor- mal basis in Fn, let us call this basis B. The change of coordinate matrix [I]S,B from this basis to the standard one is exactly U . We know that y = (y1, y2, . . . , yn)T = U −1x, so the coordinates y1, y2, . . . , yn can be inter- preted as coordinates of the vector x in the new basis u1, u2, . . . , un. So, orthogonal diagonalization allows us to visualize very well the set Q[x] = 1, or a similar one, as long as we can visualize it for diagonal matrices. Example. Consider the quadratic form of two variables (i.e. quadratic form on R2), Q(x, y) = 2x2 +2y2 +2xy. Let us describe the set of points (x, y)T ∈ R2 satisfying Q(x, y) = 1. The matrix A of Q is A = ( 2 1 1 2 ) . Orthogonally diagonalizing this matrix we can represent it as A = U ( 3 0 0 1 ) U ∗, where U = 1 √2 ( 1 −1 1 1 ) , or, equivalently U ∗AU = ( 3 0 0 1 ) =: D. The set {y : (Dy, y) = 1} is the ellipse with half-axes 1/ √3 and 1. There- fore the set {x ∈ R2 : (Ax, x) = 1}, is the same ellipse only in the basis ( 1√2 , 1√2 )T , (− 1√2 , 1√2 )T , or, equivalently, the same ellipse, rotated π/4. 2.2. Non-orthogonal diagonalization. Orthogonal diagonalization in- volves computing eigenvalues and eigenvectors, so it may be diﬃcult to do without computers for large n. On the other hand, the non-orthogonal di- agonalization, i.e. ﬁnding an invertible S (without requiring S−1 = S∗) such that D = S∗AS is diagonal, is much easier computationally and can be done using only algebraic operations (addition, subtraction, multiplication, division). Below we present two most used methods of non-orthogonal diagonal- ization. 2.2.1. Diagonalization by completion of squares. The ﬁrst methods is based on completion of squares. We will illustrate this method on real quadratic forms (forms on Rn). After simple modiﬁcations this method could be used in the complex case, but we will not discuss it here. If necessary, an inter- ested reader should be able to to make the appropriate modiﬁcations. Let us again consider the quadratic form of two variables, Q[x] = 2x2 1 + 2x1x2 + 2x2 2 (it is the same quadratic form as in the above example, only 202 7. Bilinear and quadratic forms here we call variables not x, y but x1, x2). Since 2 ( x1 + 1 2 x2 )2 = 2 ( x2 1 + 2x1 1 2 x2 + 1 4 x2 2 ) = 2x 2 1 + 2x1x2 + 1 2 x2 2 (note, that the ﬁrst two terms coincide with the ﬁrst two terms of Q), we get 2x2 1 + 2x1x2 + 2x2 2 = 2 ( x1 + 1 2 x2 )2 + 3 2 x 2 2 = 2y2 1 + 3 2 y2 2, where y1 = x1 + 1 2 x2 and y2 = x2. The same method can be applied to quadratic form of more than 2 variables. Let us consider, for example, a form Q[x] in R3, Q[x] = x2 1 − 6x1x2 + 4x1x3 − 6x2x3 + 8x2 2 − 3x2 3. Considering all terms involving the ﬁrst variable x1 (the ﬁrst 3 terms in this case), let us pick a full square or a multiple of a full square which has exactly these terms (plus some other terms). Since (x1 − 3x2 + 2x3) 2 = x2 1 − 6x1x2 + 4x1x3 − 12x2x3 + 9x 2 2 + 4x 2 3 we can rewrite the quadratic form as (x1 − 3x2 + 2x3)2 − x2 2 + 6x2x3 − 7x2 3. Note, that the expression −x2 2 + 6x2x3 − 7x2 3 involves only variables x2 and x3. Since −(x2 − 3x3)2 = −(x2 2 − 6x2x3 + 9x 2 3) = −x2 2 + 6x2x3 − 9x 2 3 we have −x2 2 + 6x2x3 − 7x 2 3 = −(x2 − 3x3) 2 + 2x2 3. Thus we can write the quadratic form Q as Q[x] = (x1 − 3x2 + 2x3)2 − (x2 − 3x3) 2 + 2x2 3 = y2 1 − y2 2 + 2y2 3 where y1 = x1 − 3x2 + 2x3, y2 = x2 − 3x3, y3 = x3. Finally, let us address the question that an attentive reader is probably already asking: what to do if at some point we do have a product of two variables, but no corresponding squares? For example, how to diagonalize the form x1x2? The answer follows immediately from the identity 4x1x2 = (x1 + x2) 2 − (x1 − x2) 2,(2.1) which gives us the representation Q[x] = y2 1 − y2 2, y1 = (x1 + x2)/2, y2 = (x1 − x2)/2. 2. Diagonalization of quadratic forms 203 2.2.2. Diagonalization using row/column operations. There is another way of performing non-orthogonal diagonalization of a quadratic form. The idea is to perform row operations on the matrix A of the quadratic form. The diﬀerence with the row reduction (Gauss–Jordan elimination) is that after each row operation we need to perform the same column operation, the reason for that being that we want to make the matrix S∗AS diagonal. Let us explain how everything works on an example. Suppose we want to diagonalize a quadratic form with matrix A =   1 −1 3 −1 2 1 3 1 1   . We augment the matrix A by the identity matrix, and perform on the aug- mented matrix (A|I) row/column operations. After each row operation we have to perform on the matrix A the same column operation. 1 We get   1 −1 3 1 0 0 −1 2 1 0 1 0 3 1 1 0 0 1  +R1 ∼   1 −1 3 1 0 0 0 1 4 1 1 0 3 1 1 0 0 1   ∼   1 0 3 1 0 0 0 1 4 1 1 0 3 4 1 0 0 1   −3R1 ∼   1 0 3 1 0 0 0 1 4 1 1 0 0 4 −8 −3 0 1   ∼   1 0 0 1 0 0 0 1 4 1 1 0 0 4 −8 −3 0 1   −4R2 ∼   1 0 0 1 0 0 0 1 4 1 1 0 0 0 −24 −7 −4 1   ∼   1 0 0 1 0 0 0 1 0 1 1 0 0 0 −24 −7 −4 1   . Note, that we perform column operations only on the left side of the aug- mented matrix We get the diagonal D matrix on the left, and the matrix S∗ on the right, so D = S∗AS,   1 0 0 0 1 0 0 0 −24   =   1 0 0 1 1 0 −7 −4 1     1 −1 3 −1 2 1 3 1 1     1 1 −7 0 1 −4 0 0 1   . Let us explain why the method works. A row operation is a left multipli- cation by an elementary matrix. The corresponding column operation is the right multiplication by the transposed elementary matrix. Therefore, 1In the case of complex Hermitian matrices we perform for each row operation the conjugate o the corresponding column operation, see Remark 2.1 below 204 7. Bilinear and quadratic forms performing row operations E1, E2, . . . , EN and the same column operations we transform the matrix A to (2.2) EN . . . E2E1AE∗ 1 E∗ 2 . . . E∗ N = EAE∗. As for the identity matrix in the right side, we performed only row operations on it, so the identity matrix is transformed to EN . . . E2E1I = EI = E. If we now denote E∗ = S we get that S∗AS is a diagonal matrix, and the matrix E = S∗ is the right half of the transformed augmented matrix. In the above example we got lucky, because we did not need to inter- change two rows. This operation is a bit tricker to perform. It is quite simple if you know what to do, but it may be hard to guess the correct row operations. Let us consider, for example, a quadratic form with the matrix A = ( 0 1 1 0 ) If we want to diagonalize it by row and column operations, the simplest idea would be to interchange rows 1 and 2. But we also must to perform the same column operation, i.e. interchange columns 1 and 2, so we will end up with the same matrix. So, we need something more non-trivial. The identity (2.1), for example, can be used to diagonalize this quadratic form. However, a simpler idea also works: use row operations to get a non-zero entry on the diagonal! For example, if we start with making a1,1 non-zero, the following series of row (and the corresponding column) operations is one of the possible choices: ( 0 1 1 0 1 0 0 1 ) + 1 2 R2 ∼ ( 1/2 1 1 1/2 1 0 0 1 ) ∼ ( 1 1 1 1/2 1 0 0 1 ) −R1 ∼ ( 1 1 1 1/2 0 −1 −1 1/2 ) ∼ ( 1 0 1 1/2 0 −1 −1 1/2 ) . Remark. Non-orthogonal diagonalization gives us a simple description of a set Q[x] = 1 in a non-orthogonal basis. It is harder to visualize, than the representation given by the orthogonal diagonalization. However, if we are not interested in the details, for example if it is suﬃcient for us just to know that the set is an ellipsoid (or hyperboloid, etc), then the non-orthogonal diagonalization is an easier way to get the answer. Remark 2.1. For quadratic forms with complex entries (i.e. for forms (Ax, x), A = A∗), the non-orthogonal diagonalization works the same way 2. Diagonalization of quadratic forms 205 as in the real case, with the only diﬀerence, that the corresponding “column operations” have the complex conjugate coeﬃcients. The reason for that is that if a row operation is given by left multiplica- tion by an elementary matrix Ek, then the corresponding column operation is given by the right multiplication by E∗ k, see (2.2). Note that formula (2.2) works in both complex and reals cases: in real case we could write ET k instead of E∗ k, but using Hermitian adjoint allows us to have the same formula in both cases. 206 7. Bilinear and quadratic forms Exercises. 2.1. Diagonalize the quadratic form with the matrix A =   1 2 1 2 3 2 1 2 1   . Use two methods: completion of squares and row operations. Which one do you like better? Can you say if the matrix A is positive deﬁnite or not? 2.2. For the matrix A A =   2 1 1 1 2 1 1 1 2   orthogonally diagonalize the corresponding quadratic form, i.e. ﬁnd a diagonal ma- trix D and a unitary matrix U such that D = U ∗AU . 3. Silvester’s Law of Inertia As we discussed above, there are many ways to diagonalize a quadratic form. Note, that a resulting diagonal matrix is not unique. For example, if we got a diagonal matrix D = diag{λ1, λ2, . . . , λn}, we can take a diagonal matrix S = diag{s1, s2, . . . , sn}, sk ∈ R, sk ̸= 0 and transform D to S∗DS = diag{s 2 1λ1, s 2 2λ2, . . . , s2 nλn}. This transformation changes the diagonal entries of D. However, it does not change the signs of the diagonal entries. And this is always the case! Namely, the famous Silvester’s Law of Inertia states that: For a Hermitian matrix A (i.e. for a quadratic form Q[x] = (Ax, x)) and any of its diagonalization D = S∗AS, the number of positive (negative, zero) diagonal entries of D depends only on A, but not on a particular choice of diagonalization. Here we of course assume that S is an invertible matrix, and D is a diagonal one. The idea of the proof of the Silvester’s Law of Inertia is to express the number of positive (negative, zero) diagonal entries of a diagonalization D = S∗AS in terms of A, not involving S or D. We will need the following deﬁnition. 3. Silvester’s Law of Inertia 207 Deﬁnition. Given an n × n Hermitian matrix A = A∗ (a quadratic form Q[x] = (Ax, x) on Fn) we call a subspace E ⊂ Fn positive (resp. negative, resp. neutral ) if (Ax, x) > 0 (resp. (Ax, x) < 0, resp. (Ax, x) = 0) for all x ∈ E, x ̸= 0. Sometimes, to emphasize the role of A we will say A-positive (A negative, A-neutral). Theorem 3.1. Let A be an n × n Hermitian matrix, and let D = S∗AS be its diagonalization by an invertible matrix S. Then the number of positive (resp. negative) diagonal entries of D coincides with the maximal dimension of an A-positive (resp. A-negative) subspace. The above theorem says that if r+ is the number of positive diagonal entries of D, then there exists an A-positive subspace E of dimension r+, but it is impossible to ﬁnd a positive subspace E with dim E > r+. We will need the following lemma, which can be considered a particular case of the above theorem. Lemma 3.2. Let D be a diagonal matrix D = diag{λ1, λ2, . . . , λn}. Then the number of positive (resp. negative) diagonal entries of D coincides with the maximal dimension of a D-positive (resp. D-negative) subspace. Proof. By rearranging the standard basis in Fn (changing the numeration) we can always assume without loss of generality that the positive diagonal entries of D are the ﬁrst r+ diagonal entries. Consider the subspace E+ spanned by the ﬁrst r+ coordinate vectors e1, e2, . . . , er+. Clearly E+ is a D-positive subspace, and dim E+ = r+. Let us now show that for any other D-positive subspace E we have dim E ≤ r+. Consider the orthogonal projection P = P E+ , P x = (x1, x2, . . . , xr+, 0 . . . , 0) T , x = (x1, x2, . . . , xn)T . For a D-positive subspace E deﬁne an operator T : E → E+ by T x = P x, ∀x ∈ E. In other words, T is the restriction of the projection P : P is deﬁned on the whole space, but we restricted its domain to E and target space to E+. We got an operator acting from E to E+, and we use a diﬀerent letter to distinguish it from P . Note, that Ker T = {0}. Indeed, let for x = (x1, x2, . . . , xn)T ∈ E we have T x = P x = 0. Then, by the deﬁnition of P x1 = x2 = . . . = xr+ = 0, 208 7. Bilinear and quadratic forms and therefore (Dx, x) = n∑ k=r++1 λkx2 k ≤ 0 (λk ≤ 0 for k > r+). But x belongs to a D-positive subspace E, so the inequality (Dx, x) ≤ 0 holds only for x = 0. Let us now apply the Rank Theorem (Theorem 7.1 from Chapter 2). First of all, rank T = dim Ran T ≤ dim E+ = r+ because Ran T ⊂ E+. By the Rank Theorem, dim Ker T + rank T = dim E. But we just proved that Ker T = {0}, i.e. that dim Ker T = 0, so dim E = rank T ≤ dim E+ = r+. To prove the statement about negative entries, we just apply the above reasoning to the matrix −D. □ Proof of Theorem 3.1. Let D = S∗AS be a diagonalization of A. Since (Dx, x) = (S∗ASx, x) = (ASx, Sx) it follows that for any D-positive subspace E, the subspace SE is an A- positive subspace. The same identity implies that for any A-positive sub- space F the subspace S−1F is D-positive. Since S and S−1 are invertible transformations, dim E = dim SE and dim F = dim S−1F . Therefore, for any D positive subspace E we can ﬁnd an A-positive subspace (namely SE) of the same dimension, and vice versa: for any A-positive subspace F we can ﬁnd a D-positive subspace (namely S−1F ) of the same dimension. Therefore the maximal possible dimensions of a A-positive and a D-positive subspace coincide, and the theorem is proved. The case of negative diagonal entries treated similarly, we leave the details as an exercise to the reader. □ 4. Positive deﬁnite forms. Minimax characterization of eigenvalues and the Silvester’s criterion of positivity Deﬁnition. A quadratic form Q is called • Positive deﬁnite if Q[x] > 0 for all x ̸= 0. • Positive semideﬁnite if Q[x] ≥ 0 for all x. • Negative deﬁnite if Q[x] < 0 for all x ̸= 0. • Negative semideﬁnite if Q[x] ≤ 0 for all x. • Indeﬁnite if it take both positive and negative values, i.e. if there exist vectors x1 and x2 such that Q[x1] > 0 and Q[x2] < 0. 4. Positive deﬁnite forms. Minimax. Silvester’s criterion 209 Deﬁnition. A Hermitian matrix A = A∗ is called positive deﬁnite (negative deﬁnite, etc. . . ) if the corresponding quadratic form Q[x] = (Ax, x) is positive deﬁnite (negative deﬁnite, etc. . . ). Theorem 4.1. Let A = A∗. Then 1. A is positive deﬁnite iﬀ all eigenvalues of A are positive. 2. A is positive semideﬁnite iﬀ all eigenvalues of A are non-negative. 3. A is negative deﬁnite iﬀ all eigenvalues of A are negative. 4. A is negative semideﬁnite iﬀ all eigenvalues of A are non-positive. 5. A is indeﬁnite iﬀ it has both positive and negative eigenvalues. Proof. The proof follows trivially from the orthogonal diagonalization. In- deed, there is an orthonormal basis in which matrix of A is diagonal, and for diagonal matrices the theorem is trivial. □ Remark. Note, that to ﬁnd whether a matrix (a quadratic form) is positive deﬁnite (negative deﬁnite, etc) one does not have to compute eigenvalues. By Silvester’s Law of Inertia it is suﬃcient to perform an arbitrary, not necessarily orthogonal diagonalization D = S∗AS and look at the diagonal entries of D. 4.1. Silvester’s criterion of positivity. It is an easy exercise to see that a 2 × 2 matrix A = ( a b b c ) is positive deﬁnite if and only if (4.1) a > 0 and det A = ac − |b| 2 > 0 Indeed, if a > 0 and det A = ac−|b|2 > 0, then c > 0, so trace A = a+c > 0. So we know that if λ1, λ2 are eigenvalues of A then λ1λ2 > 0 (det A > 0) and λ1 + λ2 = trace A > 0. But that only possible if both eigenvalues are positive. So we have proved that conditions (4.1) imply that A is positive deﬁnite. The opposite implication is quite simple, we leave it as an exercise for the reader. This result can be generalized to the case of n × n matrices. Namely, for a matrix A A =      a1,1 a1,2 . . . a1,n a2,1 a2,2 . . . a2,n ... ... . . . ... an,1 an,2 . . . an,n  | | |  210 7. Bilinear and quadratic forms let us consider its all upper left submatrices A1 = (a1,1), A2 = ( a1,1 a1,2 a2,1 a2,2 ) , A3 =   a1,1 a1,2 a1,3 a2,1 a2,2 a2,3 a3,1 a3,2 a3,3   , . . . , An = A Theorem 4.2 (Silvester’s Criterion of Positivity). A matrix A = A∗ is positive deﬁnite if and only if det Ak > 0 for all k = 1, 2, . . . , n. First of all let us notice that if A > 0 then Ak > 0 also (can you explain why?). Therefore, since all eigenvalues of a positive deﬁnite matrix are positive, see Theorem 4.1, det Ak > 0 for all k. One can show that if det Ak > 0 ∀k then all eigenvalues of A are posi- tive by analyzing diagonalization of a quadratic form using row and column operations, which was described in Section 2.2. The key here is the obser- vation that if we perform row/column operations in natural order (i.e. ﬁrst subtracting the ﬁrst row/column from all other rows/columns, then sub- tracting the second row/columns from the rows/columns 3, 4, . . . , n, and so on. . . ), and if we are not doing any row interchanges, then we automatically diagonalize quadratic forms Ak as well. Namely, after we subtract ﬁrst and second rows and columns, we get diagonalization of A2; after we subtract the third row/column we get the diagonalization of A3, and so on. Since we are performing only row replacement we do not change the determinant. Moreover, since we are not performing row exchanges and performing the operations in the correct order, we preserve determinants of Ak. Therefore, the condition det Ak > 0 guarantees that each new entry in the diagonal is positive. Of course, one has to be sure that we can use only row replacements, and perform the operations in the correct order, i.e. that we do not encounter any pathological situation. If one analyzes the algorithm, one can see that the only bad situation that can happen is the situation where at some step we have zero in the pivot place. In other words, if after we subtracted the ﬁrst k rows and columns and obtained a diagonalization of Ak, the entry in the k + 1st row and k + 1st column is 0. We leave it as an exercise for the reader to show that this is impossible. □ The proof we outlined above is quite simple. However, let us present, in more detail, another one, which can be found in more advanced textbooks. I personally prefer this second proof, for it demonstrates some important connections. We will need the following characterization of eigenvalues of a hermitian matrix. 4. Positive deﬁnite forms. Minimax. Silvester’s criterion 211 4.2. Minimax characterization of eigenvalues. Let us recall that the codimension of a subspace E ⊂ X is by the deﬁnition the dimension of its orthogonal complement, codim E = dim(E⊥). Since for a subspace E ⊂ X, dim X = n we have dim E + dim E⊥ = n, we can see that codim E = dim X − dim E. Recall that the trivial subspace {0} has dimension zero, so the whole space X has codimension 0. Theorem 4.3 (Minimax characterization of eigenvalues). Let A = A∗ be an n × n matrix, and let λ1 ≥ λ2 ≥ . . . ≥ λn be its eigenvalues taken in the decreasing order. Then λk = max E: dim E=k min x∈E ∥x∥=1 (Ax, x) = min F : codim F =k−1 max x∈F ∥x∥=1 (Ax, x). Let us explain in more details what the expressions like max min and min max mean. To compute the ﬁrst one, we need to consider all subspaces E of dimension k. For each such subspace E we consider the set of all x ∈ E of norm 1, and ﬁnd the minimum of (Ax, x) over all such x. Thus for each subspace we obtain a number, and we need to pick a subspace E such that the number is maximal. That is the max min. The min max is deﬁned similarly. Remark. A sophisticated reader may notice a problem here: why do the maxima and minima exist? It is well known, that maximum and minimum have a nasty habit of not existing: for example, the function f (x) = x has neither maximum nor minimum on the open interval (0, 1). However, in this case maximum and minimum do exist. There are two possible explanations of the fact that (Ax, x) attains maximum and mini- mum. The ﬁrst one requires some familiarity with basic notions of analysis: one should just say that the unit sphere in E, i.e. the set {x ∈ E : ∥x∥ = 1} is compact, and that a continuous function (Q[x] = (Ax, x) in our case) on a compact set attains its maximum and minimum. Another explanation will be to notice that the function Q[x] = (Ax, x), x ∈ E is a quadratic form on E. It is not diﬃcult to compute the matrix of this form in some orthonormal basis in E, but let us only note that this matrix is not A: it has to be a k × k matrix, where k = dim E. It is easy to see that for a quadratic form the maximum and minimum over a unit sphere is the maximal and minimal eigenvalues of its matrix. As for optimizing over all subspaces, we will prove below that the max- imum and minimum do exist. 212 7. Bilinear and quadratic forms Proof of Theorem 4.3. First of all, by picking an appropriate orthonor- mal basis, we can assume without loss of generality that the matrix A is diagonal, A = diag{λ1, λ2, . . . , λn}. Pick subspaces E and F , dim E = k, codim F = k − 1, i.e. dim E = n−k+1. Since dim E +dim F > n, there exists a non-zero vector x0 ∈ E ∩F . By normalizing it we can assume without loss of generality that ∥x0∥ = 1. We can always arrange the eigenvalues in decreasing order, so let us assume that λ1 ≥ λ2 ≥ . . . ≥ λn. Since x belongs to the both subspaces E and F min x∈E ∥x∥=1 (Ax, x) ≤ (Ax0, x0) ≤ max x∈F ∥x∥=1 (Ax, x). We did not assume anything except dimensions about the subspaces E and F , so the above inequality (4.2) min x∈E ∥x∥=1 (Ax, x) ≤ max x∈F ∥x∥=1 (Ax, x). holds for all pairs of E and F of appropriate dimensions. Deﬁne E0 := span{e1, e2, . . . , ek}, F0 := span{ek, ek+1, ek+2, . . . , en}. Since for a self-adjoint matrix B, the maximum and minimum of (Bx, x) over the unit sphere {x : ∥x∥ = 1} are the maximal and the minimal eigenvalue respectively (easy to check on diagonal matrices), we get that min x∈E0 ∥x∥=1 (Ax, x) = max x∈F0 ∥x∥=1 (Ax, x) = λk. It follows from (4.2) that for any subspace E, dim E = k min x∈E ∥x∥=1 (Ax, x) ≤ max x∈F0 ∥x∥=1 (Ax, x) = λk and similarly, for any subspace F of codimension k − 1, max x∈F ∥x∥=1 (Ax, x) ≥ min x∈E0 ∥x∥=1 (Ax, x) = λk. But on subspaces E0 and F0 both maximum and minimum are λk, so min max = max min = λk. □ Corollary 4.4 (Intertwining of eigenvalues). Let A = A∗ = {aj,k}n j,k=1 be a self-adjoint matrix, and let ̃A = {aj,k} n−1 j,k=1 be its submatrix of size (n − 1) × (n − 1). Let λ1, λ2, . . . , λn and µ1, µ2, . . . , µn−1 be the eigenvalues of A and ̃A respectively, taken in decreasing order. Then λ1 ≥ µ1 ≥ λ2 ≥ µ2 ≥ . . . ≥ λn−1 ≥ µn−1 ≥ λn. 4. Positive deﬁnite forms. Minimax. Silvester’s criterion 213 i.e. λk ≥ µk ≥ λk+1, k = 1, 2, . . . , n − 1 Proof. Let ̃X ⊂ Fn be the subspace spanned by the ﬁrst n−1 basis vectors, ̃X = span{e1, e2, . . . , en−1}. Since ( ̃Ax, x) = (Ax, x) for all x ∈ ̃X, Theorem 4.3 implies that µk = max E⊂ ̃X dim E=k min x∈E ∥x∥=1 (Ax, x). To get λk we need to get maximum over the set of all subspaces E of Fn, dim E = k, i.e. take maximum over a bigger set (any subspace of ̃X is a subspace of Fn). Therefore µk ≤ λk. (the maximum can only increase, if we increase the set). On the other hand, any subspace E ⊂ ̃X of codimension k − 1 (here we mean codimension in ̃X) has dimension n − 1 − (k − 1) = n − k, so its codimension in Fn is k. Therefore µk = min E⊂ ̃X dim E=n−k max x∈E ∥x∥=1 (Ax, x) ≤ min E⊂Fn dim E=n−k max x∈E ∥x∥=1 (Ax, x) = λk+1 (minimum over a bigger set can only be smaller). □ Proof of Theorem 4.2. If A > 0, then Ak > 0 for k = 1, 2, . . . , n as well (can you explain why?). Since all eigenvalues of a positive deﬁnite matrix are positive (see Theorem 4.1), det Ak > 0 for all k = 1, 2, . . . , n. Let us now prove the other implication. Let det Ak > 0 for all k. We will show, using induction in k, that all Ak (and so A = An) are positive deﬁnite. Clearly A1 is positive deﬁnite (it is 1 × 1 matrix, so A1 = det A1). Assuming that Ak−1 > 0 (and det Ak > 0) let us show that Ak is positive deﬁnite. Let λ1, λ2, . . . , λk and µ1, µ2, . . . , µk−1 be eigenvalues of Ak and Ak−1 respectively. By Corollary 4.4 λj ≥ µj > 0 for j = 1, 2, . . . , k − 1. Since det Ak = λ1λ2 . . . λk−1λk > 0, the last eigenvalue λk must also be positive. Therefore, since all its eigenvalues are positive, the matrix Ak is positive deﬁnite. □ 4.3. Some remarks. First of all notice, that Silvester Criterion of Posi- tivity does not generalize to positive semideﬁnite matrices if n ≥ 3, meaning that for n × n matrices, n ≥ 3, the conditions det Ak ≥ 0 do not imply that A is positive semideﬁnite, see Problem 4.6 below. 214 7. Bilinear and quadratic forms For 2 × 2 matrices, however, the conditions det Ak ≥ 0 imply that A is positive semideﬁnite, see Problem 4.3 below. This sometimes leads to the wrong conclusion about n × n matrices. Finally, we should should say couple words about negative deﬁnite ma- trices. It is a typical students’ mistake to say that the condition det Ak < 0 implies that A is negative deﬁnite. But that is wrong! To check if the matrix A is negative deﬁnite, one just have to check that the matrix −A is positive deﬁnite. Applying Silvester’s Criterion of Positivity to −A one can see that A is negative deﬁnite if and only if (−1)k det Ak > 0 for all k = 1, 2, . . . , n. Exercises. 4.1. Using Silvester’s Criterion of Positivity check if the matrices A =   4 2 1 2 3 −1 1 −1 2   , B =   3 −1 2 −1 4 −2 2 −2 2   are positive deﬁnite or not. Are the matrices −A, A3 and A−1, A + B−1, A + B, A − B positive deﬁnite? 4.2. True or false: a) If A is positive deﬁnite, then A5 is positive deﬁnite. b) If A is negative deﬁnite, then A8 is negative deﬁnite. c) If A is negative deﬁnite, then A12 is positive deﬁnite. d) If A is positive deﬁnite and B is negative semideﬁnite, then A−B is positive deﬁnite. e) If A is indeﬁnite, and B is positive deﬁnite, then A + B is indeﬁnite. 4.3. Let A be a 2 × 2 Hermitian matrix, such that a1,1 > 0, det A ≥ 0. Prove that A is positive semideﬁnite. 4.4. Find a real symmetric n×n matrix such that det Ak ≥ 0 for all k = 1, 2, . . . , n, but the matrix A is not positive semideﬁnite. Try to ﬁnd an example for the minimal possible n. 4.5. Let A be an n × n Hermitian matrix such that det Ak > 0 for all k = 1, 2, . . . , n − 1 and det A ≥ 0. Prove that A is positive semideﬁnite. 4.6. Find a real symmetric 3 × 3 matrix A such that a1,1 > 0, det Ak ≥ 0 for k = 2, 3, but the matrix A is not positive semideﬁnite. 5. Positive deﬁnite forms and inner products Let V be an inner product space and let B = v1, v2, . . . , vn be a basis (not necessarily orthogonal) in V . Let G = {gj,k}n j.k=1 be the matrix deﬁned by gj,k = (vk, vj). 5. Positive deﬁnite forms and inner products 215 If x = ∑ k xkvk and y = ∑ k ykvk, then (x, y) =   ∑ k xkvk, ∑ j yjvj   = n∑ k,j=1 xkyj(vk, vj) = n∑ j=1 n∑ k=1 gj,kxkyj = (G[x]B, [y]B)Cn , where ( · , · )Cn stands for the standard inner product in Cn. One can im- mediately see that G is a positive deﬁnite matrix (why?). So, when one works with coordinates in an arbitrary (not necessarily orthogonal) basis in an inner product space, the inner product (in terms of coordinates) is not computed as the standard inner product in Cn, but with the help of a positive deﬁnite matrix G as described above. Note, that this G-inner product coincides with the standard inner prod- uct in Cn if and only if G = I, which happens if and only if the basis v1, v2, . . . , vn is orthonormal. Conversely, given a positive deﬁnite matrix G one can deﬁne a non- standard inner product (G-inner product) in Cn by (x, y)G := (Gx, y)Cn, x, y ∈ Cn. One can easily check that (x, y)G is indeed an inner product, i.e. that prop- erties 1–4 from Section 1.3 of Chapter 5 are satisﬁed. Chapter 8 Dual spaces and tensors All vector spaces in this chapter are ﬁnite-dimensional. 1. Dual spaces 1.1. Linear functionals and the dual space. Change of coordinates in the dual space. Deﬁnition 1.1. A linear functional on a vector space V (over a ﬁeld F) is a linear transformation L : V → F. This special class of linear transformation suﬃciently important to de- serve a separate name. If one thinks of vectors as of some physical objects, like force or velocity, then one can think of a linear functional as a (linear) measurement, that gives you some a scalar quantity as the result: think about force or velocity in a given direction. Deﬁnition 1.2. A collection of all linear functionals on a ﬁnite-dimensional1 vector space V is called the dual of V and is usually denoted as V ′ or V ∗ As it was discussed earlier in Section 4 of Chapter 1, the collection L(V, W ) of all linear transformations acting from V to W is a vector space 1We consider here only ﬁnite-dimensional spaces because for inﬁnite-dimensional spaces the dual space consists not of all but only of the so-called bounded linear functionals. Without giving the precise deﬁnition, let us only mention than in the ﬁnite-dimensional case (both the domain and the target space are ﬁnite-dimensional) all linear transformations are bounded, and we do not need to mention the word bounded 217 218 8. Dual spaces and tensors (with naturally deﬁned operations of addition and multiplication by a scalar. So, the dual space V ′ = L(V, F) is a vector space. Let us consider an example. Let the space V be Rn, what is its dual? As we know, a linear transformation T : Rn → Rm is represented by an m × n matrix, so a linear functional on Rn (i.e. a linear transformation L : Rn → R is given by an 1 × n matrix (row), let us denote it by [L]. The collection of all such rows is isomorphic to Rn (isomorphism is given by taking the transpose [L] → [L]T ). So, the dual of Rn is Rn itself. The same holds true for Cn, of course, as well as for Fn, where F is an arbitrary ﬁeld. Since the space V over a ﬁeld F (here we mostly interested in the case F = R or F = C) of dimension n is isomorphic to Fn, and the dual to Fn is isomorphic to Fn, we can conclude that the dual V ′ is isomorphic to V Thus, the deﬁnition of the dual space is starting to look a bit silly, since it does not appear to give us anything new. However, that is not the case! If we look carefully, we can see that the dual space is indeed a new object. To see that, let us analyze how the entries of the matrix [L] (which we can call the coordinates of L) change when we change the basis in V . 1.1.1. Change of coordinates formula. Let A = {a1, a2, . . . , an}, B = {b1, b2, . . . , bn} be two bases in V , and let [L]A = [L]S,A and [L]B = [L]S,B be the matrices of L in the bases A and B respectively (we suppose that the basis in the target space of scalars is always the standard one, so we can skip the subscript S in the notation). Then recalling the change of coordinate rule from Section 8.4 in Chapter 2 we get that [L]B = [L]A[I]A,B. Recall that for a vector v ∈ V its coordinates in diﬀerent bases are related by the formula [v]B = [I]B,A[v]A, and that [I]A,B = [I]−1 B,A. If we denote S := [I]B,A, so [v]B = S[v]A, the entries of the vectors [L]T B and [L]T A are related by the formula (1.1) [L]T B = (S−1) T [L] T A (since we usually represent a vector as a column of its coordinates, we use [L]T A and [L]T B instead of [L]A and [L]B) Saying it in words 1. Dual spaces 219 If S is the change of coordinate matrix (from old coordinates to the new ones) in X, then the change of coordinate matrix in the dual space X ′ is (S−1)T . So, the dual space V ′ of V while isomorphic to V is indeed a diﬀerent object: the diﬀerence is in how the coordinates in V and V ′ change when one changes the basis in V . Remark. One can ask: why can’t we pick a basis in X and some completely unrelated basis in the dual X ′? Of course, we can do that, but imagine, what would it take to compute L(x), knowing coordinates of x in some basis and coordinates of L in some completely unrelated basis. So, if we want (knowing the coordinates of a vector x in some basis) to compute the action of a linear functional L using the standard rules of matrix algebra, i.e. to multiply a row (the functional) by a column (the vector), we have no choice: the “coordinates” of the linear functional L should be the entries of its matrix (in the same basis). As we can see later, see Section 1.3 below, the entries (“coordinates”) of a linear functional are indeed the coordinates in some basis (the so-called dual basis. 1.1.2. A uniqueness theorem. Lemma 1.3. Let v ∈ V . If L(v) = 0 for all L ∈ V ′ then v = 0. As a corollary, if L(v1) = L(v2) for all L ∈ V ′, then v1 = v2 Proof. Fix a basis B in V . Then L(v) = [L]B[v]B. Picking diﬀerent matrices (i.e. diﬀerent L) we can easily see that [v]B = 0. Indeed, if Lk = [0, . . . , 0, 1 k, 0, . . . , 0] then the equality Lk[v]B = 0 implies that kth coordinate of [v]B is 0. Using this equality for all k we conclude that [v]B = 0, so v = 0. □ 1.2. Second dual. As we discussed above, the dual space V ′ is a vector space, so one can consider its dual V ′′ = (V ′)′. It looks like one that can consider the dual V ′′′ of V ′′ and so on. . . However, the fun stops with V ′′ because The second dual V ′′ is canonically (i.e. in a natural way) isomor- phic to V 220 8. Dual spaces and tensors Let us decipher this statement. Any vector v ∈ V canonically deﬁnes a linear functional Lv on V ′ (i.e. an element of the second dual V ′′ by the rule Lv(f ) = f (v) ∀f ∈ V ′ It is easy to check that the mapping T : V → V ′′, T v = Lv is a linear transformation. Note, that Ker T = {0}. Indeed, if T v = 0, then f (v) = 0 ∀f ∈ V ′, and by Lemma 1.3 above we have v = 0. Since dim V ′′ = dim V ′ = dim V , the condition Ker T = {0} implies that T is an invertible transformation (isomorphism). The isomorphism T is very natural, (at least for a mathematician). In particular, it was deﬁned without using a basis, so it does not depend on the choice of basis. So, informally we say that V ′′ is canonically isomorphic to V : the rigorous statement is that the map T described above (which we consider to be a natural and canonical) is an isomorphism from V to V ′′. 1.3. Dual, a.k.a. biorthogonal bases. In the previous sections, we sev- eral times referred to the entries of the matrix of a linear functional L as coordinates. But coordinates in this book usually means the coordinates in some basis. Are the “coordinates’ of a linear functional really coordinates in some basis? Turns out the answer is “yes”, so the terminology remains consistent. Let us ﬁnd the basis corresponding to the coordinates of L ∈ V ′. Let {b1, b2, . . . , bn} be a basis in V . For L ∈ V ′, let [L]B = [L1, L2, . . . , Ln] be its matrix (row) in the basis B. Consider linear functionals b′ 1, b′ 2, . . . , b′ n ∈ V ′ deﬁned by (1.2) b ′ k(bj) = δk,j where δk,j is the Kroneker delta, δk.j = { 1, j = k 0 j ̸= k Recall, that a linear transformation is deﬁned by its action on a basis, so the functionals b′ k are well deﬁned. As one can easily see, the functional L can be represented as L = ∑ Lkb ′ k. 1. Dual spaces 221 Indeed, take an arbitrary v = ∑ k αkbk ∈ V , so [v]B = [α1, α2, . . . , αn]T . By linearity and deﬁnition of b′ k b′ k(v) = b′ k   ∑ j αjbj   = ∑ j αjb′ k(bj) = αk. Therefore Lv = [L]B[v]B = ∑ k Lkαk = ∑ k Lkb′ k(v). Since this identity holds for all v ∈ V , we conclude that L = ∑ k Lkb′ k. Since we did not assume anything about L ∈ V ′, we have just shown that any linear functional L can be represented as a linear combination of b′ 1, b′ 2, . . . , b′ n, so the system b′ 1, b′ 2, . . . , b′ n is generating. Let us show that this system is linearly independent (and so it is a basis). Let 0 = ∑ k Lkb′ k. Then for an arbitrary j = 1, 2, . . . , n 0 = 0bj = (∑ k Lkb′ k ) (bj) = ∑ k Lkb′ k(bj) = Lj so Lj = 0. Therefore, all Lk are 0 and the system is linearly independent. So, the system b′ 1, b′ 2, . . . , b′ n is indeed a basis in the dual space V ′ and the entries of [L]B are coordinates of L with respect to the basis B. Deﬁnition 1.4. Let b1, b2, . . . , bn be a basis in V . The system of vectors b ′ 1, b′ 2, . . . , b′ n ∈ V ′, uniquely deﬁned by the equation (1.2) is called the dual (or biorthogonal) basis to b1, b2, . . . , bn. Note that we have shown that the dual system to a basis is a basis. Note also that in b′ 1, b′ 2, . . . , b′ n is the dual system to a basis b1, b2, . . . , bn, then b1, b2, . . . , bn is the dual to the basis b′ 1, b′ 2, . . . , b′ n 1.3.1. Abstract non-orthogonal Fourier decomposition. The dual system can be used for computing the coordinates in the basis b1, b2, . . . , bn. Let b′ 1, b′ 2, . . . , b′ n be the biorthogonal system to b1, b2, . . . , bn, and let v =∑ k αkbk. Then, as it was shown before b′ j(v) = bj ( ∑ k αkbk ) = ∑ k αkbj(bk) = αjb′ j(bj) = αj, so αk = b′ k(v). Then we can write (1.3) v = ∑ k b ′ k(v)bk. In other words, 222 8. Dual spaces and tensors The kth coordinate of a vector v in a basis B = {b1, b2, . . . , bn} is b′ k(v)}, where B′ = {b′ 1, b′ 2, . . . , b′ n} is the dual basis. This formula is called (a baby version of) the abstract non-orthogonal Fourier decomposition of v (in the basis b1, b2, . . . , bn). The reason for this name will be clear later in Section 2.3. Remark 1.5. Let A = {a1, a2, . . . , an} and B = {b1, b2, . . . , bm} be bases in X and Y respectively, and let B′ = {b′ 1, b′ 2, . . . , b′ m} be the dual basis to B. Then the matrix [T ]B,A =: A = {ak,j}m k=1n j=1 of the transformation T in the bases A, B is given by ak,j = b′ k(T aj), j = 1, 2, . . . , n, k = 1, 2, . . . , m. 1.4. Examples of dual systems. The ﬁrst example we consider is a trivial one. Let V be Rn (or Cn) and let e1, e2, . . . , en be the standard basis there. The dual space will be the space of n-dimensional row vectors, which is isomorphic to Rn (or Cn in the complex case), and the standard basis there is the dual to e1, e2, . . . , en. The standard basis in (Rn)′ (or in (Cn)′ is eT 1 , eT 2 , . . . , eT n ) obtained from e1, e2, . . . , en by transposition. 1.4.1. Taylor formula. The next example is more interesting. Let us con- sider the space Pn of polynomials of degree at most n. As we know, the powers {ek}n k=0, e(t) = tn form the standard basis in this space. What is the dual to this basis? The answer might be tricky to guess, but it is very easy to check when you know it. Namely, consider the linear functionals e′ k ∈ (Pn)′, k = 0, 1, . . . , n, acting on polynomials as follows: e ′ k(p) := 1 k! dk dtk p(t) \f \f t=0= 1 k! p(k)(0); here we use the usual agreement that 0! = 1 and d0f /dt0 = f . Since dk dtk jj = { j(j − 1) . . . (j − k + 1)tj−k, k ≤ j 0 k > j we can easily see that the system {e′ k}n k=0 is the dual to the system of powers {ek}n k=0. Applying (1.3) to the above system {ek}n k=0 and its dual we get that any polynomial p of degree at most n can be represented as (1.4) p(t) = n∑ k=0 p(k)(0) k! tk This formula is well-known in Calculus as the Taylor formula for polyno- mials. More precisely, this is a particular case of the Taylor formula, the 1. Dual spaces 223 so-called Maclaurin formula. The general Taylor formula p(t) = n∑ k=0 p(k)(a) k! (t − a)k can be obtained from (1.4) by applying it to the polynomial p(τ − a) and then denoting t := τ − a. It also can be obtained by considering powers (t − a)k, k = 0, 1, . . . , n and ﬁnding the dual system the same way we did it for tk. 2 1.4.2. Lagrange interpolation. Our next example deals with the so-called Lagrange interpolating formula. Let a1, a2, . . . , an+1 be distinct points (in R or C), and let Pn be the space of polynomials of degree at most n. Deﬁne functionals fk ∈ P′ n by fk(p) = p(ak) ∀p ∈ Pn. What is the dual of this system of functionals? Note, that while it is not hard to show that the functionals fk are linearly independent, and so (since dim(Pn)′ = dim Pn = n + 1) form a basis in (Pn)′, we do not need that. We will construct the dual system directly, and then will be able to see that the system f1, f2, . . . , fn+1 is indeed a basis. Namely, let us deﬁne the polynomials pk, k = 1, 2, . . . , n + 1 as pk(t) = ∏ j:j̸=k(t − aj) ∕ ∏ j:j̸=k(ak − aj) where j in the products runs from 1 to n + 1. Clearly pk(ak) = 1 and pk(aj) = 0 if j ̸= k, so indeed the system p1, p2, . . . , pn+1 is dual to the system f1, f2, . . . , fn+1. There is a little detail here, since the notion of a dual system was deﬁned only for a basis, and we did not prove that either of the systems is one. But one can immediately see that the system p1, p2, . . . , pn+1 is linearly independent (can you explain why?), and since it contains n + 1 = dim Pn vectors, it is a basis. Therefore, the system of functionals f1, f2, . . . , fn+1 is also a basis in the dual space (Pn)′. Remark. Note, that we did not just got lucky here, this is a general phe- nomenon. Namely, as Problem 1.1 below asserts, any system of vectors having a “‘dual” one must be linearly independent. So, constructing a dual system is a way of proving linear independence (and an easy one, if you can do it easily as in the above example). 2 Note, that the general Taylor formula says more than the formula for polynomials obtained here: it says that any n times diﬀerentiable function can be approximated near the point a by its Taylor polynomial. Moreover, if the function is n + 1 times diﬀerentiable, it allows us to estimate the error. The above formula for polynomials serves as a motivation and a starting point for the general case 224 8. Dual spaces and tensors Applying formula (1.3) to the above example one can see that the (unique) polynomial p, deg p ≤ n satisfying (1.5) p(ak) = yk, k = 1, 2, . . . , n + 1 can be reconstructed by the formula (1.6) p(t) = n+1∑ k=1 ykpk(t). This formula is well -known in mathematics as the “Lagrange interpolation formula”. Exercises. 1.1. Let v1, v2, . . . , vr be a system of vectors in X such that there exists a system v′ 1, v′ 2, . . . , v′ r of linear functionals such that v′ k(vj) = { 1, j = k 0 j ̸= k a) Show that the system v1, v2, . . . , vr is linearly independent. b) Show that if the system v1, v2, . . . , vr is not generating, then the “biorthog- onal” system v′ 1, v′ 2, . . . , v′ r is not unique. Hint: Probably the easiest way to prove that is to complete the system v1, v2, . . . , vr to a basis, see Propo- sition 5.4 from Chapter 2 1.2. Prove that given distinct points a1, a2, . . . , an+1 and values y1, y2, . . . , yn+1 (not necessarily distinct) the polynomial p, deg p ≤ n satisfying (1.5) is unique. Try to prove it using the ideas from linear algebra, and not what you know about polynomials. 2. Dual of an inner product space Let us recall that there is no inner product space over an arbitrary ﬁeld, that all our inner product spaces are either real or complex. 2.1. Riesz representation theorem. Theorem 2.1 (Riesz representation theorem). Let H be an inner product space. Given a linear functional L on H there exists a unique vector y ∈ H such that (2.1) L(v) = (v, y) ∀v ∈ H. Proof. Fix an orthonormal basis e1, e2, . . . , en in H, and let [L] = [L1, L2, . . . , Ln] be the matrix of L in this basis. Deﬁne vector y by (2.2) y := ∑ k Lkek, 2. Dual of an inner product space 225 where Lk denotes the complex conjugate of Lk. In the case of a real space the conjugation does nothing and can be simply ignored. We claim that y satisﬁes (2.1). Indeed, take an arbitrary vector v = ∑ k αkek. Then [v] = [α1, α2, . . . , αn] T and L(v) = [L][v] = ∑ k Lkαk. On the other hand Recall that if we know coordinates of 2 vectors in an or- thonormal basis, we can compute the in- ner product by tak- ing these coordinate and computing the standard inner prod- uct in Cn (or Rn). (v, y) = ∑ k αkLk = ∑ k αkLk so (2.1) holds. To show that the vector y is unique, let us assume that y satisﬁes (2.1). Then for k = 1, 2, . . . , n (ek, y) = L(ek) = Lk, so (y, ek) = Lk. Then, using the formula for the decomposition in the orthonormal basis, see Section 2.1 of Chapter 5 we get y = ∑ k (y, ek)ek = ∑ k Lkek which means that any vector satisfying (2.1) must be represented by (2.2). □ Remark. While the statement of the theorem does not require a basis, the proof presented above utilizes an orthonormal basis in H, although the resulting vector y does not depend on the choice of the basis 3. An advantage of this proof is that it gives a formula for computing the representing vector y. 2.2. Is an inner product space a dual to itself ? For a vector y in an inner product space H one can deﬁne a linear functional Ly, Ly(v) := (v, y). It is easy to see that the mapping y 7→ Ly is an injective mapping from H to sits dual H ∗. The above Theorem 2.1 asserts that this mapping is a surjection (onto), so one is tempted to say that the dual of an inner product space H is (canonically isomorphic to) the space H itself, with the canonical isomorphism given by y 7→ Ly. 3 An alternative proof that does need a basis is also possible. This alternative proof, that works in inﬁnite-dimensional case, uses strong convexity of the unit ball in the inner product space together with the idea of completeness from analysis. 226 8. Dual spaces and tensors This is indeed the case if H is a real inner product space and it is easy to show that the map y 7→ Ly is a linear transformation. We already discussed that the map is injective and surjective, so it is an invertible linear transformations, i.e. an isomorphism. However if H is a complex space, one needs to be a bit more careful. Namely, the mapping y 7→ Ly that that maps a vector y ∈ H to the linear functional Ly as in Theorem 2.1 (Ly(v) = (v, y)) is not a linear one. More precisely, while it is easy to show that (2.3) Ly1+y2 = Ly1 + Ly2, it follows from the deﬁnition of Ly and properties of inner product that (2.4) Lαy(v) = (v, αy) = α(v, y) = αLy(v), so Lαy = αLy. In other words, one can say that the dual of a complex inner product space is the space itself but with the diﬀerent linear structure: adding 2 vec- tors is equivalent to adding corresponding linear functionals, but multiplying a vector by α is equivalent to multiplying the corresponding functional by α. A transformation T satisfying T (αx + βy) = αT x + βT y is some- times called a conjugate linear transformation. So, for a complex inner product space H its dual can be canonically iden- tiﬁed with H by a conjugate linear isomorphism (i.e. invertible conjugate linear transformation) Of course, for a real inner product space the complex conjugation can be simply ignored (because α is real), so the map y 7→ Ly is a linear one. In this case we can, indeed say that the dual of an inner product space H is the space itself. In both, real and complex cases, we nevertheless can say that the dual of an inner product space can be canonically identiﬁed with the space itself. 2.3. Biorthogonal systems and orthonormal bases. Deﬁnition 2.2. Let b1, b2, . . . , bn be a basis in an inner product space H. The unique system b′ 1, b′ 2, . . . , b′ n in H deﬁned by (bj, b′ k) = δj,k, where δj,k is the Kroneker delta, is called the biorthogonal or dual to the basis b1, b2, . . . , bn. This deﬁnition clearly agrees with Deﬁnition 1.4, if one identiﬁes the dual H ′ with H as it was discussed above. Then it follows immediately 3. Adjoint (dual) transformations and transpose 227 from the discussion in Section 1.3 that the dual system b′ 1, b′ 2, . . . , b′ n to a basis b1, b2, . . . , bn is uniquely deﬁned and forms a basis, and that the dual to b′ 1, b′ 2, . . . , b′ n is b1, b2, . . . , bn. The abstract non-orthogonal Fourier decomposition formula (1.3) can be rewritten as v = n∑ k=1(v, b ′ k)bk Note, that an orthonormal basis is dual to itself. So, if e1, e2, . . . , en is an orthonormal basis, the above formula is rewritten as v = n∑ k=1(v, ek)ek which is the classical (orthogonal) abstract Fourier decomposition, see for- mula (2.2) in Section 2.1 of Chapter 5. 3. Adjoint (dual) transformations and transpose. Fundamental subspace revisited (once more) By analogy with the case of an inner product spaces, see Theorem 2.1, it is customary to write L(v), where L is a linear functional (i.e. L ∈ V ′, v ∈ V ) in the form resembling inner product L(v) = ⟨v, L⟩ Note, that the expression ⟨v, L⟩ is linear in both arguments, unlike the inner product which in the case of a complex space is linear in the ﬁrst argument and conjugate linear in the second. So, to distinguish it from the inner product, we use the angular brackets. 4 Note also, that while in the inner product both vectors belong to the same space, v and L above belong to diﬀerent spaces: in particular, we cannot add them. 3.1. Dual (adjoint) transformation. Deﬁnition 3.1. Let A : X → Y be a linear transformation. The transfor- mation A′ : Y ′ → X ′ (X ′ and Y ′ are dual spaces for X and Y respectively) such that ⟨Ax, y′⟩ = ⟨x, A ′y′⟩ ∀x ∈ X, y′ ∈ Y ′ is called the adjoint (dual) to A. 4This notation, while widely used, is far from the standard. Sometimes (v, L) is used, sometimes the angular brackets are used for the inner product. So, encountering expression like that in the text, one has to be very careful to distinguish inner product from the action of a linear functional. 228 8. Dual spaces and tensors Of course, it is not a priori clear why the transformation A′ exists. Below we will show that indeed such transformation exists, and moreover, it is unique. 3.1.1. Dual transformation for the case A : Fn → Fm. Let us ﬁrst consider the case when X = Fn, Y = Fm (F here is, as usual, either R or C, but everything works for the case of arbitrary ﬁelds) As usual, we identify a vector v in Fn with the column of its coordinates, and a linear transformation with it matrix (in the standard basis). The dual of Fn is, as it was discussed above, the space of rows of size n, so we can identify its with Fn. Again, we will treat an element of (Fn)′ as a column vector of its coordinates. Under these agreements we have for x ∈ Fn and x′ ∈ (Fn)′ x′(x) = ⟨x, x′⟩ = (x′) T x where the right side is the product of matrices (or a row and a column). Then, for arbitrary x ∈ X = Fn and y′ ∈ Y ′ = (Fm)′ ⟨Ax, y′⟩ = (y′)T Ax = (AT y′) T x = ⟨x, A T y⟩ (the expressions in the middle are products of matrices). So we have proved that the adjoint transformation exists. let us show that it is unique. Assume that for some transformation B ⟨Ax, y′⟩ = ⟨x, By′⟩ ∀x ∈ Fn, ∀y′ ∈ (F m) ′. That means that for arbitrary ⟨x, (AT − B)y′⟩ = 0, ∀x ∈ F n, ∀y′ ∈ (Fm)′ By taking for x and y′ the vectors from the standard bases in Fn and (Fm)′ ∼= Fm respectively we get that the matrices B and AT coincide. □ So, for X = Fn, Y = Fm The dual transformation A′ exists, and is unique. Moreover, its matrix (in the standard bases) equals AT (the transpose of the matrix of A) 3.1.2. Dual transformation in the abstract setting. Now, let us consider the general case. In fact, we do not need to do much, since everything can be reduced to the case of spaces Fn. Namely, let us ﬁx bases A = a1, a2, . . . , an in X, and B = b1, b2, . . . , bm in Y , and let A′ = a′ 1, a′ 2, . . . , a′ n and B = b′ 1, b′ 2, . . . , b′ m be their dual bases (in X ′ and Y ′ respectively). For a vector v (from a space or its dual) we as usual denote by [v]B the column of its coordinates in the basis B. Then ⟨x, x′⟩ = ([x′]A′)T [x]A, ∀x ∈ X ∀x′ ∈ X ′, 3. Adjoint (dual) transformations and transpose 229 i.e. instead of working with x ∈ X and x′ ∈ X ′ we can work with columns their coordinates (in the dual bases A and A′ respectively) absolutely the same way we do in in the case of Fn. Of course, the same works for Y , so working with columns of coordinates and then translating everything back to the abstract setting we get that the dual transformation exists in unique in this case as well. Moreover, using the fact (which we just proved) that for A : Fn → Fm the matrix of A′ is AT we get (3.1) [A′]A′,B′ = ([A]B,A) T , or in plain English The matrix of the dual transformation in the dual basis is the transpose of the matrix of the transformation in the original bases. Remark 3.2. Note, that while we used basis to construct the dual trans- formation, the resulting transformation does not depend on the choice of a basis. 3.1.3. A coordinate-free way to deﬁne the dual transformation. Let us now present another, more “high brow” way of deﬁning the dual of a linear transformation. Namely, for x ∈ X, y′ ∈ Y let us ﬁx for a moment y′ and treat the expression ⟨Ax, y′⟩ = y′(Ax) as a function of x. It is easy to see that this is a composition of two linear transformations (which ones?) and so it is a linear function of x, i.e. a linear functional on X, i.e. an element of X ′. Let us call this linear functional B(y′) to emphasize the fact that it depends on y′. Since we can do this for every y′ ∈ Y ′, we can deﬁne the transformation B : Y ′ → X ′ such that ⟨Ax, y′⟩ = ⟨x, B(y′)⟩ Our next step is to show that B is a linear transformation. Note, that since the transformation B was deﬁned in rather indirect way, we cannot see immediately from the deﬁnition that it is linear. To show the linearity of B let us take y′ 1, y′ 2 ∈ Y ′. For x ∈ X ⟨x, B(αy′ 1 + βy′ 2)⟩ = ⟨Ax, αy′ 1 + βy′ 2⟩ by the deﬁnition of B = α⟨Ax, y′ 1⟩ + β⟨Ax, y′ 2⟩ by linearity = α⟨x, B(y′ 1)⟩ + β⟨x, B(y′ 2)⟩ by the deﬁnition of B = ⟨x, αB(y′ 1) + βB(y′ 2)⟩ by linearity Since this identity is true for all x, we conclude that B(αy′ 1 + βy′ 2) = αB(y′ 1) + βB(y′ 2), i.e. that B is linear. 230 8. Dual spaces and tensors The main advantage of this approach that it does not require a basis, so it can be (and is) used in the inﬁnite-dimensional situation. However, the proof that we presented above in Sections 3.1.1, 3.1.2 gives a constructive way to compute the dual transformation, so we used that proof instead of more general coordinate-free one. Remark 3.3. Note, that the above coordinate-free approach can be used to deﬁne the Hermitian adjoint of as operator in an inner product space. The only addition to the reasoning presented above will be the use of the Riesz Representation Theorem (Theorem 2.1). We leave the details as an exercise to the reader, see Problem 3.2 below. 3.2. Annihilators and relations between fundamental subspaces. Deﬁnition 3.4. Let X be a vector space and let E ⊂ X. The annihilator of E, denoted by E⊥ is the set of all x′ ∈ X ′ such that ⟨x, x′⟩ = 0 for all x ∈ E. Using the fact that X ′′ is canonically isomorphic to X (see Section 1.2) we say that for E ⊂ X ′ its annihilator E⊥ consists of all vectors x ∈ X such that ⟨x, x′⟩ = 0 for all x′ ∈ E. Remark 3.5. Formally speaking, for E ⊂ X ′ the set E⊥ should be deﬁned as the set of all x′′ ∈ X ′′ such that ⟨x′, x′′⟩ = 0 for all x′ ∈ E; the symbol E⊥ is often used for the annihilator from the second part of Deﬁnition 3.4. However, because of the natural isomorphism of X ′′ and X there is no real diﬀerence between these two cases, so we will always use E⊥. Distinguishing the cases E ⊂ X and E ⊂ X ′ makes a lot of sense in the inﬁnite-dimensional situation, where X ′′ is not always canonically isomorphic to X. The spaces such that X ′′ canonically isomorphic to X have a special name: they are called reﬂexive spaces. Proposition 3.6. Let E be a subspace of X. Then (E⊥)⊥ = E This proposition looks absolutely like Proposition 3.6 from Chapter 5. However its proof is a bit more complicated, since the suggested proof of Proposition 3.6 from Chapter 5 heavily used the inner product space struc- ture: it used the decomposition X = E ⊕ E⊥, which is not true in our situation because, for example, E and E⊥ are in diﬀerent spaces. Proof. Let v1, v2, . . . , vr be a basis in E (recall that all spaces in this chapter are assumed to be ﬁnite-dimensional), so E = span{v1, v2, . . . , vr}. By Proposition 5.4 from Chapter 2 the system can be extended to a basis in all X, i.e. one can ﬁnd vectors vr+1, . . . , vn (n = dim X) such that v1, v2, . . . , vn is a basis in X. 3. Adjoint (dual) transformations and transpose 231 Let v′ 1, v′ 2, . . . , v′ n be the dual basis to v1, v2, . . . , vn. By Problem 3.3 E⊥ = span{v′ r+1, . . . , v′ n}. Applying again this problem to E⊥ we get that (E⊥) ⊥ = span{v1, v2, . . . , vn} = E. □ The following theorem is analogous to Theorem 5.1 from Chapter 5 Theorem 3.7. Let A : X → Y be an operator acting from one vector space to another. Then a) Ker A′ = (Ran A)⊥; b) Ker A = (Ran A′)⊥; c) Ran A = (Ker A′)⊥; d) Ran A′ = (Ker A)⊥. Proof. First of all, let us notice, that since for a subspace E we have (E⊥)⊥ = E, the statements 1 and 3 are equivalent. Similarly, for the same reason, the statements 2 and 4 are equivalent as well. Finally, statement 2 is exactly statement 1 applied to the operator A′ (here we use the trivial fact fact that (A′)′ = A, which is true, for example, because of the corresponding fact for the transpose). So, to prove the theorem we only need to prove statement 1. Recall that A′ : Y ′ → X ′. The inclusion y′ ∈ (Ran A)⊥ means that y′ annihilates all vectors of the form Ax, i.e. that ⟨Ax, y′⟩ = 0 ∀x ∈ X. Since ⟨Ax, y′⟩ = ⟨x, A′y′⟩, the last identity is equivalent to ⟨x, A ′y′⟩ = 0 ∀x ∈ X. But that means that A′y′ = 0 (A′y′ is a zero functional). So we have proved that y′ ∈ (Ran A)⊥ iﬀ A′y′ = 0, or equivalently iﬀ y′ ∈ Ker A′. □ Exercises. 3.1. Prove that if for linear transformations T, T1 : X → Y ⟨T x, y′⟩ = ⟨T1x, y′⟩ for all x ∈ X and for all y′ ∈ Y ′, then T = T1. Probably one of the easiest ways of proving this is to use Lemma 1.3. 3.2. Combine the Riesz Representation Theorem (Theorem 2.1) with the reason- ing in Section 3.1.3 above to present a coordinate-free deﬁnition of the Hermitian adjoint of an operator in an inner product space. 232 8. Dual spaces and tensors The next problem gives a way to prove Proposition 3.6 3.3. Let v1, v2, . . . , vn be a basis in X and let v′ 1, v′ 2, . . . , v′ n be its dual basis. Let E := span{v1, v2, . . . , vr}, r < n. Prove that E⊥ = span{v′ r+1, . . . , v′ n}. 3.4. Use the previous problem to prove that for a subspace E ⊂ X dim E + dim E⊥ = dim X. 4. What is the diﬀerence between a space and its dual? We know that the dual space X ′ has the same dimension as X, so the space and its dual are isomorphic. So one can think that really there is no diﬀerence between the space and its dual. However, as we discussed above in Section 1.1, when we change basis in the space X the coordinates in X and in X ′ change according to diﬀerent rules, see formula (1.1) above. On the other hand, using the natural isomorphism of X and X ′′ we can say that X is the dual of X ′. From this point of view, there is no diﬀerence between X and X ′: we can start from X and say that X ′ is its dual, or we can do it the other way around and start from X ′. We already used this point of view above, for example in the proof of Theorem 3.7. Note also, that the change of coordinate formula (1.1) (see also the boxed statement below it) agrees with this point of view: if ̃S := (S−1)T , then ( ̃S−1)T = S, so we get the change of coordinate formula in X from the one in X ′ by the same rule! 4.1. Isomorphisms between X and X ′. There are inﬁnitely many pos- sibilities to deﬁne an isomorphism between X and X ′. If X = Fn then the most natural way to identify X and X ′ is to identify the standard basis in Fn with the one in (Fn)′. In this case the action of a linear functional will be given by the “inner product type” expression ⟨v, v′⟩ = (v′) T v. To generalize this to the general case one has to ﬁx a basis B = b1, b2, . . . , bn in X and consider the dual basis B′ = b′ 1, b′ 2, . . . , b′ n, and deﬁne an isomor- phism T : X → X ′ by T bk = b′ k, k = 1, 2, . . . , n. This isomorphism is natural in some sense, but it depends on the choice of the basis, so in general there is no natural way to identify X and X ′. The exception to this is the case when X is a real inner product space: the Riesz representation theorem (Theorem 2.1) gives a natural way to iden- tify a linear functional with a vector in X. Note that this approach works 4. What is the diﬀerence between a space and its dual? 233 only for real inner product spaces. In the complex case, the Riesz rep- resentation theorem gives a natural identiﬁcation of X and X ′, but this identiﬁcation is not linear but conjugate linear. 4.2. An example: velocities (diﬀerential operators) and diﬀeren- tial forms as vectors and linear functionals. To illustrate the relations between vectors and linear functional, let us consider an example from mul- tivariable calculus, which gives rise to important ideas like tangent and cotangent bundles in diﬀerential geometry. Let us recall the notion of the path integral (of the second kind) from the calculus. Recall that a path γ in Rn is deﬁned by its parameterization, i.e. by a function t 7→ x(t) = (x1(t), x2(t), . . . , xn(t)) T acting from an interval [a, b] to Rn. If ω is the so-called diﬀerential form (diﬀerential 1-form), ω = f1(x)dx1 + f2(x)dx2 + . . . + fn(x)dxn, the path integral ∫ γ ω = ∫ γ f1dx1 + f2dx2 + . . . + fndxn is computed by substituting x(t) = (x1(t), x2(t), . . . , xn(t))T in the expres- sion, i.e. ∫ γ ω is computed as ∫ b a ( f1(x(t)) dx1(t) dt + f2(x(t)) dx2(t) dt + . . . + fn(x(t)) dxn(t) dt ) dt. In other words, at each moment t we have to evaluate the velocity v = dx(t) dt = ( dx1(t) dt , dx2(t) dt , . . . , dxn(t) dt )T , apply to it the linear functional f = (f1, f2, . . . , fn), f (v) = ∑n k=1 fkvk (here fk = fk(x(t)) but for a ﬁxed t each fk is just a number, so we simply write fk), and then integrate the result (which depends on t) with respect to t. 4.2.1. Velocities as vectors. Let us ﬁx t and analyze f (v). We will show that according to the rules of Calculus, the coordinates of v change as coordinates of a vector, and the coordinates of f as the coordinates of a linear functional (covector). Let us assume as it is customary in Calculus, that xk are the coordinates in the standard basis in Rn, and let B = {b1, b2, . . . , bn} be a diﬀerent basis in Rn. We will use notation ̃xk to denote the coordinates of a vector x = (x1, x2, . . . , xn)T , i.e. [x]B = (̃x1, ̃x2, . . . , ̃xn)T . 234 8. Dual spaces and tensors Let A = {ak,j}n k,j=1 be the change of coordinates matrix, A = [I]B,S, so the new coordinates ̃xk are expressed in terms of the old ones as ̃xk = n∑ j=1 ak,jxj, k = 1, 2, . . . , n. So the new coordinates ̃vk of the vector v are obtained from its old coordi- nates vk as ̃vk = n∑ j=1 ak,jvj, k = 1, 2, . . . , n. 4.2.2. Diﬀerential forms as linear functionals (covectors). Let us now cal- culate the diﬀerential form (4.1) ω = n∑ k=1 fkdxk in terms of new coordinates ̃xk. The change of coordinates matrix from the new to the old ones is A−1. Let A−1 = {̃ak,j}n k,j=1, so xk = n∑ j=1 ̃ak,j ̃xj, and dxk = n∑ j=1 ̃ak,jd̃xj, k = 1, 2, . . . , n. Substituting this into (4.1) we get ω = n∑ k=1 fk n∑ j=1 ̃ak,jd̃xj = n∑ j=1 ( n∑ k=1 ̃ak,jfk ) d̃xj = n∑ j=1 ̃fjd̃xj where ̃fj = n∑ k=1 ̃ak,jfk. But that is exactly the change of coordinate rule for the dual space! So according to the rules of Calculus, the coeﬃcients of a diﬀerential 1-form change by the same rule as coordinates in the dual space So, according to the accepted rules of Calculus, the coordinates of ve- locity v change as coordinates of a vector and coeﬃcients (coordinates) of a diﬀerential 1-form change as the entries of a linear functional. In the diﬀer- ential the set of all velocities is called the tangent space, and the set of all diﬀerential 1 forms is its dual and is called the cotangent space. 4. What is the diﬀerence between a space and its dual? 235 4.2.3. Diﬀerential operators as vectors. As we discussed above, in diﬀeren- tial geometry vectors are represented by velocities, i.e. by the derivatives dx(t)/dt. This is a simple and intuitively clear point of view, but sometimes it is viewed as a bit na¨ıve. More “highbrow” point of view, also used in diﬀerential geometry (al- though in more advanced texts) is that vectors are represented by a diﬀer- ential operators (4.2) D = ∑ k vk ∂ ∂xk . The informal reason for that is the following. Suppose we want to compute the derivative of a function Φ along the path given by the function t 7→ x(t), i.e. the derivative dΦ(x(t)) dt . By the Chain Rule, at a given time t dΦ(x(t)) dt = n∑ k=1 ( ∂Φ ∂xk \f \f \f x=x(t) ) x ′ k(t) = DΦ \f \f x=x(t), where the diﬀerential operator D is given by (4.2) with vk = x′ k(t). Of course, we need to show that the coeﬃcient vk of a diﬀerential form change according to the change of coordinate rule for vectors. This is in- tuitively clear, and can be easily shown by using the multivariable Chain Rule. We leave this as an exercise for the reader, see Problem 4.1 below. 4.3. The case of a real inner product space. As we already discussed above, it follows from the Riesz Representation Theorem (Theorem 2.1) that a real inner product space X and its dual X ′ are canonically isomorphic. Thus we can say that vectors and functionals live in the same space which makes things both simpler and more confusing. Remark. First of all let us note, that if the change of coordinates matrix S is orthogonal (S−1 = ST ), then (S−1)T = S. Therefore, for an orthogonal change of coordinate matrix the coordinates of a vector and of a linear functional change according to the same rule, so one cannot really see a diﬀerence between a vector and a functional. The change of coordinate matrix is orthogonal, for example, if we change from one orthonormal basis to another. 4.3.1. Einstein notation, metric tensor. Let B = {b1, b2, . . . , bn be a ba- sis in a real inner product space X and let B′ = {b′ 1, b′ 2, . . . , b′ n} be the dual basis (we identify the dual space X ′ with X via Riesz Representation Theorem, so b′ k can be assumed to be in X). 236 8. Dual spaces and tensors Here we present the standard in diﬀerential geometry notation (the so- called Einstein notation) for working with coordinates in these bases. Since we will only be working with coordinates, we can assume that we are working in the space Rn with the non-standard inner product ( · , · )G deﬁned by the positive deﬁnite matrix G = {gj,k}n j,k=1, gj,k = (bk, bj)X , which is often called the metric tensor, (4.3) (x, y) = (x, y) G = n∑ j=1 n∑ k=1 gj,kxjyk, x, y ∈ Rn (see Section 5 in Chapter 7). To distinguish between vectors and linear functionals (co-vectors) it is agreed to write the coordinates of a vector with indices as superscripts and the coordinates a a linear functional with indices as subscripts: thus xj, j = 1, 2, . . . , n denotes the coordinates of a vector x and fk, k = 1, 2, . . . , n denotes the coordinates of a linear functional f . Remark. Putting indices as superscripts can be confusing, since one will need to distinguish it from the power. However, this is a standard and widely used notation, so we need to get acquainted with it. While I personally, like a lot of mathematicians, prefer using coordinate-free notation, all ﬁnal computations are done in coordinates, so the coordinate notation has to be used. And as far as coordinate notations go, you will see that this notation is quite convenient to work with. Another convention in the Einstein notation is that whenever in a prod- uct the same index appear in the subscript and superscript, it means one needs to sum up in this index. Thus xjfj means ∑ j xjfj, so we can write f (x) = xjfj. The same convention holds when we have more than one index of summation, so (4.3) can be rewritten in this notation as (4.4) (x, y) = gj,kx kyj, x, y ∈ Rn (mathematicians are lazy and are always trying to avoid writing extra sym- bols, whenever they can). Finally, the last convention in the Einstein notation is the preservation of the position of the indices: if we do not sum over an index, it remains in the same position (subscript or superscript) as it was before. Thus we can write yj = a j kxk, but not fj = aj kxk, because the index j must remain as a superscript. Note, that to compute the inner product of 2 vectors, knowing their coordinates is not suﬃcient. One also needs to know the matrix G (which is often called the metric tensor ). This agrees with the Einstein notation: if we try to write (x, y) as the standard inner product, the expression xkyk 4. What is the diﬀerence between a space and its dual? 237 means just the product of coordinates, since for the summation we need the same index both as the subscript and the superscript. The expression (4.4), on the other hand, ﬁt this convention perfectly. 4.3.2. Covariant and contravariant coordinates. Lovering and raising the indices. Let us recall that we have a basis b1, b2, . . . , bn in a real inner product space, and that b′ 1, b′ 2, . . . , b′ n, b′ k ∈ X is its dual basis (we identify X with its dual X ′ via Riesz Representation Theorem, so b′ k are in X). Given a vector x ∈ X it can be represented as x = n∑ k=1(x, b′ k)bk =: n∑ k=1 xkbk, and as(4.5) x = n∑ k=1(x, bk)b′ k =: n∑ k=1 xkb ′ k.(4.6) The coordinates xk are called the covariant coordinates of the vector x and the coordinates xk are called the contravariant coordinates. Now let us ask ourselves a question: how can one get covariant coordi- nates of a vector from the contravariant ones? According to the Einstein notation, we use the contravariant coordinates working with vectors, and covariant ones for linear functionals (i.e. when we interpret a vector x ∈ X as a linear functional). We know (see (4.6)) that xk = (x, bk), so xk = (x, bk) = (∑ j xjbj, bk) = ∑ j xj(bj, bk) = ∑ j gk,jxj, or in the Einstein notation xk = gk,jxj. In other words, the metric tensor G is the change of coordinates matrix from con- travariant coordinates xk to the covariant ones xk. The operation of getting from contravariant coordinates to covariant is called lowering of the indices. Note the following interpretation of the formula (4.4) for the inner prod- uct: as we know for the vector x we get his covariant coordinate as xj = gj,kxk, so (x, y) = xjyj. Similarly, because G is symmetric, we can say that yk = gj,kyk and that (x, y) = xkyk. In other words To compute the inner product of two vectors, one ﬁrst needs to use the metric tensor G to lower indices of one vector, and then, treating this vector as a functional compute its value on the other vector. 238 8. Dual spaces and tensors Of course, we can also change from covariant coordinates xj to con- travariant ones xj (raise the indices). Since (x1, x2, . . . , xn) T = G(x 1, x 2, . . . , xn) T , we get that (x1, x 2, . . . , xn)T = G−1(x1, x2, . . . , xn)T so the change of coordinate matrix in this case is G−1. Since, as we know, the change of coordinate matrix is the metric tensor, we can immediately conclude that G−1 is the metric tensor in covariantG−1 is the metric tensor in covariant coordinates. coordinates, i.e. that if G−1 = {gk,j}n k,j=1 then (x, y) = gk,jxjyk. Remark. Note, that if one looks at the big picture, the covariant and con- travariant coordinates are completely interchangeable. It is just the matter of which one of the bases in the dual pair B and B′ we assign to be the “primary” one and which one to be the dual. What to chose as a “primary” object, and what as the “dual” one de- pends mostly on accepted conventions. Remark 4.1. Einstein notation is usually used in diﬀerential, and espe- cially Riemannian geometry, where vectors are identiﬁed with velocities and covectors (linear functionals) with the diﬀerential 1-forms, see Section 4.2 above. Vectors and covectors here are clearly diﬀerent objects and form what is called tangent and cotangent spaces respectively. In Riemannian geometry one then introduces inner product (i.e. the metric tensor, if one thinks in terms of coordinates) on the tangent space, which allows us identify vectors and covectors (linear functionals). In coor- dinate representation this identiﬁcation is done by lowering/raising indices, as described above. 4.4. Conclusions. Let us summarize the above discussion on whether or not a space is diﬀerent from its dual. In short, the answer is “Yes”, they are diﬀerent objects. Although in the ﬁnite-dimensional case, which is treated in this book, they are isomorphic, nothing is usually gained from the identiﬁcation of a space and its dual. Even in the simplest case of Fn it is useful to think that the elements of Fn are columns and the elements of its dual are rows (even though, when doing manipulations with the elements of the dual space we often put the rows vertically). More striking examples are ones considered in Sections 1.4.1 and 1.4.2 dealing with Taylor formula and Lagrange interpolation. One can clearly see there that the linear functionals are indeed completely 5. Multilinear functions. Tensors 239 diﬀerent objects than polynomials, and that hardly anything can be gained by identifying functionals with the polynomials. For inner product spaces the situation is diﬀerent, because such spaces can be canonically identiﬁed with their duals. This identiﬁcation is linear for real inner product spaces, so a real inner product space is canonically isomorphic to its dual. In the case of complex spaces, this identiﬁcation is only conjugate linear, but it is nevertheless very helpful to identify a linear functional with a vector and use the inner product space structure and ideas like orthogonality, self-adjointness, orthogonal projections, etc. However, sometimes even in the case of real inner product spaces, it is more natural to consider the space and its dual as diﬀerent objects. For ex- ample, in Riemannian geometry, see Remark 4.1 above vector and covectors come from diﬀerent objects, velocities and diﬀerential 1-forms respectively. Even though the introduction of the metric tensor allows us to identify vectors and covectors, it is sometimes more convenient to remember their origins think of them as of diﬀerent objects. Exercises. 4.1. Let D be a diﬀerential operator D = n∑ k=1 vk ∂ ∂xk . Show, using the chain rule, that if we change a basis and write D in new coordinates, its coeﬃcients vk change according to the change of coordinates rule for vectors. 5. Multilinear functions. Tensors 5.1. Multilinear functions. Deﬁnition 5.1. Let V1, V2, . . . , Vp, V be vector spaces (over the same ﬁeld F). A multilinear (p-linear) map with values in V is a function F of p vector variables v1, v2, . . . , vp, vk ∈ Vk, with the target space V , which is linear in each variable vk. In other words, it means that if we ﬁx all variables except vk we get a linear map, and this should be true for all k = 1, 2, . . . , p. We will use the symbol L(V1, V2, . . . , Vp; V ) for the set of all such multilinear functions. If the target space V is the ﬁeld of scalars F, we call F a multilinear functional, or tensor. The number p is called the valency of the multilinear functional (tensor). Thus, tensor of valency 1 is a linear functional, tensor of valency 2 is called a bilinear form. 240 8. Dual spaces and tensors Example. Let fk ∈ (Vk)′. Deﬁne a polylinear functional F = f1 ⊗f2 ⊗. . .⊗fp by multiplying the functionals fk, (5.1) f1 ⊗ f2 ⊗ . . . ⊗ fp(v1, v2, . . . , vp) = f1(v1)f2(v2) . . . fp(vp), for vk ∈ Vk, k = 1, 2, . . . , p. The polylinear functional f1 ⊗ f2 ⊗ . . . ⊗ fp is called the tensor product of functionals fk. 5.1.1. Multilinear functions form vector space. Notice, that in the space L(V1, V2, . . . , Vp; V ) one can introduce the natural operations of addition and multiplication by a scalar, (F1 + F2)(v1, v2, . . . , vp) := F1(v1, v2, . . . , vp) + F2(v1, v2, . . . , vp), (αF1)(v1, v2, . . . , vp) := αF1(v1, v2, . . . , vp), where F1, F2 ∈ L(V1, V2, . . . , Vp; V ), α ∈ F. Equipped with these operations, the space L(V1, V2, . . . , Vp; V ) is a vector space. To see that we ﬁrst need to show that F1 + F2 and αF1 are multilinear functions. Since “multilinear” means that it is linear in each argument sepa- rately (with all the other variables ﬁxed), this follows from the corresponding fact about linear transformation; namely from the fact that the sum of linear transformations and a scalar multiple of a linear transformation are linear transformations, cf. Section 4 of Chapter 1. Then it is easy to show that L(V1, V2, . . . , Vp; V ) satisﬁes all axioms of vector space; one just need to use the fact that V satisﬁes these axioms. We leave the details as an exercise for the reader. He/she can look at Section 4 of Chapter 1, where it was shown that the set of linear transformations satisﬁes axiom 7. Literally the same proof work for multilinear functions; the proof that all other axioms are also satisﬁed is very similar. 5.1.2. Dimension of L(V1, V2, . . . , Vp; V ). Let B1, B2, . . . , Bp be bases in the spaces V1, V2, . . . , Vp respectively. Since a linear transformation is deﬁned by its action on a basis, a multilinear function F ∈ L(V1, V2, . . . , Vp; V ) is deﬁned by its values on all tuples b 1 j1, b 2 j2, . . . , bp jp, bk jk ∈ Bk. Since there are exactly (dim V1)(dim V2) . . . (dim Vp) such tuples, and each F (b1 j1, b2 j2, . . . , bp jp) is determined by dim V coordi- nates (in some basis in V ). we can conclude that F ∈ L(V1, V2, . . . , Vp; V ) is determined by (dim V1)(dim V2) . . . (dim Vp)(dim V ) entries. In other words dim L(V1, V2, . . . , Vp; V ) = (dim V1)(dim V2) . . . (dim Vp)(dim V ). 5. Multilinear functions. Tensors 241 in particular, if the target space is the ﬁeld of scalars F (i.e. if we are dealing with multilinear functionals) dim L(V1, V2, . . . , Vp; F) = (dim V1)(dim V2) . . . (dim Vp). It is easy to ﬁnd a basis in L(V1, V2, . . . , Vp; F). Namely, let for k = 1, 2, . . . , p the system Bk = {bk j } dim Vk j=1 be a basis in Vk and let B′ = {̃bk j }dim Vk j=1 be its dual system, ̃bk j ∈ V ′ k. Proposition 5.2. The system ̃b 1 j1 ⊗ ̃b 2 j2 ⊗ . . . ⊗ ̃b p jp, 1 ≤ jk ≤ dim Vk, k = 1, 2, . . . , p, is a basis in the space L(V1, V2, . . . , Vp; F). Here ̃b1 j1 ⊗ ̃b2 j2 ⊗ . . . ⊗ ̃b p jp is the tensor product of functionals, as deﬁned in (5.1). Proof. We want to represent F as (5.2) F = ∑ j1,j2,...,jp αj1,j2,...,jp ̃b1 j1 ⊗ ̃b2 j2 ⊗ . . . ⊗ ̃bp jp Since ̃bj(bl) = δj,l, we have ̃b1 j1 ⊗ ̃b2 j2 ⊗ . . . ⊗ ̃bp jp(b1 j1, b2 j2, . . . , b p jp) = 1 and(5.3) ̃b1 j1 ⊗ ̃b2 j2 ⊗ . . . ⊗ ̃bp jp(b1 j′ 1, b2 j′ 2, . . . , b p j′ p) = 0(5.4) for any collection of indices j′ 1, j′ 2, . . . , j′ p diﬀerent from j1, j2, . . . , jp. Therefore, applying (5.2) to the tuple b1 j1, b2 j2, . . . , bp jp we get αj1,j2,...,jp = F (b 1 j1, b 2 j2, . . . , bp jp), so the representation (5.2) is unique (if exists). On the other hand, deﬁning αj1,j2,...,jp := F (b1 j1, b2 j2, . . . , bp jp) and using (5.3) and (5.4), we can see that the equality (5.2) holds on all tuples of form b1 j1, b2 j2, . . . , bp jp. So decomposition (5.2) holds, so we indeed have a basis. □ 5.2. Tensor Products. Deﬁnition. Let V1, V2, . . . , Vp be vector spaces. The tensor product V1 ⊗ V2 ⊗ . . . ⊗ Vp of spaces Vk is simply the set L(V ′ 1, V ′ 2, . . . , V ′ p; F) of multilinear functionals; here V ′ k is the dual of Vk. 242 8. Dual spaces and tensors Remark 5.3. By Proposition 5.2 we get that if Bk = {bk j } dim Vk j=1 is a basis in Vk for k = 1, 2, . . . , p, then the system (5.5) b1 j1 ⊗ b2 j2 ⊗ . . . ⊗ b p jp, 1 ≤ jk ≤ dim Vk, k = 1, 2, . . . , p, is a basis in V1 ⊗ V2 ⊗ . . . ⊗ Vp. Here we treat a vector vk ∈ Vk as a linear functional on V ′ k; the tensor product of vectors v1 ⊗ v2 ⊗ . . . ⊗ vp is the deﬁned according to (5.1). Remark. The tensor product v1 ⊗ v2 ⊗ . . . ⊗ vp of vectors is clearly linear in each argument vk. In other words, the map (v1, v2, . . . , vp) 7→ v1 ⊗ v2 ⊗ . . . ⊗ vp is a multilinear functional with values in V1 ⊗ V2 ⊗ . . . ⊗ Vp. We leave the proof as an exercise for a reader, see Problem 5.1 below Remark. Note, that the set {v1 ⊗ v2 ⊗ . . . ⊗ vp : vk ∈ Vk} of tensor products of vectors is strictly less than V1 ⊗ V2 ⊗ . . . ⊗ Vp, see Problem 5.2 below. 5.2.1. Lifting a multilinear function to a linear transformation on the tensor product. Proposition 5.4. For any multilinear function F ∈ L(V1, V2, . . . , Vp; V ) there exists a unique linear transformation T : V1 ⊗ V2 ⊗ . . . ⊗ Vp → V extending F , i.e. such that (5.6) F (v1, v2, . . . , vp) = T v1 ⊗ v2 ⊗ . . . ⊗ vp, for all choices of vectors vk ∈ Vk, 1 ≤ k ≤ p. Remark. If T : V1 ⊗ V2 ⊗ . . . ⊗ Vp → V is a linear transformation, then trivially the function F , F (v1, v2, . . . , vp) := T v1 ⊗ v2 ⊗ . . . ⊗ vp, is a multilinear function in L(V1, V2, . . . , Vp; V ). This follows immediately from the fact that the expression v1 ⊗ v2 ⊗ . . . ⊗ vp is linear in each variable vk. Proof of Proposition 5.4. Deﬁne T on the basis (5.5) by T b1 j1 ⊗ b2 j2 ⊗ . . . ⊗ bp jp = F (b 1 j1, b 2 j2, . . . , bp jp) and then extend it by linearity to all space V1 ⊗ V2 ⊗ . . . ⊗ Vp. To complete the proof we need to show that (5.6) holds for all choices of vectors vk ∈ Vk, 1 ≤ k ≤ p (we now know that only when each vk is one of the vectors bk jk ). To prove that, let us decompose vk as vk = ∑ jk αk jk bk jk , k = 1, 2, . . . , p. 5. Multilinear functions. Tensors 243 Using linearity in each variable vk we get v1 ⊗ v2 ⊗ . . . ⊗ vp = ∑ j1,j2,...,jp α1 j1α2 j2, . . . , αp jpb1 j1 ⊗ b 2 j2 ⊗ . . . ⊗ bp jp, F (v1, v2, . . . , vp) = ∑ j1,j2,...,jp α1 j1α2 j2, . . . , αp jpF (b 1 j1, b 2 j2, . . . , bp jp) so by the deﬁnition of T identity (5.6) holds. □ 5.2.2. Dual of a tensor product. As one can easily see, the dual of the tensor product V1⊗V2⊗. . .⊗Vp is the tensor product of dual spaces V ′ 1 ⊗V ′ 2 ⊗. . .⊗V ′ p. Indeed, by Proposition 5.4 and remark after it, there is a natural one-to- one correspondence between multilinear functionals in L(V1, V2, . . . , Vp, F) (i.e. the elements of V ′ 1 ⊗ V ′ 2 ⊗ . . . ⊗ V ′ n) and the linear transformations T : V1 ⊗V2 ⊗. . .⊗Vp → F (i.e. with the elements of the dual of V1 ⊗V2 ⊗. . .⊗Vp). Note, that the bases from Remark 5.3 and Proposition 5.2 are the dual bases (in V1 ⊗ V2 ⊗ . . . ⊗ Vp and V ′ 1 ⊗ V ′ 2 ⊗ . . . ⊗ V ′ n respectively). Knowing the dual bases allows us easily calculate the duality between the spaces V1 ⊗ V2 ⊗ . . . ⊗ Vp and V ′ 1 ⊗ V ′ 2 ⊗ . . . ⊗ V ′ p, i.e. the expression ⟨x, x′⟩, x ∈ V1 ⊗ V2 ⊗ . . . ⊗ Vp, x′ ∈ V ′ 1 ⊗ V ′ 2 ⊗ . . . ⊗ V ′ p 5.3. Covariant and contravariant tensors. Let X1, X2, . . . , Xp be vec- tor spaces, and let Vk be either Xk or X ′ k, k = 1, 2, . . . , p. For a multilinear function F ∈ L(V1, V2, . . . , Vp; V ) we say that that it is covariant in variable vk ∈ Vk if Vk = Xk and contravariant in this variable if Vk = X ′ k. If a multilinear function is covariant (contravariant) in all variables, we say that the multilinear function is covariant (contravariant). In general, if a function is covariant in r variables and contravariant in s variables, we say that the multilinear function is r-covariant s-contravariant (or simply (r, s) multilinear function, or that its valency is (r, s)). Thus, a linear functional can be interpreted as 1-covariant tensor (recall, that we use the word tensor for the case of functionals, i.e. when the target space is the ﬁeld of scalars F). By duality, a vector can be interpreted as 1-contravariant tensor. Remark. At ﬁrst the terminology might look a bit confusing: if a variable is a vector (not a functional), it is a covariant variable but a contravariant object. But notice, that we did not say here a “covariant variable”: we said that if vk ∈ Xk then the mulitilinear function is covariant in the variable vk. So, the covariant object is not vk, but the “slot” in the tensor where we put it! So there is no contradiction, we put the contravariant objects into co- variant slots and vice versa. 244 8. Dual spaces and tensors Sometimes, slightly abusing the language, people talk about covariant (contravariant) variables or arguments. But it is usually meant that the corresponding “slots” in the tensor are covariant (contravariant), and not the variables as objects. 5.3.1. Linear transformations as tensors. A linear transformation T : X1 → X2 can be interpreted as 1-covariant 1-contravariant tensor. Namely, the bilinear functional F , F (x1, x′ 2) := ⟨T x1, x′ 2⟩, x1 ∈ X1, x′ 2 ∈ X ′ 2 is covariant in the ﬁrst variable x1 and contravariant in the second one x′ 2. Conversely, Proposition 5.5. Given a 1-1 tensor F ∈ L(X1, X ′ 2; F), there exists a unique linear transformation T : X1 → X2 such that (5.7) F (x1, x′ 2) := ⟨T x1, x′ 2⟩, for all x1 ∈ X2, x′ 2 ∈ X ′ 2. Proof. First of all note, that the uniqueness is a trivial corollary of Lemma 1.3, cf. Problem 3.1 above. So we only need to prove existence of T . Let Bk = {bk j }dim Xk j=1 be a basis in Xk, and let B′ k = {̃bk j } dim Xk j=1 be the dual basis in X ′ k, k = 1, 2. Then deﬁne the matrix A = {ak,j} dim X2 k=1 dim X1 j=1 by ak,j = F (b1 j , ̃b2 k). Deﬁne T to be the operator with matrix [T ]B2,B1 = A. Clearly (see Remark 1.5) (5.8) ⟨T b1 j , ̃b2 k⟩ = ak,j = F (b1 j , ̃b 2 k) which implies the equality (5.7). This can be easily seen by decomposing x1 = ∑ j αjbj and x′ 2 = ∑ k βkb′ k and using linearity in each argument. Another, more high brow explanation is that the tensors in left and the right sides of (5.7) coincide on a basis in X1 ⊗ X ′ 2 (see Remark 5.3 about the basis), so they coincide. To be more precise, one should lift the bilinear forms to the linear transformations (functionals) X1 ⊗ X ′ 2 → F (see Proposition 5.4), and since the transformations coincide on a basis, they are equal. One can also give an alternative, coordinate-free proof of existence of T , along the lines of the coordinate-free deﬁnition of the dual space (see Section 3.1.3). Namely, if we ﬁx x1, the function F (x1, x′ 2) is a linear in x′ 2, so it is a linear functional on X ′ 2, i.e. a vector in X2. Let us call this vector T (x1). So we deﬁned a transformation T : X1 → X2. One can easily show that T is a linear transformation by essentially 5. Multilinear functions. Tensors 245 repeating the reasoning from Section 3.1.3. The equality (5.7) follows au- thomatically from the deﬁnition of T . □ Remark. Note that we also can say that the function F from Proposition 5.5 deﬁnes not the transformation T , but its adjoint. Apriori, without as- suming anything (like order of variables and its interpretation) we cannot distinguish between a transformation and its adjoint. Remark. Note, that if we would like to follow the Einstein notation, the entries aj,k of the matrix A = [T ]B2,B1 of the transformation T should be written as aj k. Then if xk, k = 1, 2, . . . , dim X1 are the coordinates of the vector x ∈ X1, the jth coordinate of y = T x is given by yj = aj kxk. Recall the here we skip the sign of summation, but we mean the sum over k. Note also, that we preserve positions of the indices, so the index j stays upstairs. The index k does not appear in the left side of the equation because we sum over this index in the right side, and its got “killed”. Similarly, if xj, j = 1, 2, . . . , dim X2 are the coordinates of the vector x′ ∈ X ′ 2, then kth coordinate of y′ := T ′x′ is given by yk = a j kxj (again, skipping the sign of summation over j). Again, since we preserve the position of the indices, so the index k in yk is a subscript. Note, that since x ∈ X1 and y = T x ∈ X2 are vectors, according to the conventions of the Einstein notation, the indices in their coordinates indeed should be written as superscripts. Similarly, x′ ∈ X ′ 2 and y′ = T ′x′ ∈ X ′ 1 are covectors, so indices in their coordinates should be written as subscripts. The Einstein notation emphasizes the fact mentioned in the previous remark, that a 1-covariant 1-contravariant tensor gives us both a linear transformation and its adjoint: the expression a j kxk gives the action of T , and aj kxj gives the action of its adjoint T ′. 5.3.2. Polylinear transformations as tensors. More generally, any polylin- ear transformation can be interpreted as a tensor. Namely, given a poly- linear transformation F ∈ L(V1, V2, . . . , Vp; V ) one can deﬁne the tensor ̃F ∈ L(V1, V2, . . . , Vp, V ′; F) by (5.9) ̃F (v1, v2, . . . , vp, v′) = ⟨F (v1, v2, . . . , vp), v′⟩, vk ∈ Vk, v′ ∈ V ′. Conversely, 246 8. Dual spaces and tensors Proposition 5.6. Given a tensor ̃F ∈ L(V1, V2, . . . , Vp, V ′; F) there exists a unique polylinear transformation F ∈ L(V1, V2, . . . , Vp; V ) such that (5.9) is satisﬁed. Proof. By Proposition 5.4 the tensor ̃F can be extended to a linear trans- formation (functional) ̃T : V1 ⊗ V2 ⊗ . . . ⊗ Vp ⊗ V ′ → F such that ̃F (v1, v2, . . . , vp, v′) = ̃T (v1 ⊗ v2 ⊗ . . . ⊗ vp ⊗ v′) for all vk ∈ Vk, v′ ∈ V ′. If w ∈ W := V1 ⊗ V2 ⊗ . . . ⊗ Vp and v′ ∈ V ′, then w ⊗ v′ ∈ V1 ⊗ V2 ⊗ . . . ⊗ Vp ⊗ V ′. So, we can deﬁne a bilinear functional (tensor) G ∈ L(W, V ′; F) by G(w, v′) := ̃T (w ⊗ v). By Proposition 5.5, G gives rise to a linear transformation, i.e. there exists a unique linear transformation T : W → V such that G(w, v′) = ⟨T w, v′⟩ ∀w ∈ W, ∀v′ ∈ V ′. And the linear transformation T gives us the polylinear map F ∈ L(V1, V2, . . . , Vp; V ) by F (v1, v2, . . . , vp) = T (v1 ⊗ v2 ⊗ . . . ⊗ vp), see Remark after Proposition 5.4. The uniqueness of the transformation F , is, as in Proposition 5.5, is a trivial corollary of Lemma 1.3. We leave the details as an exercise for the reader. □ This section shows that tensors are universal objects in polylinear algebra, since any poly- linear transformation can be interpreted as a tensor and vice versa. Exercises. 5.1. Show that the tensor product v1 ⊗ v2 ⊗ . . . ⊗ vp of vectors is linear in each argument vk. 5.2. Show that the set {v1 ⊗ v2 ⊗ . . . ⊗ vp : vk ∈ Vk} of tensor products of vectors is strictly less than V1 ⊗ V2 ⊗ . . . ⊗ Vp. 5.3. Prove that the transformation F from Proposition 5.6 is unique. 6. Change of coordinates formula for tensors. 247 6. Change of coordinates formula for tensors. The main reason for the diﬀerentiation of covariant and contravariant vari- ables is that under the change of bases, their coordinates change according to diﬀerent rules. Thus, the entries of covariant and contravariant vectors change according to diﬀerent rules as well. In this section we going to investigate this in details. Note, that coor- dinate representations are extremely important, since, for example, all nu- merical computations (unlike the theoretical investigations) are performed using some coordinate system. 6.1. Coordinate representation of a tensor. Let F be an r-covariant s-contravariant tensor, r + s = p. Let x1, . . . , xr be covariant variables (xk ∈ Xk), and f1, . . . , fs be the contravariant ones (fk ∈ X ′ k). Let us write the covariant variables ﬁrst, so the the tensor will be written as F (x1, . . . , xr, f1, . . . , fs). For k = 1, 2, . . . , p ﬁx a basis Bk = {b(k) j }dim Xk j=1 in Xk, and let B′ k = {̃b (k) j }dim Xk j=1 be the dual basis in X ′ k. For a vector xk ∈ Xk let xj (k), j = 1, 2, . . . , dim Xk be its coordinates in the basis Bk, and similarly, if fk ∈ X ′ k let f (k) j , j = 1, 2, . . . , dim Xk be its coordinates in the dual basis B′ k (note that in agreement with the Einstein notation, the coordinates of the vector are indexed by a superscript, and the coordinate of a covector re indexed by a subscript). Proposition 6.1. Denote (6.1) ϕ k1,...,ks j1,...,jr := F (b(1) j1 , . . . , b(r) jr , ̃b(r+1) k1 , . . . , ̃b(r+s) ks ). Then, in the Einstein notation (6.2) F (x1, . . . , xr, f1, . . . , fs) = ϕ k1,...,ks j1,...,jr xj1 (1) . . . x jr (r)f (1) k1 . . . f (s) ks (the summation here is over the indices j1, . . . , jr and k1, . . . , ks). Note that we use the notation (1), . . . , (r) and (1), . . . , (s) to emphasize that these are not the indices: the numbers in parenthesis just show the order of argument. Thus, right side of (6.2) does not have any indices left (all indices were used in summation), so it is just a number (for ﬁxed xks and fks). Proof of Proposition 6.1. To show that (6.1) implies (6.2) we ﬁrst notice that (6.1) means that (6.2) hods when xjs and fks are the elements of the corresponding bases. Decomposing each argument xj and fk in the corre- sponding basis and using linearity in each argument we can easily get (6.2). The computation is rather simple, but because there are a lot of indices, the formulas could be quite big and could look quite frightening. 248 8. Dual spaces and tensors To avoid writing too many huge formulas, we leave this computation to the reader as an exercise. We do not want the reader to feel cheated, so we present a diﬀerent, more “high brow” (abstract) explanation, which does not require any com- putations! Namely, let us notice that the expressions in the left and the right side of (6.2) deﬁne tensors. By Proposition 5.4 they can be lifted to linear functionals on the tensor product X1 ⊗ . . . ⊗ Xr ⊗ X ′ r+1 ⊗ . . . ⊗ X ′ r+s. Rephrasing what we discussed in the beginning of the proof, we can say that (6.1) means that the functional coincide on all vectors b(1) j1 ⊗ . . . ⊗ b (r) jr ⊗ ̃b (r+1) k1 ⊗ . . . ⊗ ̃b(r+s) ks of a basis in the tensor product, so the functionals (and therefore the tensors) are equal. □ The entries ϕ k1,...,ks j1,...,jr are called the entries of the tensor F in the bases Bk, k = 1, 2, . . . , p. Now, let for k = 1, 2, . . . p, Ak be a basis in Xk (and A′ k be the dual basis in X ′ k). We want to investigate how the entries of the tensor F change when we change the bases from Bk to Ak. 6.2. Change of coordinate formulas in Einstein notation. Let us ﬁrst consider the familiar cases of vectors and linear functionals, considered above in Section 1.1.1 but write everything down using the Einstein notation. Let we have in X two bases, B and A and let A = [A]A,B be the change of coordinates matrix from B to A. For a vector x ∈ X let xk be its coordinates in the basis B and ̃xk be the coordinates in the basis A. Similarly, for f ∈ X ′ let fk denote the coordinates in the basis B′ and ̃fk–the coordinates in the basis A′ (B′ and A′ are the dual bases to B and A respectively). Denote by (A)j k the entries of the matrix A: to be consistent with the Einstein notation the superscript j denotes the number of the row. Then we can write the change of coordinate formula as (6.3) ̃xj = (A)j kxk. Similarly, let (A−1)k j be the entries of A−1: again superscript is used to denote the number of the row. Then we can write the change of coordinate formula for the dual space as (6.4) ̃fj = (A−1) k j fk; 6. Change of coordinates formula for tensors. 249 the summation here is over the index k (i.e. along the columns of A−1), so the change of coordinate matrix in this case is indeed (A−1)T . Let us emphasize that we did not prove anything here: we only rewrote formula (1.1) from Section 1.1.1 using the Einstein notation. Remark. While it is not needed in what follows, let us play a bit more with the Einstein notation. Namely, the equations A−1A = I and AA−1 = I can be rewritten in the Einstein notation as (A)j k(A−1)k l = δj,l and (A−1) k j (A)j l = δk,l respectively. 6.3. Change of coordinates formula for tensors. Now we are ready to give the change of coordinate formula for general tensors. For k = 1, 2, . . . , p := r + s let Ak := [I]A,B be the change of coordinates matrices, and let A −1 k be their inverses. As in Section 6.2 we denote by (A) j k the entries of a matrix A, with the agreement that superscript gives the number of the column. Proposition 6.2. Given an r-covariant s-contravariant tensor F let ϕ k1,...,ks j1,...,jr and ̃ϕ k1,...,ks j1,...,jr be its entries in the bases Bk (the old ones) and Ak (the new ones) respec- tively. In the above notation ̃ϕ k1,...,ks j1,...,jr = ϕ k′ 1,...,k′ s j′ 1,...,j′ r (A−1 1 )j′ 1 j1 . . . (A−1 r ) j′ r jr (Ar+1) k1 k′ 1 . . . (Ar+s) ks k′ s (the summation here is in the indices j′ 1, . . . , j′ r and k′ 1, . . . , ks). Because of many indices, the formula in this proposition looks very com- plicated. However if one understands the main idea, the formula will turn out to be quite simple and easy to memorize. To explain the main idea let us, sightly abusing the language, express this formula “in plain English”. namely, we can say, that To express the “new” tensor entries ̃ϕk1,...,ks j1,...,jr in terms of the “old” ones ϕ k1,...,ks j1,...,jr , one needs for each covariant index (subscript) apply the covariant rule (6.4), and for each contravariant index (super- script) apply the contravariant rule (6.3) Proof of Proposition 6.2. Informally, the idea of the proof is very simple: we just change the bases one at a time, applying each time the change 250 8. Dual spaces and tensors of coordinate formulas (6.3) or (6.4), depending on whether the tensor is covariant or contravariant in the corresponding variable. To write the rigorous formal proof we will use the induction in r ans s (the number of covariant and contravariant arguments of the tensor). Proposition is true for r = 1, s = 0 and for r = 0, s = 1, see (6.4) or (6.3) respectively. Assuming now that the proposition is proved for some p and s, let us prove it for r + 1, s and for r, s + 1. Let us do the latter case, the other one is done similarly. The maid idea is that we ﬁrst change p = r + s bases and use the induction hypothesis; then we change the last one and use (6.3). Namely, let ̂ϕ k1,...,ks+1 j1,...,jr be the entries of an (r, s + 1) tensor F in the bases A1, . . . , Ap, Bp+1, p = r + s. Let us ﬁx the index ks+1 and consider the r-covariant s-contravariant tensor F (x1, . . . , xr, f1, . . . , fs, ̃b (r+s+1) s+1 ), where x1, . . . , xr, f1, . . . , fs are the variables. Clearly ϕ k1,...,ks,ks+1 j1,...,jr and ̂ϕ k1,...,ks,ks+1 j1,...,jr are its entries in the bases B1, . . . , Bp and A1, . . . , Ap respectively (can you see why?) Recall, that the index ks+1 here is ﬁxed. By the induction hypothesis (6.5) ̂ϕ k1,...,ks,ks+1 j1,...,jr = ϕ k′ 1,...,k′ s,ks+1 j′ 1,...,j′ r (A−1 1 ) j′ 1 j1 . . . (A−1 r ) j′ r jr (Ar+1) k1 k′ 1 . . . (Ar+s) ks k′ s. Note, that we did not assume anything about the index ks+1, so (6.5) holds for all ks+1. Now let us ﬁx indices j1, . . . , jr, k1, . . . , ks and consider 1-contravariant tensor F (a(1) j1 , . . . , a (r) jr , ̃a(r+1) k1 , . . . , ̃a (r+s) ks , fs+1) of the variable fs+1. Here a (k) j are the vectors in the basis Ak and ̃a (k) j are the vectors in the dual basis A′ k. It is again easy to see that ̂ϕ k1,...,ks,ks+1 j1,...,jr and ̃ϕ k1,...,ks,ks+1 j1,...,jr , js+1 = 1, 2, . . . , dim Xp+1, are the indices of this functional in the bases Bp+1 and Ap+1 respectively. According to (6.3) ̃ϕ k1,...,ks,ks+1 j1,...,jr = ̂ϕ k1,...,ks,k′ s+1 j1,...,jr (Ap+1) ks+1 k′ s+1, and since we did not assume anything about the indices j1, . . . , jr, k1, . . . , ks, the above identity holds for all their combinations. Combining this with (6.5) we get that the proposition holds for tensors of valency (r, s + 1). 6. Change of coordinates formula for tensors. 251 The case of valency (r + 1, s) is treated absolutely the same way: the only diﬀerence is that in the end we get a 1-covariant tensor and use (6.4) instead of (6.3). □ Chapter 9 Advanced spectral theory 1. Cayley–Hamilton Theorem Theorem 1.1 (Cayley–Hamilton). Let A be a square matrix, and let p(λ) = det(A − λI) be its characteristic polynomial. Then p(A) = 0. A wrong proof. The proof looks ridiculously simple: plugging A instead of λ in the deﬁnition of the characteristic polynomial we get p(A) = det(A − AI) = det 0 = 0. □ But this is a wrong proof! To see why, let us analyze what the theorem states. It states, that if we compute the characteristic polynomial det(A − λI) = p(λ) = n∑ k=0 ckλ k and then plug matrix A instead of λ to get p(A) := n∑ k=0 ckAk = c0I + c1A + . . . + cnAn then the result will be zero matrix. It is not clear why we get the same result if we just plug A instead of λ in the determinant det(A − λI). Moreover, it is easy to see that with the exception of trivial case of 1 × 1 matrices we will get a diﬀerent object. Namely, A − AI is zero matrix, and its determinant is just the number 0. 253 254 9. Advanced spectral theory But p(A) is a matrix, and the theorem claims that this matrix is the zero matrix. Thus we are comparing apples and oranges. Even though in both cases we got zero, these are diﬀerent zeroes: he number zero and the zero matrix! Let us present another proof, which is based on some ideas from analysis. This proof illus- trates an important idea that often it is suﬃcient to con- sider only a typical, generic situation. It is going beyond the scope of the book, but let us mention, without going into details, that a generic (i.e. typical) matrix is diagonalizable. A “continuous” proof. The proof is based on several observations. First of all, the theorem is trivial for diagonal matrices, and so for matrices similar to diagonal (i.e. for diagonalizable matrices), see Problem 1.1 below. The second observation is that any matrix can be approximated (as close as we want) by diagonalizable matrices. Since any operator has an upper triangular matrix in some orthonormal basis (see Theorem 1.1 in Chapter 6), we can assume without loss of generality that A is an upper triangular matrix. We can perturb diagonal entries of A (as little as we want), to make them all diﬀerent, so the perturbed matrix ̃A is diagonalizable (eigenvalues of a a triangular matrix are its diagonal entries, see Section 1.7 in Chapter 4, and by Corollary 2.3 in Chapter 4 an n × n matrix with n distinct eigenvalues is diagonalizable). As I just mentioned, we can perturb the diagonal entries of A as little as we want, so Frobenius norm ∥A − ̃A∥2 is as small as we want. Therefore one can ﬁnd a sequence of diagonalizable matrices Ak such that Ak → A as k → ∞ for example such that ∥Ak − A∥2 → 0 as k → ∞). It can be shown that the characteristic polynomials pk(λ) = det(Ak − λI) converge to the characteristic polynomial p(λ) = det(A − λI) of A. Therefore p(A) = lim k→∞ pk(Ak). But as we just discussed above the Cayley–Hamilton Theorem is trivial for diagonalizable matrices, so pk(Ak) = 0. Therefore p(A) = limk→∞ 0 = 0. □ This proof is intended for a reader who is comfortable with such ideas from analysis as continuity and convergence1. Such a reader should be able to ﬁll in all the details, and for him/her this proof should look extremely easy and natural. However, for others, who are not comfortable yet with these ideas, the proof deﬁnitely may look strange. It may even look like some kind of cheat- ing, although, let me repeat that it is an absolutely correct and rigorous proof (modulo some standard facts in analysis). So, let us present another, 1Here I mean analysis, i.e. a rigorous treatment of continuity, convergence, etc, and not calculus, which, as it is taught now, is simply a collection of recipes. 1. Cayley–Hamilton Theorem 255 proof of the theorem which is one of the “standard” proofs from linear al- gebra textbooks. A “standard” proof. We know, see Theorem 6.1.1 from Chapter 6, that any square matrix is unitary equivalent to an upper triangular one. Since for any polynomial p we have p(U AU −1) = U p(A)U −1, and the characteristic polynomials of unitarily equivalent matrices coincide, it is suﬃcient to prove the theorem only for upper triangular matrices. So, let A be an upper triangular matrix. We know that diagonal entries of a triangular matrix coincide with it eigenvalues, so let λ1, λ2, . . . , λn be eigenvalues of A ordered as they appear on the diagonal, so A =      λ1 ∗ λ2 . . . 0 λn  | | |  . The characteristic polynomial p(z) = det(A − zI) of A can be represented as p(z) = (λ1 − z)(λ2 − z) . . . (λn − z) = (−1)n(z − λ1)(z − λ2) . . . (z − λn), so p(A) = (−1) n(A − λ1I)(A − λ2I) . . . (A − λnI). Deﬁne subspaces Ek := span{e1, e2, . . . , ek}, where e1, e2, . . . , en is the standard basis in Cn. Since the matrix of A is upper triangular, the sub- spaces Ek are so-called invariant subspaces of the operator A, i.e. AEk ⊂ Ek (meaning that Av ∈ Ek for all v ∈ Ek). Moreover, since for any v ∈ Ek and any λ (A − λI)v = Av − λv ∈ Ek, because both Av and λv are in Ek. Thus (A − λI)Ek ⊂ Ek, i.e. Ek is an invariant subspace of A − λI. We can say even more about the the subspace (A − λkI)Ek. Namely, (A − λkI)ek ∈ span{e1, e2, . . . , ek−1}, because only the ﬁrst k − 1 entries of the kth column of the matrix of A − λkI can be non-zero. On the other hand, for j < k we have (A − λk)ej ∈ Ej ⊂ Ek (because Ej is an invariant subspace of A − λkI). Take any vector v ∈ Ek. By the deﬁnition of Ek it can be repre- sented as a linear combination of the vectors e1, e2, . . . , ek. Since all vectors e1, e2, . . . , ek are transformed by A − λkI to some vectors in Ek−1, we can conclude that (1.1) (A − λkI)v ∈ Ek−1 ∀v ∈ Ek. 256 9. Advanced spectral theory Take an arbitrary vector x ∈ Cn = En. Applying (1.1) inductively with k = n, n − 1, . . . 1 we get x1 := (A − λnI)x ∈ En−1, x2 := (A − λn−1I)x1 = (A − λn−1I)(A − λnI)x ∈ En−2, . . . xn := (A − λ2I)xn−1 = (A − λ2I) . . . (A − λn−1I)(A − λnI)x ∈ E1. The last inclusion mean that xn = αe1. But (A − λ1I)e1 = 0, so 0 = (A − λ1I)xn = (A − λ1I)(A − λ2I) . . . (A − λnI)x. Therefore p(A)x = 0 for all x ∈ Cn, which means exactly that p(A) = 0. □ Exercises. 1.1 (Cayley–Hamilton Theorem for diagonalizable matrices). As discussed in the above section, the Cayley–Hamilton theorem states that if A is a square matrix, and p(λ) = det(A − λI) = n∑ k=0 ckλ k is its characteristic polynomial, them p(A) := ∑n k=0 ckAk = 0 (we assuming, that by deﬁnition A0 = I). Prove this theorem for the special case when A is similar to a diagonal matrix, A = SDS−1. Hint: If D = diag{λ1, λ2, . . . , λn} and p is any polynomial, can you compute p(D)? What about p(A)? 2. Spectral Mapping Theorem 257 2. Spectral Mapping Theorem 2.1. Polynomials of operators. Let us also recall that for a square ma- trix (an operator) A and for a polynomial p(z) = ∑N k=1 akzk the operator p(A) is deﬁned by substituting A instead of the independent variable, p(A) := N∑ k=1 akAk = a0I + a1A + a2A2 + . . . + aN AN ; here we agree that A0 = I. We know that generally matrix multiplication is not commutative, i.e. generally AB ̸= BA so the order is essential. However A kAj = A jA k = Ak+j, and from here it is easy to show that for arbitrary polynomials p and q p(A)q(A) = q(A)p(A) = R(A) where R(z) = p(z)q(z). That means that when dealing only with polynomials of an operator A, one does not need to worry about non-commutativity, and act like A is simply an independent (scalar) variable. In particular, if a polynomial p(z) can be represented as a product of monomials p(z) = a(z − z1)(z − z2) . . . (z − zN ), where z1, z2, . . . , zN are the roots of p, then p(A) can be represented as p(A) = a(A − z1I)(A − z2I) . . . (A − zN I) 2.2. Spectral Mapping Theorem. Let us recall that the spectrum σ(A) of a square matrix (an operator) A is the set of all eigenvalues of A (not counting multiplicities). Theorem 2.1 (Spectral Mapping Theorem). For a square matrix A and an arbitrary polynomial p σ(p(A)) = p(σ(A)). In other words, µ is an eigenvalue of p(A) if and only if µ = p(λ) for some eigenvalue λ of A. Note, that as stated, this theorem does not say anything about multi- plicities of the eigenvalues. Remark. Note, that one inclusion is trivial. Namely, if λ is an eigenvalue of A, Ax = λx for some x ̸= 0, then Akx = λkx, and p(A)x = p(λ)x, so p(λ) is an eigenvalue of p(A). That means that the inclusion p(σ(A)) ⊂ σ(p(A)) is trivial. 258 9. Advanced spectral theory If we consider a particular case µ = 0 of the above theorem, we get the following corollary. Corollary 2.2. Let A be a square matrix with eigenvalues λ1, λ2, . . . , λn and let p be a polynomial. Then p(A) is invertible if and only if p(λk) ̸= 0 ∀k = 1, 2, . . . , n. Proof of Theorem 2.1. As it was discussed above, the inclusion p(σ(A)) ⊂ σ(p(A)) is trivial. To prove the opposite inclusion σ(p(A)) ⊂ p(σ(A)) take a point µ ∈ σ(p(A)). Denote q(z) = p(z) − µ, so q(A) = p(A) − µI. Since µ ∈ σ(p(A)) the operator q(A) = p(A) − µI is not invertible. Let us represent the polynomial q(z) as a product of monomials, q(z) = a(z − z1)(z − z2) . . . (z − zN ). Then, as it was discussed above in Section 2.1, we can represent q(A) = a(A − z1I)(A − z2I) . . . (A − zN I). The operator q(A) is not invertible, so one of the terms A − zkI must be not invertible (because a product of invertible transformations is always invertible). That means zk ∈ σ(A). On the other hand zk is a root of q, so 0 = q(zk) = p(zk) − µ and therefore µ = p(zk). So we have proved the inclusion σ(p(A)) ⊂ p(σ(A)). □ Exercises. 2.1. An operator A is called nilpotent if Ak = 0 for some k. Prove that if A is nilpotent, then σ(A) = {0} (i.e. that 0 is the only eigenvalue of A). Can you do it without using the spectral mapping theorem? 3. Generalized eigenspaces 259 3. Generalized eigenspaces. Geometric meaning of algebraic multiplicity 3.1. Invariant subspaces. Deﬁnition. Let A : V → V be an operator (linear transformation) in a vector space V . A subspace E of the vector space V is called an invariant subspace of the operator A (or, shortly, A-invariant) if AE ⊂ E, i.e. if Av ∈ E for all v ∈ E. If E is A-invariant, then A2E = A(AE) ⊂ AE ⊂ E, i.e. E is A2-invariant. Similarly one can show (using induction, for example), that if AE ⊂ E then AkE ⊂ E ∀k ≥ 1. This implies that P (A)E ⊂ E for any polynomial p, i.e. that: any A-invariant subspace E is an invariant subspace of p(A). If E is an A-invariant subspace, then for all v ∈ E the result Av also belongs to E. Therefore we can treat A as an operator acting on E, not on the whole space V . Formally, for an A-invariant subspace E we deﬁne the so-called restric- tion A|E : E → E of A onto E by (A|E)v = Av ∀v ∈ E. Here we changed domain and target space of the operator, but the rule assigning value to the argument remains the same. We will need the following simple lemma Lemma 3.1. Let p be a polynomial, and let E be an A-invariant subspace. Then p(A|E) = p(A)|E. Proof. The proof is trivial □ If E1, E2, . . . , Er a basis of A-invariant subspaces, and Ak := A|Ek are the corresponding restrictions, then, since AEk = AkEk ⊂ Ek, the operators Ak act independently of each other (do not interact), and to analyze action of A we can analyze operators Ak separately. 260 9. Advanced spectral theory In particular, if we pick a basis in each subspace Ek and join them to get a basis in V (see Theorem 2.6 from Chapter 4) then the operator A will have in this basis the following block-diagonal form A =      A1 A2 0 . . . 0 Ar  | | |  (of course, here we have the correct ordering of the basis in V , ﬁrst we take a basis in E1,then in E2 and so on). Our goal now is to pick a basis of invariant subspaces E1, E2, . . . , Er such that the restrictions Ak have a simple structure. In this case we will get a basis in which the matrix of A has a simple structure. The eigenspaces Ker(A − λkI) would be good candidates, because the restriction of A to the eigenspace Ker(A−λkI) is simply λkI. Unfortunately, as we know eigenspaces do not always form a basis (they form a basis if and only if A can be diagonalized, cf Theorem 2.1 in Chapter 4. However, the so-called generalized eigenspaces will work. 3.2. Generalized eigenspaces. Deﬁnition 3.2. A vector v is called a generalized eigenvector (correspond- ing to an eigenvalue λ) if (A − λI)kv = 0 for some k ≥ 1. The collection Eλ of all generalized eigenvectors, together with 0 is called the generalized eigenspace (corresponding to the eigenvalue λ. In other words one can represent the generalized eigenspace Eλ as (3.1) Eλ = ⋃ k≥1 Ker(A − λI)k. The sequence Ker(A − λI)k, k = 1, 2, 3, . . . is an increasing sequence of subspaces, i.e. Ker(A − λI) k ⊂ Ker(A − λI) k+1 ∀k ≥ 1. The representation (3.1) does not look very simple, for it involves an in- ﬁnite union. However, the sequence of the subspaces Ker(A−λI)k stabilizes, i.e. Ker(A − λI)k = Ker(A − λI) k+1 ∀k ≥ kλ, so, in fact one can take the ﬁnite union. To show that the sequence of kernels stabilizes, let us notice that if for ﬁnite-dimensional subspaces E and F we have E ⫋ F (symbol E ⫋ F means that E ⊂ F but E ̸= F ), then dim E < dim F . 3. Generalized eigenspaces 261 Since dim Ker(A − λI)k ≤ dim V < ∞, it cannot grow to inﬁnity, so at some point Ker(A − λI) k = Ker(A − λI) k+1. The rest follows from the lemma below. Lemma 3.3. Let for some k Ker(A − λI) k = Ker(A − λI) k+1. Then Ker(A − λI)k+r = Ker(A − λI) k+r+1 ∀r ≥ 0. Proof. Let v ∈ Ker(A − λI)k+r+1, i.e. (A − λI)k+r+1v = 0. Then w := (A − λI)r ∈ Ker(A − λI) k+1. But we know that Ker(A − λI)k = Ker(A − λI)k+1 so w ∈ Ker(A − λI)k, which means (A − λI)kw = 0. Recalling the deﬁnition of w we get that (A − λI)k+rv = (A − λI)kw = 0 so v ∈ Ker(A−λI)k+r. We proved that Ker(A−λI)k+r+1 ⊂ Ker(A−λI)k+r. The opposite inclusion is trivial. □ Deﬁnition. The number d = d(λ) on which the sequence Ker(A − λI)k stabilizes, i.e. the number d such that Ker(A − λI) d−1 ⫋ Ker(A − λI)d = Ker(A − λI)d+1 is called the depth of the eigenvalue λ. It follows from the deﬁnition of the depth, that for the generalized eigenspace Eλ (3.2) (A − λI) d(λ)v = 0 ∀v ∈ Eλ. Now let us summarize, what we know about generalized eigenspaces. a) Eλ is an invariant subspace of A, AEλ ⊂ Eλ. b) If d(λ) is the depth of the eigenvalue λ, then ((A − λI)|Eλ) d(λ) = (A|Eλ − λIEλ)d(λ) = 0. (this is just another way of writing (3.2)) c) σ(A|Eλ) = {λ}, because the operator A|Eλ − λIEλ, is nilpotent, see 2, and the spectrum of nilpotent operator consists of one point 0, see Problem 2.1 Now we are ready to state the main result of this section. Let A : V → V . 262 9. Advanced spectral theory Theorem 3.4. Let σ(A) consists of r points λ1, λ2, . . . , λr, and let Ek := Eλk be the corresponding generalized eigenspaces. Then the system of sub- space E1, E2, . . . , Er is a basis of subspaces in V . Remark 3.5. If we join the bases in all generalized eigenspaces Ek, then by Theorem 2.6 from Chapter 4 we will get a basis in the whole space. In this basis the matrix of the operator A has the block diagonal form A = diag{A1, A2, . . . , Ar}, where Ak := A|Ek , Ek = Eλk . It is also easy to see, see (3.2) that the operators Nk := Ak − λkIEk are nilpotent, N dk k = 0. Proof of Theorem 3.4. Let mk be the multiplicity of the eigenvalue λk, so p(z) = ∏r k=1(z − λk)mk is the characteristic polynomial of A. Deﬁne pk(z) = p(z)/(z − λk)mk = ∏ j̸=k(z − λj) mj . Lemma 3.6. (3.3) (A − λkI) mk |Ek = 0, Proof. There are 2 possible simple proofs. The ﬁrst one is to notice that mk ≥ dk, where dk is the depth of the eigenvalue λk and use the fact that (A − λkI) dk |Ek = (Ak − λkIEk )mk = 0, where Ak := A|Ek (property 2 of the generalized eigenspaces). The second possibility is to notice that according to the Spectral Map- ping Theorem, see Corollary 2.2, the operator Pk(A)|Ek = pk(Ak) is invert- ible. By the Cayley–Hamilton Theorem (Theorem 1.1) 0 = p(A) = (A − λkI)mk pk(A), and restriction all operators to Ek we get 0 = p(Ak) = (Ak − λkIEk ) mk pk(Ak), so (Ak − λkIEk ) mk = p(Ak)pk(Ak) −1 = 0 pk(Ak) −1 = 0. □ To prove the theorem deﬁne q(z) = r∑ k=1 pk(z). Since pk(λj) = 0 for j ̸= k and pk(λk) ̸= 0, we can conclude that q(λk) ̸= 0 for all k. Therefore, by the Spectral Mapping Theorem, see Corollary 2.2, the operator B = q(A) is invertible. 3. Generalized eigenspaces 263 Note that BEk ⊂ Ek (any A-invariant subspace is also p(A)-invariant). Since B is an invertible operator, dim(BEk) = dim Ek, which together with BEk ⊂ Ek implies BEk = Ek. Multiplying the last identity by B−1 we get that B−1Ek = Ek, i.e. that Ek is an invariant subspace of B−1. Note also, that it follows from (3.3) that pk(A)|Ej = 0 ∀j ̸= k, because pk(A)|Ej = pk(Aj) and pk(Aj) contains the factor (Aj − λjIEj )mj = 0. Deﬁne the operators Pk by Pk = B−1pk(A). Lemma 3.7. For the operators Pk deﬁned above a) P1 + P2 + . . . + Pr = I; b) Pk|Ej = 0 for j ̸= k; c) Ran Pk ⊂ Ek; d) moreover, Pkv = v ∀v ∈ Ek, so, in fact Ran Pk = Ek. Proof. Property 1 is trivial: r∑ k=1 Pk = B−1 r∑ k=1 Pkpk(A) = B−1B = I. Property 2 follows from (3.3). Indeed, pk(A) contains the factor (A − λj)mj , restriction of which to Ej is zero. Therefore pk(A)|Ej = 0 and thus Pk|Ej = B−1pk(A)|Ej = 0. To prove property 3, recall that according to Cayley–Hamilton Theorem p(A) = 0. Since p(z) = (z − λk)mk pk(z), we have for w = pk(A)v (A − λkI)mk w = (A − λkI)mk pk(A)v = p(A)v = 0. That means, any vector w in Ran pk(A) is annihilated by some power of (A − λkI), which by deﬁnition means that Ran pk(A) ⊂ Ek. To prove the last property, let us notice that it follows from (3.3) that for v ∈ Ek pk(A)v = r∑ j=1 pj(A)v = Bv, which implies Pkv = B−1Bv = v. □ Now we are ready to complete the proof of the theorem. Take v ∈ V and deﬁne vk = Pkv. Then according to Statement c) of Lemma 3.7, vk ∈ Ek, 264 9. Advanced spectral theory and by Statement a), v = r∑ k=1 vk, so v admits a representation as a linear combination. To show that this representation is unique, we can just note, that if v is represented as v = ∑r k=1 vk, vk ∈ Ek, then it follows from the Statements b) and d) of Lemma 3.7 that Pkv = Pk(v1 + v2 + . . . + vr) = Pkvk = vk. □ 3.3. Geometric meaning of algebraic multiplicity. Proposition 3.8. Algebraic multiplicity of an eigenvalue equals the dimen- sion of the corresponding generalized eigenspace. Proof. According to Remark 3.5, if we joint bases in generalized eigenspaces Ek = Eλk to get a basis in the whole space, the matrix of A in any such basis has a block-diagonal form diag{A1, A2, . . . , Ar}, where Ak := A|Ek . Operators Nk = Ak − λkIEk are nilpotent, so σ(Nk) = {0}. Therefore, the spectrum of the operator Ak (recall that Ak = Nk − λkI) consists of one eigenvalue λk of (algebraic) multiplicity nk = dim Ek. The multiplicity equals nk because an operator in a ﬁnite-dimensional space V has exactly dim V eigenvalues counting multiplicities, and Ak has only one eigenvalue. Note that we are free to pick bases in Ek, so let us pick them in such a way that the corresponding blocks Ak are upper triangular. Then det(A − λI) = r∏ k=1 det(Ak − λIEk ) = r∏ k=1 (λk − λ) nk . But this means that the algebraic multiplicity of the eigenvalue λk is nk = dim Eλk . □ 3.4. An important application. The following corollary is very impor- tant for diﬀerential equations. Corollary 3.9. Any operator A in V can be represented as A = D + N , where D is diagonalizable (i.e. diagonal in some basis) and N is nilpotent (N m = 0 for some m), and DN = N D. Proof. As we discussed above, see Remark 3.5, if we join the bases in Ek to get a basis in V , then in this basis A has the block diagonal form A = diag{A1, A2, . . . , Ar}, where Ak := A|Ek , Ek = Eλk . The operators Nk := Ak−λkIEk are nilpotent, and the operator D = diag{λ1IE1, λ2IE2 . . . , λrIEr } 3. Generalized eigenspaces 265 is diagonal (in this basis). Notice also that λkIEk Nk = NkλkIEk (iden- tity operator commutes with any operator), so the block diagonal operator N = diag{N1, N2, . . . , Nr} commutes with D, DN = N D. Therefore, deﬁn- ing N as the block diagonal operator N = diag{N1, N2, . . . , Nr} we get the desired decomposition. □ This corollary allows us to compute functions of operators. Let us recall that if p is a polynomial of degree d, then p(a + x) can be computed with the help of Taylor’s formula p(a + x) = d∑ k=0 p(k)(a) k! xk This formula is an algebraic identity, meaning that for each polynomial p we can check that the formula is true using formal algebraic manipulations with a and x and not caring about their nature. Since operators D and N commute, DN = N D, the same rules as for usual (scalar) variables apply to them, and we can write (by plugging D instead of a and N instead of x p(A) = p(D + N ) = d∑ k=0 p(k)(D) k! N k. Here, to compute the derivative p(k)(D) we ﬁrst compute the kth derivative of the polynomial p(x) (using the usual rules from calculus), and then plug D instead of x. But since N is nilpotent, N m = 0 for some m, only ﬁrst m terms can be non-zero, so p(A) = p(D + N ) = m−1∑ k=0 f (k)(D) k! N k. In m is much smaller than d, this formula makes computation of p(A) much easier. The same approach works if p is not a polynomial, but an inﬁnite power series. For general power series we have to be careful about convergence of all the series involved, so we cannot say that the formula is true for an arbitrary power series p(x). However, if the radius of convergence of the power series is ∞, then everything works ﬁne. In particular, if p(x) = ex, then, using the fact that (ex)′ = ex we get. e A = m−1∑ k=0 eD k! N k = eD m−1∑ k=0 1 k! N k This formula has important applications in diﬀerential equation. 266 9. Advanced spectral theory Note, that the fact that N D = DN is essential here! 4. Structure of nilpotent operators Recall, that an operator A in a vector space V is called nilpotent if Ak = 0 for some exponent k. In the previous section we have proved, see Remark 3.5, that if we join the bases in all generalized eigenspaces Ek = Eλk to get a basis in the whole space, then the operator A has in this basis a block diagonal form diag{A1, A2, . . . , Ar} and operators Ak ca be represented as Ak = λkI + Nk, where Nk are nilpotent operators. In each generalized eigenspace Ek we want to pick up a basis such that the matrix of Ak in this basis has the simplest possible form. Since matrix (in any basis) of the identity operator is the identity matrix, we need to ﬁnd a basis in which the nilpotent operator Nk has a simple form. Since we can deal with each Nk separately, we will need to consider the following problem: For a nilpotent operator A ﬁnd a basis such that the matrix of A in this basis is simple. Let see, what does it mean for a matrix to have a simple form. It is easy to see that the matrix (4.1)         0 1 0 0 1 0 . . . . . . 1 0 0  | | | | | |  is nilpotent. These matrices (together with 1 × 1 zero matrices) will be our “building blocks”. Namely, we will show that for any nilpotent operator one can ﬁnd a basis such that the matrix of the operator in this basis has the block diagonal form diag{A1, A2, . . . , Ar}, where each Ak is either a block of form (4.1) or a 1 × 1 zero block. Let us see what we should be looking for. Suppose the matrix of an operator A has in a basis v1, v2, . . . , vp the form (4.1). Then Av1 = 0(4.2) and Avk+1 = vk, k = 1, 2, . . . , p − 1.(4.3) 4. Structure of nilpotent operators 267 Thus we have to be looking for the chains of vectors v1, v2, . . . , vp satisfying the above relations (4.2), (4.3). 4.1. Cycles of generalized eigenvectors. Deﬁnition. Let A be a nilpotent operator. A chain of non-zero vectors v1, v2, . . . , vp satisfying relations (4.2), (4.3) is called a cycle of generalized eigenvectors of A. The vector v1 is called the initial vector of the cycle, the vector vp is called the end vector of the cycle, and the number p is called the length of the cycle. Remark. A similar deﬁnition can be made for an arbitrary operator. Then all vectors vk must belong to the same generalized eigenspace Eλ, and they must satisfy the identities (A − λI)v1 = 0, (A − λI)vk+1 = vk, k = 1, 2, . . . , p − 1, Theorem 4.1. Let A be a nilpotent operator, and let C1, C2, . . . , Cr be cycles of its generalized eigenvectors, Ck = vk 1, vk 2, . . . , vk pk , pk being the length of the cycle Ck. Assume that the initial vectors v1 1, v2 1, . . . , vr 1 are linearly in- dependent. Then no vector belongs to two cycles, and the union of all the vectors from all the cycles is a linearly independent. Proof. Let n = p1 + p2 + . . . + pr be the total number of vectors in all the cycles2. We will use induction in n. If n = 1 the theorem is trivial. Let us now assume, that the theorem is true for all operators and for all collection of cycles, as long as the total number of vectors in all the cycles is strictly less than n. Without loss of generality we can assume that the vectors vk j span the whole space V , because, otherwise we can consider instead of the operator A its restriction onto the invariant subspace span{vk j : k = 1, 2, . . . , r, 1 ≤ j ≤ pk}. Consider the subspace Ran A. It follows from the relations (4.2), (4.3) that vectors vk j : k = 1, 2, . . . , r, 1 ≤ j ≤ pk − 1 span Ran A. Note that if pk > 1 then the system vk 1, vk 2, . . . , vk pk−1 is a cycle, and that A annihilates any cycle of length 1. Therefore, we have ﬁnitely many cycles, and initial vectors of these cycles are linearly independent, so the induction hypothesis applies, and the vectors vk j : k = 1, 2, . . . , r, 1 ≤ j ≤ pk − 1 are linearly independent. Since these vectors also span Ran A, we have a basis there. Therefore, rank A = dim Ran A = n − r 2Here we just count vectors in each cycle, and add all the numbers. We do not care if some cycles have a common vector, we count this vector in each cycle it belongs to (of course, according to the theorem, it is impossible, but initially we cannot assume that) 268 9. Advanced spectral theory (we had n vectors, and we removed one vector vk pk from each cycle Ck, k = 1, 2, . . . , r, so we have n − r vectors in the basis vk j : k = 1, 2, . . . , r, 1 ≤ j ≤ pk − 1 ). On the other hand Avk 1 = 0 for k = 1, 2, . . . , r, and since these vectors are linearly independent dim Ker A ≥ r. By the Rank Theorem (Theorem 7.1 from Chapter 2) dim V = rank A + dim Ker A = (n − r) + dim Ker A ≥ (n − r) + r = n so dim V ≥ n. On the other hand V is spanned by n vectors, therefore the vectors vk j : k = 1, 2, . . . , r, 1 ≤ j ≤ pk, form a basis, so they are linearly independent □ 4.2. Jordan canonical form of a nilpotent operator. Theorem 4.2. Let A : V → V be a nilpotent operator. Then V has a basis consisting of union of cycles of generalized eigenvectors of the operator A. Proof. We will use induction in n where n = dim V . For n = 1 the theorem is trivial. Assume that the theorem is true for any operator acting in a space of dimension strictly less than n. Consider the subspace X = Ran A. X is an invariant subspace of the operator A, so we can consider the restriction A|X . Since A is not invertible, dim Ran A < dim V , so by the induction hy- pothesis there exist cycles C1, C2, . . . , Cr of generalized eigenvectors such that their union is a basis in X. Let Ck = vk 1, vk 2, . . . , vk pk , where vk 1 is the initial vector of the cycle. Since the end vector vk pk belong to Ran A, one can ﬁnd a vector vk pk+1 such that Avpk+1 = vk pk . So we can extend each cycle Ck to a bigger cycle ̃Ck = vk 1, vk 2, . . . , vk pk , vk pk+1. Since the initial vectors vk 1 of cycles ̃Ck, k = 1, 2, . . . , r are linearly independent, the above Theorem 4.1 implies that the union of these cycles is a linearly independent system. By the deﬁnition of the cycle we have vk 1 ∈ Ker A, and we assumed that the initial vectors vk 1, k = 1, 2, . . . , r are linearly independent. Let us complete this system to a basis in Ker A, i.e. let ﬁnd vectors u1, u2, . . . , uq such that the system v1 1, v2 1, . . . , vr 1, u1, u2, . . . , uq is a basis in Ker A (it may happen that the system vk 1, k = 1, 2, . . . , r is already a basis in Ker A, in which case we put q = 0 and add nothing). The vector uj can be treated as a cycle of length 1, so we have a collec- tion of cycles ̃C1, ̃C2, . . . , ̃Cr, u1, u2, . . . , uq, whose initial vectors are linearly independent. So, we can apply Theorem 4.1 to get that the union of all these cycles is a linearly independent system. 4. Structure of nilpotent operators 269 To show that it is a basis, let us count the dimensions. We know that the cycles C1, C2, . . . , Cr have dim Ran A = rank A vectors total. Each cycle ̃Ck was obtained from Ck by adding 1 vector to it, so the total number of vectors in all the cycles ̃Ck is rank A + r. We know that dim Ker A = r + q (because v1 1, v2 1, . . . , vr 1, u1, u2, . . . , uq is a basis there). We added to the cycles ̃C1, ̃C2, . . . , ̃Cr additional q vectors, so we got rank A + r + q = rank A + dim Ker A = dim V linearly independent vectors. But dim V linearly independent vectors is a basis. □ Deﬁnition. A basis consisting of a union of cycles of generalized eigen- vectors of a nilpotent operator A (existence of which is guaranteed by the Theorem 4.2) is called a Jordan canonical basis for A. Note, that such basis is not unique. Corollary 4.3. Let A be a nilpotent operator. There exists a basis (a Jordan canonical basis) such that the matrix of A in this basis is a block diagonal diag{A1, A2, . . . , Ar}, where all Ak (except may be one) are blocks of form (4.1), and one of the blocks Ak can be zero. The matrix of A in a Jordan canonical basis is called the Jordan canoni- cal form of the operator A. We will see later that the Jordan canonical form is unique, if we agree on how to order the blocks (i.e. on how to order the vectors in the basis). Proof of Corollary 4.3. According to Theorem 4.2 one can ﬁnd a basis consisting of a union of cycles of generalized eigenvectors. A cycle of size p gives rise to a p × p diagonal block of form (4.1), and a cycle of length 1 correspond to a 1 × 1 zero block. We can join these 1 × 1 zero blocks in one large zero block (because oﬀ-diagonal entries are 0). □ 4.3. Dot diagrams. Uniqueness of the Jordan canonical form. There is a good way of visualizing Theorem 4.2 and Corollary 4.3, the so- called dot diagrams. This methods also allows us to answer many natural questions, like “is the block diagonal representation given by Corollary 4.3 unique?” Of course, if we treat this question literally, the answer is “no”, for we always can change the order of the blocks. But, if we exclude such trivial possibilities, for example by agreeing on some order of blocks (say, if we put all non-zero blocks in decreasing order, and then put the zero block), is the representation unique, or not? 270 9. Advanced spectral theory r r r r r r r r r r r r r r                          0 1 0 1 0 1 0 1 0 0 0 1 0 1 0 0 1 0 0 0 1 0 0 0  | | | | | | | | | | | | | | | | | | | | | | |  Figure 1. Dot diagram and corresponding Jordan canonical form of a nilpotent operator To better understand the structure of nilpotent operators, described in the Section 4.1, let us draw the so-called dot diagram. Namely, suppose we have a basis, which is a union of cycles of generalized eigenvalues. Let us represent the basis by an array of dots, so that each column represents a cycle. The ﬁrst row consists of initial vectors of cycles, and we arrange the columns (cycles) by their length, putting the longest one to the left. On the ﬁgure 1 we have the dot diagram of a nilpotent operator, as well as its Jordan canonical form. This dot diagram shows, that the basis has 1 cycle of length 5, one cycle of length 3, two cycles of length 2, and 2 cycles of length 1. The cycle of length 5 corresponds to the 5 × 5 block of the matrix, the cycle of length 3 correspond to 3 non-zero block, and two cycles of length 2 correspond to two 2 × 2 blocks. Three cycles of length 1 correspond to two zero entries on the diagonal. Here in each block we only giving the main diagonal and the diagonal above it; all other entries of the matrix are zero. If we agree on the ordering of the blocks, there is a one-to-one corre- spondence between dot diagrams and Jordan canonical forms (for nilpotent operators). So, the question about uniqueness of the Jordan canonical form is equivalent to the question about uniqueness of the dot diagram. To answer this question, let us analyze, how the operator A transforms the dot diagram. Since the operator A annihilates initial vectors of the cycles, and moves vector vk+1 of a cycle to the vector vk, we can see that 4. Structure of nilpotent operators 271 the operator A acts on its dot diagram by deleting the ﬁrst (top) row of the diagram. The new dot diagram corresponds to a Jordan canonical basis in Ran A, and allows us to write down the Jordan canonical form for the restriction A|Ran A. Similarly, it is not hard to see that the operator Ak removes the ﬁrst k rows of the dot diagram. Therefore, if for all k we know the dimensions dim Ker(Ak), we know the dot diagram of the operator A. Namely, the number of dots in the ﬁrst row is dim Ker A, the number of dots in the second row is dim Ker(A2) − dim Ker A, and the number of dots in the kth row is dim Ker(Ak) − dim Ker(A k+1). But this means that the dot diagram, which was initially deﬁned using a Jordan canonical basis, does not depend on a particular choice of such a basis. Therefore, the dot diagram, is unique! This implies that if we agree on the order of the blocks, then the Jordan canonical form is unique. 4.4. Computing a Jordan canonical basis. Let us say few words about computing a Jordan canonical basis for a nilpotent operator. Let p1 be the largest integer such that Ap1 ̸= 0 (so Ap1+1 = 0). One can see from the above analysis of dot diagrams, that p1 is the length of the longest cycle. Computing operators Ak, k = 1, 2, . . . , p1, and counting dim Ker(Ak) we can construct the dot diagram of A. Now we want to put vectors instead of dots and ﬁnd a basis which is a union of cycles. We start by ﬁnding the longest cycles (because we know the dot diagram, we know how many cycles should be there, and what is the length of each cycle). Consider a basis in the column space Ran(Ap1). Name the vectors in this basis v1 1, v2 1, . . . , vr1 1 , these will be the initial vectors of the cycles. Then we ﬁnd the end vectors of the cycles v1 p1, v2 p1, . . . , vr1 p1 by solving the equations A p1vk p1 = vk 1, k = 1, 2, . . . , r1. Applying consecutively the operator A to the end vector vk p1, we get all the vectors vk j in the cycle. Thus, we have constructed all cycles of maximal length. Let p2 be the length of a maximal cycle among those that are left to ﬁnd. Consider the subspace Ran(Ap2), and let dim Ran(Ap2) = r2. Since Ran(Ap1) ⊂ Ran(Ap2), we can complete the basis v1 1, v2 1, . . . , vr1 1 to a basis 272 9. Advanced spectral theory v1 1, v2 1, . . . , vr1 1 , vr1+1 1 , . . . , vr2 1 in Ran(Ar2). Then we ﬁnd end vectors of the cycles Cr1+1, . . . , Cr2 by solving (for vk p2) the equations Ap1vk p2 = vk 1, k = r1 + 1, r1 + 2, . . . , r2, thus constructing th cycles of length p2. Let p3 denote the length of a maximal cycle among ones left. Then, completing the basis v1 1, v2 1, . . . , vr2 1 in Ker(Ap2) to a basis in Ker(Ap3 we construct the cycles of length p3, and so on. . . One ﬁnal remark: as we discussed above, if we know the dot diagram, we know the canonical form, so after we have found a Jordan canonical basis, we do not need to compute the matrix of A in this basis: we already know it! 5. Jordan decomposition theorem Theorem 5.1. Given an operator A there exist a basis (Jordan canonical basis) such that the matrix of A in this basis has a block diagonal form with blocks of form (5.1)        λ 1 0 λ 1 λ . . . . . . 1 0 λ  | | | | |  where λ is an eigenvalue of A. Here we assume that the block of size 1 is just λ. The block diagonal form from Theorem 5.1 is called the Jordan canonical form of the operator A. The corresponding basis is called a Jordan canonical basis for an operator A. Proof of Theorem 5.1. According to Theorem 3.4 and Remark 3.5, if we join bases in the generalized eigenspaces Ek = Eλk to get a basis in the whole space, the matrix of A in this basis has a block diagonal form diag{A1, A2, . . . , Ar}, where Ak = A|Ek . The operators Nk = Ak − λkIEk are nilpotent, so by Theorem 4.2 (more precisely, by Corollary 4.3) one can ﬁnd a basis in Ek such that the matrix of Nk in this basis is the Jordan canonical form of Nk. To get the matrix of Ak in this basis one just puts λk instead of 0 on the main diagonal. □ 5. Jordan decomposition theorem 273 5.1. Remarks about computing Jordan canonical basis. First of all let us recall that the computing of eigenvalues is the hardest part, but here we do not discuss this part, and assume that eigenvalues are already com- puted. For each eigenvalue λ we compute subspaces Ker(A − λI)k, k = 1, 2, . . . until the sequence of the subspaces stabilizes. In fact, since we have an increasing sequence of subspaces (Ker(A − λI)k ⊂ Ker(A − λI)k+1), then it is suﬃcient only to keep track of their dimension (or ranks of the operators (A − λI)k). For an eigenvalue λ let m = mλ be the number where the sequence Ker(A − λI)k stabilizes, i.e. m satisﬁes dim Ker(A − λI) m−1 < dim Ker(A − λI) m = dim Ker(A − λI) m+1. Then Eλ = Ker(A − λI)m is the generalized eigenspace corresponding to the eigenvalue λ. After we computed all the generalized eigenspaces there are two possible ways of action. The ﬁrst way is to ﬁnd a basis in each generalized eigenspace, so the matrix of the operator A in this basis has the block-diagonal form diag{A1, A2, . . . , Ar}, where Ak = A|Eλk . Then we can deal with each ma- trix Ak separately. The operators Nk = Ak − λkI are nilpotent, so applying the algorithm described in Section 4.4 we get the Jordan canonical repre- sentation for Nk, and putting λk instead of 0 on the main diagonal, we get the Jordan canonical representation for the block Ak. The advantage of this approach is that we are working with smaller blocks. But we need to ﬁnd the matrix of the operator in a new basis, which involves inverting a matrix and matrix multiplication. Another way is to ﬁnd a Jordan canonical basis in each of the generalized eigenspaces Eλk by working directly with the operator A, without splitting it ﬁrst into the blocks. Again, the algorithm we outlined above in Section 4.4 works with a slight modiﬁcation. Namely, when computing a Jordan canonical basis for a generalized eigenspace Eλk , instead of considering sub- spaces Ran(Ak − λkI)j, which we would need to consider when working with the block Ak separately, we consider the subspaces (A − λkI)jEλk . Index Mm,n, 3 Mm×n, 3 δk,j , see Kroneker delta adjoint of an operator, 142 basis, 6 biorthogonal, see basis, dual dual, 218 of subspaces, 109 orthogonal, 127 orthonormal, 127 coordinates of a vector in the basis, 6 counting multiplicities, 102 dual basis, 218 dual space, 215 duality, 241 eigenvalue, 100 eigenvector, 100 Einstein notation, 234, 243 entry, entries of a matrix, 4 of a tensor, 246 Fourier decomposition abstract, non-orthogonal, 220, 224 abstract, orthogonal, 128, 225 Frobenius norm, 182 functional linear, 215 generalized eigenspace, 258 generalized eigenvector, 258 generating system, 7 Gram–Schmidt orthogonalization, 131 Hermitian matrix, 166 Hilbert–Schmidt norm, 182 inner product abstract, 119 in Cn, 118 inner product space, 119 invariant subspace, 253 isometry, 146 Jordan canonical basis, 267, 270 form, 267, 270 basis for a nilpotent operator, 267 form for a nilpotent operator, 267 Jordan decomposition theorem, 270 for a nilpotent operator, 267 Kroneker delta, 218, 224 least square solution, 136 minimal norm, 185 linear combination, 6 trivial, 8 linear functional, 215 linearly dependent, 8 linearly independent, 8 matrix, 4 275 276 Index antisymmetric, 11 Hermitian, 166 lower triangular, 81 symmetric, 5, 11 triangular, 81 upper triangular, 31, 81 minor, 96 Moore–Penrose inverse, 185 multilinear function, 237 multilinear functional, see tensor multiplicities counting, 102 multiplicity algebraic, 102 geometric, 103 norm, 117, 123 Euclidean in Rn or Cn, 117 Frobenius, 182 Hilbert–Scmidt, 182 operator, of a linear transformation, 181 normal operator, 167 normed space, 123 operator norm, 181 orthogonal complement, 133 orthogonal projection, 129 polynomial matrix, 94 projection orthogonal, 129 Schmidt decomposition, 174 self-adjoint operator, 166 singular value decomposition, 176 reduced (compact) form, 176 singular values, 173 space dual, 215 Spectral theory, 99 spectrum, 100 submatrix, 96 subspace invariant, 253 tensor, 237 r-covariant s-contravariant, 241 contravariant, 241 covariant, 241 trace, 23 transpose, 4 triangular matrix, 81 eigenvalues of, 103 unitary operator, 147 valency of a tensor, 237","libVersion":"0.2.2","langs":""}